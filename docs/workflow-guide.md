# Claude Code Workflow Guide for ORbit

## Complete Setup & Walkthrough

This guide walks you through setting up a streamlined Claude Code workflow from scratch, using ORbit as the working example. By the end, you'll have a system that eliminates manual handoff reports, reduces token waste, and lets you tackle large features across multiple sessions without compounding context.

---

## Part 1: The File Structure

First, let's set up the directory structure inside your ORbit project. You'll create a few folders and files that Claude Code uses automatically.

```
orbit/
├── .claude/
│   ├── commands/           # Custom slash commands (reusable workflows)
│   │   ├── phase-start.md
│   │   ├── audit.md
│   │   └── wrap-up.md
│   ├── agents/             # Specialist subagents
│   │   ├── tester.md
│   │   └── reviewer.md
│   └── settings.json       # (auto-generated by Claude Code)
├── CLAUDE.md               # Lean project context (Claude reads this every session)
├── docs/
│   ├── active-feature.md   # Current feature spec (swap this per task)
│   └── architecture.md     # Deeper reference Claude reads on-demand
└── ... (your normal project files)
```

### Why this structure matters

- `.claude/commands/` — These are slash commands you can run like `/phase-start` or `/wrap-up`. They replace your manual "okay Claude, read the files and continue where we left off" prompts.
- `.claude/agents/` — These are specialist subagents that get their own context window. Their output doesn't bloat your main session.
- `CLAUDE.md` — Claude reads this automatically at the start of every session. Keep it lean (~50-100 lines). Think of it as a routing table, not an encyclopedia.
- `docs/` — Detailed specs live here. Claude reads them on-demand when needed, not upfront.

---

## Part 2: Setting Up CLAUDE.md

This is the most important file. Your current approach of writing a complete project directory doc is eating tokens. Instead, write a lean CLAUDE.md that gives Claude just enough to orient itself, and points to detailed docs only when needed.

```markdown
# ORbit - Surgical Analytics Platform

## Stack
- Web: Next.js (App Router), TypeScript, Supabase, Vercel
- iOS: SwiftUI
- DB: Supabase PostgreSQL with triggers, materialized views, RLS

## Key Patterns (follow these always)
- Use `useSupabaseQuery` hook for ALL data fetching (no manual fetch/useEffect)
- Auto-save with optimistic updates for toggle/settings UIs (no save buttons)
- Median-over-average for all OR analytics calculations
- Volume-weighted scoring for scorecards
- Commit after completing each phase of work
- Run `npm run typecheck && npm run lint && npm run test` after changes

## Project Structure
- `/src/app/` — Next.js App Router pages
- `/src/components/` — Shared React components
- `/src/hooks/` — Custom hooks including useSupabaseQuery
- `/src/lib/` — Utilities, Supabase client, types
- `/supabase/migrations/` — SQL migration files
- `/ios/ORbit/` — SwiftUI iOS app

## Current Work
See `docs/active-feature.md` for the current feature spec and requirements.

## Architecture Reference
For database schemas, trigger systems, and analytics pipeline details,
read `docs/architecture.md` (only read this when you need DB/analytics context).

## Conventions
- TypeScript strict mode, no `any` types
- Use shadcn/ui components
- Toast notifications via sonner
- Date handling: always use facility timezone, never UTC for display
- Milestone ordering: by sequence number, not by timestamp
```

### What changed from your old approach

| Before (your old way) | After (new way) |
|---|---|
| Full project directory listing | Just the folder structure summary |
| Complete database schema in CLAUDE.md | Pointer to `docs/architecture.md` |
| Feature requirements in CLAUDE.md | Pointer to `docs/active-feature.md` |
| ~500+ lines loaded every session | ~50 lines loaded every session |
| Claude reads everything upfront | Claude reads details on-demand |

---

## Part 3: Writing a Feature Spec

When you have a large task, write it as a feature spec in `docs/active-feature.md`. This is what you'd normally put in your giant CLAUDE.md — but now it only gets loaded when Claude actually needs it.

Here's an example for the case detail page redesign:

```markdown
# Feature: Case Detail Page Redesign

## Goal
Redesign the case detail page as ORbit's most-used feature. Inspired by
Raycast's interface patterns — clean, fast, information-dense.

## Requirements
1. Header: Case ID, surgeon name, procedure, date, status badge
2. Timeline: Visual milestone timeline with durations between milestones
3. Metrics panel: Key efficiency metrics (turnover time, case duration, etc.)
4. Detail tabs: Milestones, Notes, Flags/Delays, Billing
5. Edit capability: Inline editing for milestone times with auto-save
6. Mobile responsive: Must work on tablet in OR environment

## Database Context
- Cases table: id, facility_id, surgeon_id, procedure_name, case_date, status
- Milestones table: id, case_id, milestone_type, recorded_at, sequence_number
- Flags table: id, case_id, flag_type, description, created_at
- Key relationships: cases -> milestones (1:many), cases -> flags (1:many)

## Known Issues
- Milestone ordering bug: some facilities have duplicate sequence numbers
- Timezone display: facility_timezone must be used, not UTC
- useSupabaseQuery migration: all fetch calls must use the hook

## Files Likely Involved
- /src/app/cases/[id]/page.tsx (main page)
- /src/components/cases/ (case-specific components)
- /src/hooks/useCaseDetail.ts (data hook)

## Out of Scope
- Block scheduling integration
- Surgeon comparison views
- PDF export
```

### Why this works better

Claude only reads this file when it encounters a task that references "active feature" or when your commands tell it to. It doesn't consume tokens sitting in CLAUDE.md on sessions where you're doing something unrelated.

---

## Part 4: Custom Commands

These are the real workflow accelerators. Instead of typing long prompts to explain what you want Claude to do, you create reusable commands.

### Command: `/audit` — Analyze and plan

Create `.claude/commands/audit.md`:

```markdown
description: Audit the active feature and create a phased implementation plan
---

Read `docs/active-feature.md` to understand the current feature requirements.

Analyze the existing codebase for files related to this feature. Check:
1. Which files already exist and their current state
2. What's missing vs. what needs refactoring
3. Any type errors or lint issues in related files
4. Database schema alignment with requirements

Then create a phased implementation plan:
- Break the work into 3-5 phases
- Each phase should be completable in one session (~30 min of work)
- Each phase should end with a working (non-broken) state
- List the specific files to create/modify in each phase
- Note dependencies between phases

Create this plan as tasks with dependencies using TaskCreate.
Also save the plan to `docs/implementation-plan.md` as a readable reference.

After creating the plan, stop and wait for approval before starting any phase.
```

### Command: `/phase-start` — Pick up where you left off

Create `.claude/commands/phase-start.md`:

```markdown
description: Start or continue the next phase of implementation
---

1. Check the current task list for incomplete tasks
2. Read `docs/active-feature.md` for feature context
3. Read `docs/implementation-plan.md` if it exists
4. Look at recent git commits to understand what's already been done
5. Identify the next incomplete phase/task

Before starting work:
- Run `git status` to check for any uncommitted changes
- Run the test suite to confirm current state is clean

Then proceed with the next phase. After completing it:
- Run typecheck, lint, and tests
- Fix any issues
- Commit with a descriptive message: "feat(case-detail): phase N - description"
- Update the task status to completed
```

### Command: `/wrap-up` — End a session cleanly

Create `.claude/commands/wrap-up.md`:

```markdown
description: Wrap up the current session and prepare for handoff
---

1. Run the full test suite: `npm run typecheck && npm run lint && npm run test`
2. Fix any issues found
3. Commit all remaining changes
4. Update task statuses (mark completed ones, note in-progress ones)
5. Update `docs/implementation-plan.md` with:
   - Which phases are complete
   - Current phase progress (what's done, what's remaining)
   - Any blockers or decisions that need to be made
   - Any unexpected issues encountered

Keep the update concise — bullet points, not paragraphs.
```

### How to use these commands

In Claude Code, you just type:

```
> /audit              # Analyzes and creates the plan
> /phase-start        # Picks up the next phase
> /wrap-up            # Cleanly ends the session
```

No more typing "okay read all the files and tell me where we left off." The commands handle it.

---

## Part 5: Subagents for Testing

Testing output is one of the biggest context polluters. A full test suite run can dump thousands of tokens of output into your main context. Instead, delegate it to a subagent.

Create `.claude/agents/tester.md`:

```yaml
---
name: tester
description: Runs typecheck, lint, and test suites. Reports only failures.
allowed-tools:
  - Bash
  - Read
---

You are a testing agent. Run the following checks in order:

1. TypeScript: `npx tsc --noEmit`
2. Lint: `npm run lint`
3. Tests: `npm run test`

For each check, report:
- ✅ PASS with zero details if everything passes
- ❌ FAIL with ONLY the specific error messages (not full stack traces)

Format your response as a brief summary, like:
- TypeScript: ✅ PASS
- Lint: ❌ 2 errors in src/components/CaseTimeline.tsx (unused import, missing type)
- Tests: ✅ 14/14 passing

Do not include full command output. Only report actionable information.
```

Now in your main session, instead of running tests directly (which dumps all that output into your context), you say:

```
Use the tester agent to run the full test suite
```

The tester gets its own context window, runs everything, and returns just the summary to your main session. Your main context stays clean.

---

## Part 6: The Complete Workflow (Step by Step)

Here's the entire flow for tackling a large feature, start to finish.

### Day 1: Setup (5 minutes)

**Step 1:** Write your feature spec

```bash
# Write/update docs/active-feature.md with the feature requirements
# (You can do this in your editor or have Claude help draft it here in chat)
```

**Step 2:** Open Claude Code and run the audit

```
> /audit
```

Claude reads the feature spec, analyzes the codebase, and creates:
- A set of Tasks with dependencies (persisted to disk)
- `docs/implementation-plan.md` with the readable plan

**Step 3:** Review the plan

Claude shows you the plan and waits. You review the phases, adjust if needed, then approve.

**Step 4:** Accept and start

When you accept the plan, Claude Code automatically clears context (this is a new built-in feature). You get a fresh context window but the Tasks persist on disk.

### Day 1-N: Implementation (repeating cycle)

**Step 5:** Start a phase

```
> /phase-start
```

Claude checks the task list, finds the next incomplete phase, verifies the current state with tests, and starts working.

**Step 6:** Work through the phase

Claude implements the phase. You can interact, ask questions, steer decisions. The key is that each phase is scoped to be completable in one session.

**Step 7:** Monitor context usage

Watch the context meter in the bottom right of Claude Code. Two scenarios:

**If context hits ~70%** and you're mid-phase:
```
/compact focus on the case detail page changes and the current phase progress
```
This summarizes the conversation, preserves key decisions, and gives you back most of your context window. You can keep working in the same session.

**If you finish a phase** cleanly:
```
> /wrap-up
```
This runs tests, commits, and updates the plan. Then start a new session:
```
# In terminal:
claude --continue
# or just start a new claude session and run:
> /phase-start
```

The Tasks persist across sessions, so `/phase-start` in a new session knows exactly where you left off.

**Step 8:** Repeat until done

Each new session: `/phase-start` → work → `/wrap-up` or `/compact` → continue.

### Final: Verification

After all phases are complete:

```
Use the tester agent to run the full test suite

Then review the complete implementation against docs/active-feature.md
and confirm all requirements are met.
```

---

## Part 7: Key Differences From Your Old Workflow

| Step | Your Old Way | New Way |
|---|---|---|
| **Project context** | Write complete CLAUDE.md with full directory | Lean CLAUDE.md (~50 lines) + detailed docs on-demand |
| **Planning** | Claude does audit, you manually save it | `/audit` command creates Tasks + plan file automatically |
| **Session handoff** | Claude writes report, you paste it into new session | Tasks persist on disk, `/phase-start` auto-resumes |
| **Context management** | Stop at 60%, start new session | `/compact` at 70% to keep working, or `/wrap-up` + new session |
| **Testing** | Run tests in main session (eats context) | Tester subagent runs tests in isolated context |
| **Resuming** | "Read all the files and continue" | `/phase-start` (3 words) |
| **Progress tracking** | Manual report files | Tasks with dependencies (built-in, persistent) |

## Part 8: Pro Tips

### Tip 1: Use `/compact` with focus instructions

Don't just run `/compact`. Tell it what to preserve:

```
/compact focus on the CaseTimeline component refactoring decisions
and the remaining milestone ordering bug fix
```

This gives you a much better summary than the default.

### Tip 2: Use `claude --continue` vs `claude --resume`

- `claude --continue` — Picks up the most recent session automatically
- `claude --resume` — Shows you a list of recent sessions to choose from (press P to preview before selecting)

### Tip 3: Git worktrees for parallel work

If you want to work on the web app and iOS app simultaneously:

```bash
# Create a worktree for iOS work
git worktree add ../orbit-ios-work ios-feature-branch

# Terminal 1: Web work in main directory
cd orbit && claude

# Terminal 2: iOS work in worktree
cd ../orbit-ios-work && claude
```

Each Claude session is fully isolated. They can't interfere with each other.

### Tip 4: Check context usage anytime

Run `/context` in Claude Code to see exactly what's consuming your context window. This helps you identify if CLAUDE.md is too large or if a particular tool output bloated things.

### Tip 5: Subagent for codebase exploration

Before starting a feature, you can have a subagent explore without polluting your main context:

```
Use a subagent to investigate how the milestone recording system works.
Check the database triggers, the API routes, and the frontend hooks.
Report back with a summary of the data flow.
```

The subagent reads dozens of files, but only a concise summary enters your main context.

### Tip 6: Custom compact instructions in CLAUDE.md

Add this to your CLAUDE.md so auto-compaction preserves what matters:

```markdown
## Compact Instructions
When compacting, always preserve:
- Current phase number and progress
- Any architectural decisions made this session
- File paths that were modified
- Any bugs discovered but not yet fixed
```

---

## Quick Reference Card

| Action | Command |
|---|---|
| Start a new feature | Write `docs/active-feature.md`, then `/audit` |
| Begin/resume work | `/phase-start` |
| Run tests (without polluting context) | "Use the tester agent to run tests" |
| Reclaim context mid-session | `/compact focus on [what matters]` |
| End a session cleanly | `/wrap-up` |
| Resume last session | `claude --continue` |
| Pick a specific session | `claude --resume` |
| Check context usage | `/context` |
| See task list | `Ctrl+T` |
| Parallel work | `git worktree add` + separate terminals |
| Fresh start (wipe context) | `/clear` |

---

## Getting Started Checklist

- [ ] Create `.claude/commands/audit.md` (copy from Part 4)
- [ ] Create `.claude/commands/phase-start.md` (copy from Part 4)
- [ ] Create `.claude/commands/wrap-up.md` (copy from Part 4)
- [ ] Create `.claude/agents/tester.md` (copy from Part 5)
- [ ] Rewrite your `CLAUDE.md` to be lean (copy from Part 2, customize)
- [ ] Create `docs/architecture.md` with your detailed DB/analytics reference
- [ ] Write your first `docs/active-feature.md` for your current task
- [ ] Run `/audit` and see it work
