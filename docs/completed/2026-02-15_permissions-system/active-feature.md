# Feature: Granular Permissions System

## Goal
Implement a feature-level permissions system that replaces hardcoded role checks with a dynamic, database-driven permission resolution system. Global admins configure permission templates, facility admins customize per-facility permissions, and the frontend gates UI based on resolved permissions via a `can()` API.

## Requirements
1. Database schema: permissions registry, permission templates, facility permissions tables
2. RPC function to resolve user permissions (single call, cached in UserContext)
3. `usePermissions` hook integrated into UserContext with `can()`, `canAny()`, `canAll()`
4. Shared PermissionMatrix component for both admin pages
5. Global admin permission templates page (`/admin/permission-templates`)
6. Facility admin permissions page (`/settings/permissions`)
7. Full UI integration: replace all hardcoded role checks with `can()` calls
8. Sync detection: prompt global admin when facilities are missing new permissions

## Database Context
- Table: `permissions` — master registry of all permission keys, grouped by category
- Table: `permission_templates` — default grants per access_level (user, coordinator)
- Table: `facility_permissions` — per-facility overrides of template defaults
- Function: `get_user_permissions()` — resolves final permission set for current user
- Function: `user_has_permission(key)` — helper for RLS policies (future use)
- Function: `get_my_access_level()` — helper returning current user's access level
- Function: `get_my_facility_id()` — helper returning current user's facility
- Function: `copy_permission_template_to_facility(facility_id)` — copies template to new facility

## UI/UX
- Route: `/admin/permission-templates` — Global admin template management
- Route: `/settings/permissions` — Facility admin permission management
- Both pages: Tab selector (User | Coordinator), permission matrix grouped by category
- Matrix uses existing Toggle component (sm size) for each permission
- Auto-save per toggle with brief toast confirmation
- AccessDenied component for unauthorized page access

## Files Likely Involved
- `lib/UserContext.tsx` — Add can()/canAny()/canAll(), parallel permission fetch
- `lib/hooks/usePermissions.ts` — New hook using useSupabaseQuery
- `components/permissions/PermissionMatrix.tsx` — Shared matrix component
- `components/ui/AccessDenied.tsx` — New access denied page component
- `app/admin/permission-templates/page.tsx` — Global admin page
- `app/settings/permissions/page.tsx` — Facility admin page
- `components/layouts/navigation-config.tsx` — Replace allowedRoles with can()
- `components/settings/SettingsLayout.tsx` — Replace requiredAccess with can()
- `supabase/migrations/20260215000000_permissions_system.sql` — Single migration

## iOS Parity
- [ ] iOS equivalent needed
- [x] iOS can wait (database RPC is platform-agnostic; iOS consumes same function later)

## Known Issues / Constraints
- Device reps are separate entities (not in users table) — excluded from permission system
- Permissions fetched once per session (next page load); no real-time subscription
- Phase 5 (RLS hardening) deferred to separate project
- No TypeScript enum for permission keys — DB is source of truth, plain strings

## Out of Scope
- Device rep permissions (separate access model)
- RLS hardening (Phase 5 — deferred)
- iOS implementation
- Real-time permission sync
- Per-user permission overrides (only per-facility, per-access-level)

## Acceptance Criteria
- [ ] Permission matrix renders dynamically from DB (adding a permission row auto-appears in UI)
- [ ] Global admin can configure default templates for user and coordinator roles
- [ ] Facility admin can customize permissions for their facility
- [ ] `can()` correctly resolves permissions: admin bypass, facility-scoped, default-deny
- [ ] All hardcoded role checks replaced with `can()` calls
- [ ] Navigation items show/hide based on permissions
- [ ] AccessDenied component shown for unauthorized page access
- [ ] Impersonation works: global admin sees impersonated facility's permissions
- [ ] Sync banner shows when facilities are missing new permissions
- [ ] All tests pass (`npm run typecheck && npm run lint && npm run test`)
- [ ] No TypeScript `any` types introduced

---

## Review Q&A

> Generated by /review on 2026-02-14

**Q1:** The implementation plan creates permission templates for access_levels 'user' and 'device_rep', but the current UserContext (lib/UserContext.tsx:14) defines access_levels as 'global_admin' | 'facility_admin' | 'coordinator' | 'user'. 'coordinator' is missing from the plan and 'device_rep' is missing from the UserContext type. What are the actual access levels that need permission templates?
**A1:** user + device_rep + coordinator — All three non-admin roles get permission templates. (Later revised: device_rep excluded — see Q17.)

**Q2:** The implementation plan defines tab-level permissions for 5 case drawer tabs: overview, financials, milestones, implants, and staff. But the actual CaseDrawer only has 4 tabs: financials, milestones, flags, and validation. Should we create permissions for the tabs that actually exist, or the planned ones?
**A2:** Match actual tabs — Create permissions for: tab.case_financials, tab.case_milestones, tab.case_flags, tab.case_validation. Drop the non-existent overview/implants/staff tab permissions.

**Q3:** The current codebase has several hardcoded role checks (canCreateCases, allowedRoles, requiredAccess). When we implement the permissions system, should these be replaced by can() or remain as a parallel layer?
**A3:** Replace with can() — Remove all hardcoded role checks and replace with can() calls. The permissions system becomes the single source of truth.

**Q4:** Where should the facility-level permissions page go in the Settings sidebar?
**A4:** Organization group — Place 'Roles & Permissions' alongside 'Users & Roles'. These are closely related concepts.

**Q5:** Which admin navigation group should 'Permission Templates' go in?
**A5:** Management group — Alongside 'Facilities'. Templates control how new facilities are configured.

**Q6:** The plan references SQL helper functions `get_my_access_level()` and `get_my_facility_id()` that don't exist in the codebase or migrations. Do they exist in Supabase, or do we need to create them?
**A6:** Create them in Phase 1 — These functions don't exist. Create them in the Phase 1 migration.

**Q7:** The plan's usePermissions hook uses raw supabase calls, but CLAUDE.md says to always use useSupabaseQuery. Which pattern?
**A7:** Use useSupabaseQuery — Follow the established pattern. Keeps the codebase consistent.

**Q8:** When a global admin impersonates a facility, how should the permissions page handle data fetching?
**A8:** Explicit facility_id param — The facility permissions page queries directly with effectiveFacilityId (like every other settings page). Global admin RLS policies grant full access.

**Q9:** Once we add can() to UserContext, should we remove the old convenience booleans (isGlobalAdmin, isFacilityAdmin, isAdmin, canCreateCases, isCoordinator)?
**A9:** Keep isGlobalAdmin + isAdmin, remove the rest — isGlobalAdmin is needed for impersonation logic. isAdmin is useful bypass shorthand. Remove canCreateCases, isFacilityAdmin, and isCoordinator since can() replaces them.

**Q10:** For the permission matrix, should we use the existing Toggle component or simpler checkboxes?
**A10:** Use existing Toggle (sm size) — Consistent with the rest of the app's design system.

**Q11:** Auto-save with debounce, batch save with button, or auto-save per toggle?
**A11:** Auto-save per toggle — Each toggle immediately upserts the permission. Show a brief toast 'Saved'.

**Q12:** Should Phase 4 (Full UI Integration) be split into sub-phases?
**A12:** Split Phase 4 into 2-3 sub-phases — 4a: Navigation + route-level guards. 4b: Action buttons + component-level gating.

**Q13:** Should Phase 5 (RLS Hardening) be included or deferred?
**A13:** Defer Phase 5 to separate project — Ship Phases 1-4 as a complete feature. RLS hardening is a separate security concern.

**Q14:** What happens when a new permission is added to the permissions table but existing facilities don't have it?
**A14:** Prompt admin to propagate — Show a banner in the admin UI when facilities are missing permissions, with a "Push template defaults" action.

**Q15:** When a user navigates to a page they don't have permission for, what should happen?
**A15:** Show AccessDenied component — Render an in-page message with a link back to dashboard. Non-disruptive and clear.

**Q16:** Seed all 41 permissions now, or only ones with actionable UI?
**A16:** Seed all 41 now — Having unused permissions in the DB is harmless. When features are built later, the permissions are already there.

**Q17:** The plan seeds default permissions for 'device_rep'. Are device reps actual users in the users table with access_level='device_rep', or separate entities?
**A17:** Separate entity, not in users table — Device reps use facility_device_reps/device_rep_invites tables. The permission system shouldn't target them.

**Q18:** Given only two non-admin roles (user, coordinator), keep tabs or switch to dropdown?
**A18:** Keep tabs with 2 options — Two tabs: User | Coordinator.

**Q19:** What should coordinator's default permissions look like?
**A19:** Nearly facility_admin level — Grant most things except: settings.manage, users.manage, audit.view.

**Q20:** Single migration file or split into multiple?
**A20:** Single migration file — One file with all tables, functions, seeds, and backfill.

**Q21:** Should the plan order (1→2→3→4) change?
**A21:** Plan order is correct — Prove the plumbing before building the management UI.

**Q22:** How to handle the loading state for the permissions fetch?
**A22:** Parallel fetch in UserContext — Fetch user data AND permissions concurrently. Set loading=false when both complete.

**Q23:** When a facility admin changes a permission, should it take effect immediately for logged-in users?
**A23:** Next page load only — Simple and standard. No real-time subscription needed.

**Q24:** Should PermissionGuard include a loading state?
**A24:** Skip loading state in guard — By the time PermissionGuard renders, UserContext is already loaded. Just check can() and render.

**Q25:** Should the frontend have typed permission keys or rely on DB as source of truth?
**A25:** DB is source of truth, loose typing — Permission keys are plain strings. No TypeScript enum. Maximum flexibility.
