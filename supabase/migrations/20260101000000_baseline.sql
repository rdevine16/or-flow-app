-- Baseline schema dump from production
-- Generated by pg_dump on 2026-02-16

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: public; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA IF NOT EXISTS public;


--
-- Name: archive_old_audit_logs(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.archive_old_audit_logs() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  archived_count INTEGER;
BEGIN
  -- For now, we just return count of old records
  -- In production, you'd COPY these to S3/cold storage then delete
  SELECT COUNT(*) INTO archived_count
  FROM audit_log
  WHERE created_at < NOW() - INTERVAL '2 years';
  
  RETURN archived_count;
END;
$$;


--
-- Name: audit_case_device_companies_changes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.audit_case_device_companies_changes() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_facility_id UUID;
  v_case_number TEXT;
  v_company_name TEXT;
  v_user_id UUID;
  v_user_email TEXT;
  v_platform TEXT;
  v_action TEXT;
  v_target_label TEXT;
  v_old_values JSONB;
  v_new_values JSONB;
BEGIN
  -- Get facility_id and case_number from the case
  SELECT c.facility_id, c.case_number 
  INTO v_facility_id, v_case_number
  FROM cases c 
  WHERE c.id = COALESCE(NEW.case_id, OLD.case_id);
  
  -- Get company name
  SELECT name INTO v_company_name
  FROM implant_companies
  WHERE id = COALESCE(NEW.implant_company_id, OLD.implant_company_id);
  
  -- Determine the user who made the change
  -- Cast to text first to avoid UUID comparison issues with empty string
  IF TG_OP = 'DELETE' THEN
    v_user_id := auth.uid();
  ELSE
    v_user_id := COALESCE(
      CASE WHEN NEW.delivered_by IS NOT NULL THEN NEW.delivered_by END,
      CASE WHEN NEW.confirmed_by IS NOT NULL THEN NEW.confirmed_by END,
      auth.uid()
    );
  END IF;
  
  -- Get user email (handle case where user_id might be null)
  IF v_user_id IS NOT NULL THEN
    SELECT email INTO v_user_email
    FROM auth.users
    WHERE id = v_user_id;
  END IF;
  
  -- Get platform (default to 'web' if not set)
  v_platform := COALESCE(NEW.last_modified_platform, OLD.last_modified_platform, 'web');
  
  -- Determine action and build old/new values based on what changed
  IF TG_OP = 'INSERT' THEN
    v_action := 'case.implant_company_added';
    v_target_label := format('%s - Case #%s', v_company_name, v_case_number);
    v_new_values := jsonb_build_object(
      'implant_company', v_company_name,
      'case_number', v_case_number,
      'tray_status', NEW.tray_status
    );
    
  ELSIF TG_OP = 'UPDATE' THEN
    -- Check what specifically changed and set appropriate action
    IF OLD.tray_status IS DISTINCT FROM NEW.tray_status THEN
      CASE NEW.tray_status
        WHEN 'consignment' THEN
          v_action := 'device_rep.tray_consignment_confirmed';
          v_target_label := format('%s - Case #%s', v_company_name, v_case_number);
          v_old_values := jsonb_build_object('tray_status', OLD.tray_status);
          v_new_values := jsonb_build_object(
            'tray_status', 'consignment',
            'notes', NEW.rep_notes
          );
          
        WHEN 'loaners_confirmed' THEN
          v_action := 'device_rep.tray_loaners_confirmed';
          v_target_label := format('%s loaner trays - %s - Case #%s', NEW.loaner_tray_count, v_company_name, v_case_number);
          v_old_values := jsonb_build_object('tray_status', OLD.tray_status);
          v_new_values := jsonb_build_object(
            'tray_status', 'loaners_confirmed',
            'loaner_tray_count', NEW.loaner_tray_count,
            'notes', NEW.rep_notes
          );
          
        WHEN 'delivered' THEN
          v_action := 'device_rep.trays_delivered';
          v_target_label := format('%s trays delivered - %s - Case #%s', COALESCE(NEW.delivered_tray_count, NEW.loaner_tray_count, 0), v_company_name, v_case_number);
          v_old_values := jsonb_build_object(
            'tray_status', OLD.tray_status,
            'loaner_tray_count', OLD.loaner_tray_count
          );
          v_new_values := jsonb_build_object(
            'tray_status', 'delivered',
            'delivered_tray_count', NEW.delivered_tray_count
          );
          
        WHEN 'pending' THEN
          v_action := 'device_rep.tray_status_reset';
          v_target_label := format('%s - Case #%s', v_company_name, v_case_number);
          v_old_values := jsonb_build_object(
            'tray_status', OLD.tray_status,
            'loaner_tray_count', OLD.loaner_tray_count,
            'delivered_tray_count', OLD.delivered_tray_count
          );
          v_new_values := jsonb_build_object('tray_status', 'pending');
          
        ELSE
          v_action := 'device_rep.tray_status_changed';
          v_target_label := format('%s - Case #%s', v_company_name, v_case_number);
          v_old_values := jsonb_build_object('tray_status', OLD.tray_status);
          v_new_values := jsonb_build_object('tray_status', NEW.tray_status);
      END CASE;
      
    ELSIF OLD.rep_notes IS DISTINCT FROM NEW.rep_notes THEN
      v_action := 'device_rep.notes_updated';
      v_target_label := format('%s - Case #%s', v_company_name, v_case_number);
      v_old_values := jsonb_build_object('notes', OLD.rep_notes);
      v_new_values := jsonb_build_object('notes', NEW.rep_notes);
      
    ELSE
      -- Generic update
      v_action := 'device_rep.tray_updated';
      v_target_label := format('%s - Case #%s', v_company_name, v_case_number);
      v_old_values := to_jsonb(OLD);
      v_new_values := to_jsonb(NEW);
    END IF;
    
  ELSIF TG_OP = 'DELETE' THEN
    v_action := 'case.implant_company_removed';
    v_target_label := format('%s - Case #%s', v_company_name, v_case_number);
    v_old_values := jsonb_build_object(
      'implant_company', v_company_name,
      'case_number', v_case_number,
      'tray_status', OLD.tray_status
    );
  END IF;
  
  -- Insert into audit_log (matching existing schema)
  INSERT INTO audit_log (
    user_id,
    user_email,
    facility_id,
    action,
    target_type,
    target_id,
    target_label,
    old_values,
    new_values,
    metadata,
    success
  ) VALUES (
    v_user_id,
    v_user_email,
    v_facility_id,
    v_action,
    'case_device_company',
    COALESCE(NEW.id, OLD.id),
    v_target_label,
    v_old_values,
    v_new_values,
    jsonb_build_object(
      'platform', v_platform,
      'case_id', COALESCE(NEW.case_id, OLD.case_id),
      'implant_company_id', COALESCE(NEW.implant_company_id, OLD.implant_company_id)
    ),
    true
  );
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


--
-- Name: audit_case_implants_changes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.audit_case_implants_changes() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  case_number_val TEXT;
  facility_id_val UUID;
  user_email_val TEXT;
BEGIN
  -- Skip audit logging if no user session (service role / demo data generation)
  IF auth.uid() IS NULL THEN
    IF TG_OP = 'DELETE' THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  -- Get case info for context
  SELECT case_number, facility_id INTO case_number_val, facility_id_val
  FROM cases WHERE id = COALESCE(NEW.case_id, OLD.case_id);

  -- Get user email from users table (more reliable than auth.email())
  SELECT email INTO user_email_val
  FROM users WHERE id = auth.uid();

  -- Fallback if not found
  IF user_email_val IS NULL THEN
    user_email_val := COALESCE(auth.email(), 'unknown');
  END IF;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO audit_log (
      user_id,
      user_email,
      facility_id,
      action,
      target_type,
      target_id,
      target_label,
      new_values
    ) VALUES (
      auth.uid(),
      user_email_val,
      facility_id_val,
      'case_implants.created',
      'case_implants',
      NEW.id,
      'Case #' || case_number_val,
      to_jsonb(NEW)
    );
    RETURN NEW;
    
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO audit_log (
      user_id,
      user_email,
      facility_id,
      action,
      target_type,
      target_id,
      target_label,
      old_values,
      new_values
    ) VALUES (
      auth.uid(),
      user_email_val,
      facility_id_val,
      'case_implants.updated',
      'case_implants',
      NEW.id,
      'Case #' || case_number_val,
      to_jsonb(OLD),
      to_jsonb(NEW)
    );
    RETURN NEW;
    
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO audit_log (
      user_id,
      user_email,
      facility_id,
      action,
      target_type,
      target_id,
      target_label,
      old_values
    ) VALUES (
      auth.uid(),
      user_email_val,
      facility_id_val,
      'case_implants.deleted',
      'case_implants',
      OLD.id,
      'Case #' || case_number_val,
      to_jsonb(OLD)
    );
    RETURN OLD;
  END IF;
  
  RETURN NULL;
END;
$$;


--
-- Name: auto_create_patient_checkin(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.auto_create_patient_checkin() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_expected_status_id UUID;
  v_expected_arrival TIMESTAMPTZ;
BEGIN
  -- Only create for scheduled cases (not cancelled, etc.)
  IF NEW.status_id IS NOT NULL THEN
    -- Check if the status is 'scheduled'
    PERFORM 1 FROM case_statuses WHERE id = NEW.status_id AND name = 'scheduled';
    IF NOT FOUND THEN
      RETURN NEW;
    END IF;
  END IF;
  
  -- Get the 'expected' patient status ID
  SELECT id INTO v_expected_status_id FROM patient_statuses WHERE name = 'expected';
  IF NOT FOUND THEN
    RETURN NEW;  -- Skip if patient statuses not set up
  END IF;
  
  -- Calculate expected arrival time
  v_expected_arrival := calculate_expected_arrival(
    NEW.facility_id,
    NEW.procedure_type_id,
    NEW.scheduled_date,
    NEW.start_time
  );
  
  -- Insert check-in record (ignore if already exists)
  INSERT INTO patient_checkins (
    case_id,
    facility_id,
    patient_status_id,
    expected_arrival_time
  ) VALUES (
    NEW.id,
    NEW.facility_id,
    v_expected_status_id,
    v_expected_arrival
  )
  ON CONFLICT (case_id) DO UPDATE SET
    expected_arrival_time = EXCLUDED.expected_arrival_time,
    updated_at = NOW();
  
  RETURN NEW;
END;
$$;


--
-- Name: calculate_case_costs(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculate_case_costs(p_procedure_type_id uuid, p_surgeon_id uuid, p_facility_id uuid) RETURNS TABLE(total_debits numeric, total_credits numeric, net_cost numeric)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_total_debits NUMERIC := 0;
  v_total_credits NUMERIC := 0;
BEGIN
  -- Get all cost categories for this facility
  -- For each category, check if surgeon has override, otherwise use procedure default
  
  WITH effective_costs AS (
    -- Start with procedure-level cost items
    SELECT 
      pci.cost_category_id,
      cc.type as category_type,
      pci.amount as procedure_amount,
      -- Check for surgeon override
      (
        SELECT sci.amount 
        FROM surgeon_cost_items sci 
        WHERE sci.surgeon_id = p_surgeon_id 
          AND sci.procedure_type_id = p_procedure_type_id
          AND sci.cost_category_id = pci.cost_category_id
        LIMIT 1
      ) as surgeon_amount
    FROM procedure_cost_items pci
    JOIN cost_categories cc ON cc.id = pci.cost_category_id
    WHERE pci.procedure_type_id = p_procedure_type_id
    
    UNION
    
    -- Also include surgeon-only cost items (additions, not overrides)
    SELECT 
      sci.cost_category_id,
      cc.type as category_type,
      NULL as procedure_amount,
      sci.amount as surgeon_amount
    FROM surgeon_cost_items sci
    JOIN cost_categories cc ON cc.id = sci.cost_category_id
    WHERE sci.surgeon_id = p_surgeon_id
      AND sci.procedure_type_id = p_procedure_type_id
      AND NOT EXISTS (
        SELECT 1 FROM procedure_cost_items pci2 
        WHERE pci2.procedure_type_id = p_procedure_type_id 
          AND pci2.cost_category_id = sci.cost_category_id
      )
  )
  SELECT 
    COALESCE(SUM(CASE WHEN category_type = 'debit' THEN COALESCE(surgeon_amount, procedure_amount) ELSE 0 END), 0),
    COALESCE(SUM(CASE WHEN category_type = 'credit' THEN COALESCE(surgeon_amount, procedure_amount) ELSE 0 END), 0)
  INTO v_total_debits, v_total_credits
  FROM effective_costs;

  RETURN QUERY SELECT v_total_debits, v_total_credits, (v_total_debits - v_total_credits);
END;
$$;


--
-- Name: calculate_case_stats(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculate_case_stats(p_case_id uuid) RETURNS TABLE(total_time_minutes integer, surgical_time_minutes integer, total_debits numeric, total_credits numeric, net_cost numeric, reimbursement numeric, profit numeric, cost_source text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_facility_id uuid;
  v_surgeon_id uuid;
  v_procedure_type_id uuid;
  v_case_date date;
  v_patient_in timestamptz;
  v_patient_out timestamptz;
  v_incision timestamptz;
  v_closing timestamptz;
  v_total_time integer;
  v_surgical_time integer;
  v_total_debits numeric := 0;
  v_total_credits numeric := 0;
  v_reimbursement numeric := 0;
  v_cost_source text := 'procedure_default';
  v_has_surgeon_override boolean := false;
BEGIN
  -- Get case details
  SELECT c.facility_id, c.surgeon_id, c.procedure_type_id, c.scheduled_date
  INTO v_facility_id, v_surgeon_id, v_procedure_type_id, v_case_date
  FROM cases c
  WHERE c.id = p_case_id;

  IF v_facility_id IS NULL THEN
    RETURN;
  END IF;

  -- Get milestone timestamps
  SELECT 
    MAX(CASE WHEN fm.name = 'patient_in' THEN cm.recorded_at END),
    MAX(CASE WHEN fm.name = 'patient_out' THEN cm.recorded_at END),
    MAX(CASE WHEN fm.name = 'incision' THEN cm.recorded_at END),
    MAX(CASE WHEN fm.name = 'closing' THEN cm.recorded_at END)
  INTO v_patient_in, v_patient_out, v_incision, v_closing
  FROM case_milestones cm
  JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id
  WHERE cm.case_id = p_case_id;

  -- Calculate times
  IF v_patient_in IS NOT NULL AND v_patient_out IS NOT NULL THEN
    v_total_time := EXTRACT(EPOCH FROM (v_patient_out - v_patient_in)) / 60;
  END IF;

  IF v_incision IS NOT NULL AND v_closing IS NOT NULL THEN
    v_surgical_time := EXTRACT(EPOCH FROM (v_closing - v_incision)) / 60;
  END IF;

  -- Check if surgeon has ANY override for this procedure (active on case date)
  IF v_surgeon_id IS NOT NULL AND v_procedure_type_id IS NOT NULL THEN
    SELECT EXISTS(
      SELECT 1 FROM surgeon_cost_items sci
      WHERE sci.surgeon_id = v_surgeon_id
        AND sci.procedure_type_id = v_procedure_type_id
        AND sci.facility_id = v_facility_id
        AND (sci.effective_from IS NULL OR sci.effective_from <= v_case_date)
        AND (sci.effective_to IS NULL OR sci.effective_to >= v_case_date)
    ) INTO v_has_surgeon_override;
    
    IF v_has_surgeon_override THEN
      v_cost_source := 'surgeon_override';
    END IF;
  END IF;

  -- Calculate costs from cost_categories
  -- For each category: check surgeon override first, then procedure default
  SELECT 
    COALESCE(SUM(CASE WHEN cc.type = 'debit' THEN 
      COALESCE(
        -- First: surgeon-specific override (with effective dating)
        (SELECT sci.amount 
         FROM surgeon_cost_items sci 
         WHERE sci.surgeon_id = v_surgeon_id 
           AND sci.procedure_type_id = v_procedure_type_id 
           AND sci.cost_category_id = cc.id
           AND sci.facility_id = v_facility_id
           AND (sci.effective_from IS NULL OR sci.effective_from <= v_case_date)
           AND (sci.effective_to IS NULL OR sci.effective_to >= v_case_date)),
        -- Second: procedure-level default (with effective dating)
        (SELECT pci.amount 
         FROM procedure_cost_items pci 
         WHERE pci.procedure_type_id = v_procedure_type_id 
           AND pci.cost_category_id = cc.id
           AND pci.facility_id = v_facility_id
           AND (pci.effective_from IS NULL OR pci.effective_from <= v_case_date)
           AND (pci.effective_to IS NULL OR pci.effective_to >= v_case_date)),
        0
      )
    ELSE 0 END), 0),
    COALESCE(SUM(CASE WHEN cc.type = 'credit' THEN 
      COALESCE(
        -- First: surgeon-specific override (with effective dating)
        (SELECT sci.amount 
         FROM surgeon_cost_items sci 
         WHERE sci.surgeon_id = v_surgeon_id 
           AND sci.procedure_type_id = v_procedure_type_id 
           AND sci.cost_category_id = cc.id
           AND sci.facility_id = v_facility_id
           AND (sci.effective_from IS NULL OR sci.effective_from <= v_case_date)
           AND (sci.effective_to IS NULL OR sci.effective_to >= v_case_date)),
        -- Second: procedure-level default (with effective dating)
        (SELECT pci.amount 
         FROM procedure_cost_items pci 
         WHERE pci.procedure_type_id = v_procedure_type_id 
           AND pci.cost_category_id = cc.id
           AND pci.facility_id = v_facility_id
           AND (pci.effective_from IS NULL OR pci.effective_from <= v_case_date)
           AND (pci.effective_to IS NULL OR pci.effective_to >= v_case_date)),
        0
      )
    ELSE 0 END), 0)
  INTO v_total_debits, v_total_credits
  FROM cost_categories cc
  WHERE cc.facility_id = v_facility_id
    AND cc.is_active = true
    AND cc.deleted_at IS NULL;

  -- Get reimbursement (from procedure_reimbursements - could add effective dating here too later)
  SELECT COALESCE(pr.reimbursement, 0)
  INTO v_reimbursement
  FROM procedure_reimbursements pr
  WHERE pr.procedure_type_id = v_procedure_type_id
    AND pr.facility_id = v_facility_id
    AND pr.payer_id IS NULL  -- Default reimbursement
  LIMIT 1;

  -- Return results
  RETURN QUERY SELECT 
    v_total_time,
    v_surgical_time,
    v_total_debits,
    v_total_credits,
    (v_total_debits - v_total_credits),  -- net_cost
    COALESCE(v_reimbursement, 0::numeric),
    (COALESCE(v_reimbursement, 0) - (v_total_debits - v_total_credits)),  -- profit
    v_cost_source;
END;
$$;


--
-- Name: calculate_expected_arrival(uuid, uuid, date, time without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculate_expected_arrival(p_facility_id uuid, p_procedure_type_id uuid, p_scheduled_date date, p_start_time time without time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_lead_time INTEGER;
  v_facility_timezone TEXT;
  v_scheduled_datetime TIMESTAMPTZ;
BEGIN
  -- Get facility timezone
  SELECT COALESCE(timezone, 'America/New_York') INTO v_facility_timezone
  FROM facilities WHERE id = p_facility_id;
  
  -- Get lead time (procedure override or facility default)
  SELECT COALESCE(pt.arrival_lead_time_minutes, f.default_arrival_lead_time_minutes, 90)
  INTO v_lead_time
  FROM facilities f
  LEFT JOIN procedure_types pt ON pt.id = p_procedure_type_id
  WHERE f.id = p_facility_id;
  
  -- Combine date and time in facility timezone, then subtract lead time
  v_scheduled_datetime := (p_scheduled_date || ' ' || COALESCE(p_start_time, '07:00:00'))::TIMESTAMP 
                          AT TIME ZONE v_facility_timezone;
  
  RETURN v_scheduled_datetime - (v_lead_time || ' minutes')::INTERVAL;
END;
$$;


--
-- Name: case_requires_rep(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.case_requires_rep(p_case_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_override BOOLEAN;
    v_procedure_requires BOOLEAN;
BEGIN
    SELECT 
        c.rep_required_override,
        COALESCE(pt.requires_rep, false)
    INTO v_override, v_procedure_requires
    FROM cases c
    LEFT JOIN procedure_types pt ON c.procedure_type_id = pt.id
    WHERE c.id = p_case_id;
    
    -- If override is set, use it; otherwise use procedure default
    IF v_override IS NOT NULL THEN
        RETURN v_override;
    ELSE
        RETURN v_procedure_requires;
    END IF;
END;
$$;


--
-- Name: clean_expired_notifications(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.clean_expired_notifications() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    DELETE FROM notifications WHERE expires_at < NOW();
END;
$$;


--
-- Name: cleanup_expired_sessions(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_expired_sessions() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  DELETE FROM user_sessions
  WHERE expires_at < NOW() - INTERVAL '7 days';
END;
$$;


--
-- Name: cleanup_expired_user_invites(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_expired_user_invites() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete invites that expired more than 30 days ago
  DELETE FROM public.user_invites
  WHERE accepted_at IS NULL
    AND expires_at < NOW() - INTERVAL '30 days';
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;


--
-- Name: cleanup_old_error_logs(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_error_logs() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  DELETE FROM error_logs
  WHERE created_at < NOW() - INTERVAL '90 days';
END;
$$;


--
-- Name: cleanup_old_login_attempts(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_login_attempts() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  DELETE FROM login_attempts
  WHERE created_at < NOW() - INTERVAL '7 days';
END;
$$;


--
-- Name: cleanup_old_soft_deletes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cleanup_old_soft_deletes() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Option A: Hard delete items older than 90 days (if you want)
  -- DELETE FROM cost_categories 
  -- WHERE deleted_at < NOW() - INTERVAL '90 days';
  
  -- Option B: Just log (no action needed - RLS handles visibility)
  RAISE NOTICE 'Soft delete cleanup check completed at %', NOW();
END;
$$;


--
-- Name: copy_complexities_to_facility(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.copy_complexities_to_facility(p_facility_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_count INTEGER := 0;
BEGIN
    INSERT INTO complexities (
        facility_id, name, display_name, description, 
        procedure_category_ids, is_active, display_order
    )
    SELECT 
        p_facility_id, name, display_name, description,
        procedure_category_ids, is_active, display_order
    FROM complexities
    WHERE facility_id IS NULL AND is_active = true
    ON CONFLICT (facility_id, name) DO NOTHING;
    
    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$;


--
-- Name: copy_cost_category_templates_to_facility(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.copy_cost_category_templates_to_facility(p_facility_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_count INTEGER := 0;
BEGIN
  INSERT INTO cost_categories (facility_id, name, type, description, display_order, is_active)
  SELECT 
    p_facility_id,
    name,
    type,
    description,
    display_order,
    is_active
  FROM cost_category_templates  -- RENAMED from default_cost_categories
  WHERE is_active = true
  ON CONFLICT (facility_id, name) DO NOTHING;
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;


--
-- Name: copy_milestone_settings_to_new_facility(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.copy_milestone_settings_to_new_facility() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Copy all global milestone settings to the new facility
  INSERT INTO facility_milestones (
    facility_id,
    name,
    display_name,
    display_order,
    is_active,
    source_milestone_type_id,
    min_minutes,
    max_minutes,
    validation_type
  )
  SELECT 
    NEW.id,
    mt.name,
    mt.display_name,
    mt.display_order,
    true,  -- Enable by default
    mt.id,
    COALESCE(gms.min_minutes, 1),
    COALESCE(gms.max_minutes, 90),
    COALESCE(gms.validation_type, 'sequence_gap')
  FROM milestone_types mt
  LEFT JOIN global_milestone_settings gms ON gms.milestone_type_id = mt.id
  WHERE NOT EXISTS (
    SELECT 1 FROM facility_milestones fm 
    WHERE fm.facility_id = NEW.id AND fm.name = mt.name
  );
  
  RETURN NEW;
END;
$$;


--
-- Name: copy_permission_template_to_facility(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.copy_permission_template_to_facility(p_facility_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO facility_permissions (facility_id, access_level, permission_key, granted)
  SELECT p_facility_id, pt.access_level, pt.permission_key, pt.granted
  FROM permission_templates pt
  ON CONFLICT (facility_id, access_level, permission_key) DO NOTHING;
END;
$$;


--
-- Name: create_case_with_milestones(text, date, time without time zone, uuid, uuid, uuid, uuid, uuid, uuid, uuid, text, uuid, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_case_with_milestones(p_case_number text, p_scheduled_date date, p_start_time time without time zone, p_or_room_id uuid, p_procedure_type_id uuid, p_status_id uuid, p_surgeon_id uuid, p_facility_id uuid, p_created_by uuid DEFAULT NULL::uuid, p_anesthesiologist_id uuid DEFAULT NULL::uuid, p_operative_side text DEFAULT NULL::text, p_payer_id uuid DEFAULT NULL::uuid, p_notes text DEFAULT NULL::text, p_rep_required_override boolean DEFAULT NULL::boolean) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_case_id UUID;
  v_milestone RECORD;
BEGIN
  -- 1) Insert the case
  INSERT INTO public.cases (
    case_number,
    scheduled_date,
    start_time,
    or_room_id,
    procedure_type_id,
    status_id,
    surgeon_id,
    facility_id,
    created_by,
    anesthesiologist_id,
    operative_side,
    payer_id,
    notes,
    rep_required_override
  ) VALUES (
    p_case_number,
    p_scheduled_date,
    p_start_time,
    p_or_room_id,
    p_procedure_type_id,
    p_status_id,
    p_surgeon_id,
    p_facility_id,
    p_created_by,
    p_anesthesiologist_id,
    p_operative_side,
    p_payer_id,
    p_notes,
    p_rep_required_override
  )
  RETURNING id INTO v_case_id;

  -- 2) Query procedure_milestone_config and insert case_milestones
  INSERT INTO public.case_milestones (case_id, facility_milestone_id, recorded_at, recorded_by)
  SELECT
    v_case_id,
    pmc.facility_milestone_id,
    NULL,
    NULL
  FROM public.procedure_milestone_config pmc
  WHERE pmc.procedure_type_id = p_procedure_type_id
    AND pmc.facility_id = p_facility_id
    AND pmc.is_enabled = true;

  -- 3) Verify milestones were created (should be pre-checked by caller,
  --    but enforce at DB level too)
  IF NOT EXISTS (
    SELECT 1 FROM public.case_milestones WHERE case_id = v_case_id
  ) THEN
    RAISE EXCEPTION 'No milestones configured for procedure % at facility %',
      p_procedure_type_id, p_facility_id;
  END IF;

  RETURN v_case_id;
END;
$$;


--
-- Name: create_case_with_milestones(text, date, time without time zone, uuid, uuid, uuid, uuid, uuid, uuid, uuid, text, uuid, text, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_case_with_milestones(p_case_number text, p_scheduled_date date, p_start_time time without time zone, p_or_room_id uuid, p_procedure_type_id uuid, p_status_id uuid, p_surgeon_id uuid, p_facility_id uuid, p_created_by uuid DEFAULT NULL::uuid, p_anesthesiologist_id uuid DEFAULT NULL::uuid, p_operative_side text DEFAULT NULL::text, p_payer_id uuid DEFAULT NULL::uuid, p_notes text DEFAULT NULL::text, p_rep_required_override boolean DEFAULT NULL::boolean, p_is_draft boolean DEFAULT false) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_case_id UUID;
BEGIN
  -- 1) Insert the case
  INSERT INTO public.cases (
    case_number,
    scheduled_date,
    start_time,
    or_room_id,
    procedure_type_id,
    status_id,
    surgeon_id,
    facility_id,
    created_by,
    anesthesiologist_id,
    operative_side,
    payer_id,
    notes,
    rep_required_override,
    is_draft
  ) VALUES (
    p_case_number,
    p_scheduled_date,
    p_start_time,
    p_or_room_id,
    p_procedure_type_id,
    p_status_id,
    p_surgeon_id,
    p_facility_id,
    p_created_by,
    p_anesthesiologist_id,
    p_operative_side,
    p_payer_id,
    p_notes,
    p_rep_required_override,
    p_is_draft
  )
  RETURNING id INTO v_case_id;

  -- 2) For drafts, skip milestone creation entirely
  IF p_is_draft THEN
    RETURN v_case_id;
  END IF;

  -- 3) Query procedure_milestone_config and insert case_milestones
  INSERT INTO public.case_milestones (case_id, facility_milestone_id, recorded_at, recorded_by)
  SELECT
    v_case_id,
    pmc.facility_milestone_id,
    NULL,
    NULL
  FROM public.procedure_milestone_config pmc
  WHERE pmc.procedure_type_id = p_procedure_type_id
    AND pmc.facility_id = p_facility_id
    AND pmc.is_enabled = true;

  -- 4) Verify milestones were created
  IF NOT EXISTS (
    SELECT 1 FROM public.case_milestones WHERE case_id = v_case_id
  ) THEN
    RAISE EXCEPTION 'No milestones configured for procedure % at facility %',
      p_procedure_type_id, p_facility_id;
  END IF;

  RETURN v_case_id;
END;
$$;


--
-- Name: create_case_with_milestones(text, date, time without time zone, uuid, uuid, uuid, uuid, uuid, uuid, uuid, text, uuid, text, boolean, boolean, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_case_with_milestones(p_case_number text, p_scheduled_date date, p_start_time time without time zone, p_or_room_id uuid, p_procedure_type_id uuid, p_status_id uuid, p_surgeon_id uuid, p_facility_id uuid, p_created_by uuid DEFAULT NULL::uuid, p_anesthesiologist_id uuid DEFAULT NULL::uuid, p_operative_side text DEFAULT NULL::text, p_payer_id uuid DEFAULT NULL::uuid, p_notes text DEFAULT NULL::text, p_rep_required_override boolean DEFAULT NULL::boolean, p_is_draft boolean DEFAULT false, p_staff_assignments jsonb DEFAULT NULL::jsonb) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_case_id UUID;
  v_staff JSONB;
BEGIN
  -- 1) Insert the case
  INSERT INTO public.cases (
    case_number,
    scheduled_date,
    start_time,
    or_room_id,
    procedure_type_id,
    status_id,
    surgeon_id,
    facility_id,
    created_by,
    anesthesiologist_id,
    operative_side,
    payer_id,
    notes,
    rep_required_override,
    is_draft
  ) VALUES (
    p_case_number,
    p_scheduled_date,
    p_start_time,
    p_or_room_id,
    p_procedure_type_id,
    p_status_id,
    p_surgeon_id,
    p_facility_id,
    p_created_by,
    p_anesthesiologist_id,
    p_operative_side,
    p_payer_id,
    p_notes,
    p_rep_required_override,
    p_is_draft
  )
  RETURNING id INTO v_case_id;

  -- 2) For drafts, skip milestone creation entirely
  IF p_is_draft THEN
    -- Still insert staff even for drafts (team is often known early)
    IF p_staff_assignments IS NOT NULL AND jsonb_array_length(p_staff_assignments) > 0 THEN
      INSERT INTO public.case_staff (case_id, user_id, role_id)
      SELECT
        v_case_id,
        (elem->>'user_id')::UUID,
        (elem->>'role_id')::UUID
      FROM jsonb_array_elements(p_staff_assignments) AS elem;
    END IF;

    RETURN v_case_id;
  END IF;

  -- 3) Query procedure_milestone_config and insert case_milestones
  INSERT INTO public.case_milestones (case_id, facility_milestone_id, recorded_at, recorded_by)
  SELECT
    v_case_id,
    pmc.facility_milestone_id,
    NULL,
    NULL
  FROM public.procedure_milestone_config pmc
  WHERE pmc.procedure_type_id = p_procedure_type_id
    AND pmc.facility_id = p_facility_id
    AND pmc.is_enabled = true;

  -- 4) Verify milestones were created
  IF NOT EXISTS (
    SELECT 1 FROM public.case_milestones WHERE case_id = v_case_id
  ) THEN
    RAISE EXCEPTION 'No milestones configured for procedure % at facility %',
      p_procedure_type_id, p_facility_id;
  END IF;

  -- 5) Insert staff assignments if provided
  IF p_staff_assignments IS NOT NULL AND jsonb_array_length(p_staff_assignments) > 0 THEN
    INSERT INTO public.case_staff (case_id, user_id, role_id)
    SELECT
      v_case_id,
      (elem->>'user_id')::UUID,
      (elem->>'role_id')::UUID
    FROM jsonb_array_elements(p_staff_assignments) AS elem;
  END IF;

  RETURN v_case_id;
END;
$$;


--
-- Name: create_device_rep_profile(uuid, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_device_rep_profile(user_id uuid, user_email text, first_name text, last_name text, phone_number text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  rep_role_id UUID;
BEGIN
  -- Get or create device_rep role
  SELECT id INTO rep_role_id FROM user_roles WHERE name = 'device_rep';
  
  -- If device_rep role doesn't exist, use 'tech' or create it
  IF rep_role_id IS NULL THEN
    INSERT INTO user_roles (name) VALUES ('device_rep') RETURNING id INTO rep_role_id;
  END IF;

  INSERT INTO users (id, email, first_name, last_name, phone, access_level, facility_id, role_id)
  VALUES (user_id, user_email, first_name, last_name, phone_number, 'device_rep', NULL, rep_role_id);
END;
$$;


--
-- Name: detect_case_issues(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.detect_case_issues(p_case_id uuid) RETURNS TABLE(issue_type text, milestone_name text, detected_value numeric, expected_min numeric, expected_max numeric, details jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_facility_id UUID;
  v_case_status TEXT;
  v_scheduled_date DATE;
  v_milestones JSONB;
  v_prev_milestone RECORD;
  v_curr_milestone RECORD;
BEGIN
  -- Get case info
  SELECT c.facility_id, cs.name, c.scheduled_date
  INTO v_facility_id, v_case_status, v_scheduled_date
  FROM cases c
  JOIN case_statuses cs ON cs.id = c.status_id
  WHERE c.id = p_case_id;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Build milestone data with timestamps and expected ranges
  FOR v_curr_milestone IN (
    SELECT 
      fm.id as facility_milestone_id,
      fm.name,
      fm.display_name,
      fm.display_order,
      fm.min_minutes,
      fm.max_minutes,
      fm.validation_type,
      fm.pair_with_id,
      cm.recorded_at
    FROM facility_milestones fm
    LEFT JOIN case_milestones cm ON cm.facility_milestone_id = fm.id AND cm.case_id = p_case_id
    WHERE fm.facility_id = v_facility_id
      AND fm.is_active = true
      AND fm.deleted_at IS NULL
    ORDER BY fm.display_order
  )
  LOOP
    -- Skip if no recorded timestamp and case isn't complete
    IF v_curr_milestone.recorded_at IS NULL THEN
      -- Check for missing required milestones on completed cases
      IF v_case_status = 'completed' AND v_curr_milestone.name IN ('patient_in', 'patient_out') THEN
        issue_type := 'missing';
        milestone_name := v_curr_milestone.display_name;
        detected_value := NULL;
        expected_min := NULL;
        expected_max := NULL;
        details := jsonb_build_object('required_for', 'completed case');
        RETURN NEXT;
      END IF;
      CONTINUE;
    END IF;

    -- For paired milestones with validation_type = 'duration', check against partner
    IF v_curr_milestone.validation_type = 'duration' AND v_curr_milestone.pair_with_id IS NOT NULL THEN
      -- Get the end milestone timestamp
      SELECT cm.recorded_at INTO v_prev_milestone
      FROM case_milestones cm
      WHERE cm.case_id = p_case_id 
        AND cm.facility_milestone_id = v_curr_milestone.pair_with_id;
      
      IF v_prev_milestone.recorded_at IS NOT NULL THEN
        DECLARE
          v_duration_minutes NUMERIC;
        BEGIN
          v_duration_minutes := EXTRACT(EPOCH FROM (v_prev_milestone.recorded_at - v_curr_milestone.recorded_at)) / 60;
          
          -- Check if duration exceeds max
          IF v_curr_milestone.max_minutes IS NOT NULL AND v_duration_minutes > v_curr_milestone.max_minutes THEN
            issue_type := 'timeout';
            milestone_name := v_curr_milestone.display_name;
            detected_value := v_duration_minutes;
            expected_min := v_curr_milestone.min_minutes;
            expected_max := v_curr_milestone.max_minutes;
            details := jsonb_build_object('validation_type', 'duration', 'pair_milestone', v_curr_milestone.pair_with_id);
            RETURN NEXT;
          END IF;
          
          -- Check if duration is below min
          IF v_curr_milestone.min_minutes IS NOT NULL AND v_duration_minutes < v_curr_milestone.min_minutes THEN
            issue_type := 'too_fast';
            milestone_name := v_curr_milestone.display_name;
            detected_value := v_duration_minutes;
            expected_min := v_curr_milestone.min_minutes;
            expected_max := v_curr_milestone.max_minutes;
            details := jsonb_build_object('validation_type', 'duration', 'pair_milestone', v_curr_milestone.pair_with_id);
            RETURN NEXT;
          END IF;
        END;
      END IF;
    ELSE
      -- For sequence_gap validation, check against previous milestone
      SELECT cm.recorded_at, fm.display_name INTO v_prev_milestone
      FROM case_milestones cm
      JOIN facility_milestones fm ON fm.id = cm.facility_milestone_id
      WHERE cm.case_id = p_case_id
        AND fm.display_order < v_curr_milestone.display_order
        AND fm.is_active = true
      ORDER BY fm.display_order DESC
      LIMIT 1;

      IF v_prev_milestone.recorded_at IS NOT NULL THEN
        DECLARE
          v_gap_minutes NUMERIC;
        BEGIN
          v_gap_minutes := EXTRACT(EPOCH FROM (v_curr_milestone.recorded_at - v_prev_milestone.recorded_at)) / 60;
          
          -- Check for impossible sequence (negative gap)
          IF v_gap_minutes < 0 THEN
            issue_type := 'impossible';
            milestone_name := v_curr_milestone.display_name;
            detected_value := v_gap_minutes;
            expected_min := 0;
            expected_max := NULL;
            details := jsonb_build_object(
              'validation_type', 'sequence_gap',
              'previous_milestone', v_prev_milestone.display_name,
              'message', 'Recorded before previous milestone'
            );
            RETURN NEXT;
          END IF;
          
          -- Check if gap exceeds max
          IF v_curr_milestone.max_minutes IS NOT NULL AND v_gap_minutes > v_curr_milestone.max_minutes THEN
            issue_type := 'timeout';
            milestone_name := v_curr_milestone.display_name;
            detected_value := v_gap_minutes;
            expected_min := v_curr_milestone.min_minutes;
            expected_max := v_curr_milestone.max_minutes;
            details := jsonb_build_object(
              'validation_type', 'sequence_gap',
              'previous_milestone', v_prev_milestone.display_name
            );
            RETURN NEXT;
          END IF;
          
          -- Check if gap is below min
          IF v_curr_milestone.min_minutes IS NOT NULL AND v_gap_minutes < v_curr_milestone.min_minutes THEN
            issue_type := 'too_fast';
            milestone_name := v_curr_milestone.display_name;
            detected_value := v_gap_minutes;
            expected_min := v_curr_milestone.min_minutes;
            expected_max := v_curr_milestone.max_minutes;
            details := jsonb_build_object(
              'validation_type', 'sequence_gap',
              'previous_milestone', v_prev_milestone.display_name
            );
            RETURN NEXT;
          END IF;
        END;
      END IF;
    END IF;
  END LOOP;

  -- Check for stale cases (scheduled yesterday or earlier with no milestones)
  IF v_case_status = 'scheduled' AND v_scheduled_date < CURRENT_DATE THEN
    -- Check if any milestones recorded
    IF NOT EXISTS (SELECT 1 FROM case_milestones WHERE case_id = p_case_id) THEN
      issue_type := 'stale';
      milestone_name := NULL;
      detected_value := EXTRACT(DAY FROM (CURRENT_DATE - v_scheduled_date));
      expected_min := NULL;
      expected_max := NULL;
      details := jsonb_build_object(
        'scheduled_date', v_scheduled_date,
        'days_overdue', EXTRACT(DAY FROM (CURRENT_DATE - v_scheduled_date))
      );
      RETURN NEXT;
    END IF;
  END IF;

  -- Check for incomplete cases (in_progress or delayed for more than 24 hours)
  IF v_case_status IN ('in_progress', 'delayed') THEN
    DECLARE
      v_last_activity TIMESTAMPTZ;
    BEGIN
      SELECT MAX(recorded_at) INTO v_last_activity
      FROM case_milestones
      WHERE case_id = p_case_id;

      IF v_last_activity IS NOT NULL AND v_last_activity < NOW() - INTERVAL '24 hours' THEN
        issue_type := 'incomplete';
        milestone_name := NULL;
        detected_value := EXTRACT(EPOCH FROM (NOW() - v_last_activity)) / 3600; -- hours
        expected_min := NULL;
        expected_max := 24;
        details := jsonb_build_object(
          'last_activity', v_last_activity,
          'hours_since_activity', EXTRACT(EPOCH FROM (NOW() - v_last_activity)) / 3600,
          'case_status', v_case_status
        );
        RETURN NEXT;
      END IF;
    END;
  END IF;

  RETURN;
END;
$$;


--
-- Name: disable_demo_audit_triggers(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.disable_demo_audit_triggers() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    ALTER TABLE case_implants DISABLE TRIGGER audit_case_implants_trigger;
END;
$$;


--
-- Name: disable_demo_triggers(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.disable_demo_triggers() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Disable triggers on case_milestones (prevents trigger_record_case_stats error)
  ALTER TABLE case_milestones DISABLE TRIGGER trg_record_case_stats;
  ALTER TABLE case_milestones DISABLE TRIGGER trg_update_case_stats;
  ALTER TABLE case_milestones DISABLE TRIGGER on_milestone_recorded_detect_issues;
  ALTER TABLE case_milestones DISABLE TRIGGER trigger_update_patient_status_from_milestone;
  
  -- Disable triggers on cases (prevents cascading recalculations)
  ALTER TABLE cases DISABLE TRIGGER on_case_completed;
  ALTER TABLE cases DISABLE TRIGGER on_case_status_change_detect_issues;
  ALTER TABLE cases DISABLE TRIGGER trg_record_stats_on_validation;
  ALTER TABLE cases DISABLE TRIGGER trg_refresh_stats_on_completion;
  ALTER TABLE cases DISABLE TRIGGER trg_remove_stats_on_invalidation;
  ALTER TABLE cases DISABLE TRIGGER trg_sync_exclusion_to_stats;
  ALTER TABLE cases DISABLE TRIGGER trigger_auto_create_patient_checkin;
END;
$$;


--
-- Name: enable_demo_audit_triggers(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enable_demo_audit_triggers() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    ALTER TABLE case_implants ENABLE TRIGGER audit_case_implants_trigger;
END;
$$;


--
-- Name: enable_demo_triggers(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.enable_demo_triggers() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Re-enable triggers on case_milestones
  ALTER TABLE case_milestones ENABLE TRIGGER trg_record_case_stats;
  ALTER TABLE case_milestones ENABLE TRIGGER trg_update_case_stats;
  ALTER TABLE case_milestones ENABLE TRIGGER on_milestone_recorded_detect_issues;
  ALTER TABLE case_milestones ENABLE TRIGGER trigger_update_patient_status_from_milestone;
  
  -- Re-enable triggers on cases
  ALTER TABLE cases ENABLE TRIGGER on_case_completed;
  ALTER TABLE cases ENABLE TRIGGER on_case_status_change_detect_issues;
  ALTER TABLE cases ENABLE TRIGGER trg_record_stats_on_validation;
  ALTER TABLE cases ENABLE TRIGGER trg_refresh_stats_on_completion;
  ALTER TABLE cases ENABLE TRIGGER trg_remove_stats_on_invalidation;
  ALTER TABLE cases ENABLE TRIGGER trg_sync_exclusion_to_stats;
  ALTER TABLE cases ENABLE TRIGGER trigger_auto_create_patient_checkin;
END;
$$;


--
-- Name: end_procedure_cost_item(uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.end_procedure_cost_item(p_id uuid, p_end_date date DEFAULT (CURRENT_DATE - '1 day'::interval)) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE procedure_cost_items
  SET effective_to = p_end_date
  WHERE id = p_id
    AND effective_to IS NULL;
END;
$$;


--
-- Name: end_surgeon_cost_item(uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.end_surgeon_cost_item(p_id uuid, p_end_date date DEFAULT (CURRENT_DATE - '1 day'::interval)) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE surgeon_cost_items
  SET effective_to = p_end_date
  WHERE id = p_id
    AND effective_to IS NULL; -- Only end currently active items
END;
$$;


--
-- Name: ensure_checkin_records(uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ensure_checkin_records(p_facility_id uuid, p_date date) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_default_status_id UUID;
  v_created_count INTEGER := 0;
BEGIN
  -- Get the default "expected" status
  SELECT id INTO v_default_status_id
  FROM patient_statuses
  WHERE name = 'expected'
  LIMIT 1;
  
  -- If no expected status, try to get any status
  IF v_default_status_id IS NULL THEN
    SELECT id INTO v_default_status_id
    FROM patient_statuses
    ORDER BY display_order
    LIMIT 1;
  END IF;
  
  -- Create checkin records for cases that don't have one
  INSERT INTO patient_checkins (
    facility_id,
    case_id,
    patient_id,
    patient_status_id,
    checklist_responses
  )
  SELECT 
    c.facility_id,
    c.id,
    c.patient_id,
    v_default_status_id,
    '{}'::jsonb
  FROM cases c
  LEFT JOIN patient_checkins pc ON c.id = pc.case_id
  WHERE c.facility_id = p_facility_id
    AND c.scheduled_date = p_date
    AND pc.id IS NULL
    AND v_default_status_id IS NOT NULL;
  
  GET DIAGNOSTICS v_created_count = ROW_COUNT;
  
  RETURN v_created_count;
END;
$$;


--
-- Name: expire_old_issues(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.expire_old_issues() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_expired_type_id UUID;
  v_count INTEGER;
BEGIN
  SELECT id INTO v_expired_type_id FROM resolution_types WHERE name = 'expired';

  UPDATE metric_issues
  SET 
    resolution_type_id = v_expired_type_id,
    resolved_at = NOW(),
    resolution_notes = 'Auto-expired after 30 days'
  WHERE resolved_at IS NULL
    AND expires_at < NOW();

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;


--
-- Name: facility_has_feature(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.facility_has_feature(p_facility_id uuid, p_feature_name text) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_is_enabled BOOLEAN;
  v_trial_ends_at TIMESTAMPTZ;
  v_feature_active BOOLEAN;
BEGIN
  -- Check if feature is globally active
  SELECT is_active INTO v_feature_active
  FROM features
  WHERE name = p_feature_name;
  
  IF NOT FOUND OR NOT v_feature_active THEN
    RETURN false;
  END IF;
  
  -- Check if facility has the feature enabled
  SELECT ff.is_enabled, ff.trial_ends_at
  INTO v_is_enabled, v_trial_ends_at
  FROM facility_features ff
  JOIN features f ON f.id = ff.feature_id
  WHERE ff.facility_id = p_facility_id
    AND f.name = p_feature_name;
  
  IF NOT FOUND THEN
    RETURN false;
  END IF;
  
  -- Check if enabled
  IF NOT v_is_enabled THEN
    RETURN false;
  END IF;
  
  -- Check if trial has expired (if it's a trial)
  IF v_trial_ends_at IS NOT NULL AND v_trial_ends_at < NOW() THEN
    RETURN false;
  END IF;
  
  RETURN true;
END;
$$;


--
-- Name: finalize_draft_case(uuid, text, date, time without time zone, uuid, uuid, uuid, uuid, uuid, uuid, text, uuid, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.finalize_draft_case(p_case_id uuid, p_case_number text, p_scheduled_date date, p_start_time time without time zone, p_or_room_id uuid, p_procedure_type_id uuid, p_status_id uuid, p_surgeon_id uuid, p_facility_id uuid, p_anesthesiologist_id uuid DEFAULT NULL::uuid, p_operative_side text DEFAULT NULL::text, p_payer_id uuid DEFAULT NULL::uuid, p_notes text DEFAULT NULL::text, p_rep_required_override boolean DEFAULT NULL::boolean) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- 1) Verify the case exists and is a draft
  IF NOT EXISTS (
    SELECT 1 FROM public.cases
    WHERE id = p_case_id AND is_draft = true
  ) THEN
    RAISE EXCEPTION 'Case % is not a draft or does not exist', p_case_id;
  END IF;

  -- 2) Update the case with all fields, mark as non-draft
  UPDATE public.cases SET
    case_number = p_case_number,
    scheduled_date = p_scheduled_date,
    start_time = p_start_time,
    or_room_id = p_or_room_id,
    procedure_type_id = p_procedure_type_id,
    status_id = p_status_id,
    surgeon_id = p_surgeon_id,
    anesthesiologist_id = p_anesthesiologist_id,
    operative_side = p_operative_side,
    payer_id = p_payer_id,
    notes = p_notes,
    rep_required_override = p_rep_required_override,
    is_draft = false
  WHERE id = p_case_id;

  -- 3) Remove any existing milestones (shouldn't exist, but be safe)
  DELETE FROM public.case_milestones WHERE case_id = p_case_id;

  -- 4) Create milestones from procedure config
  INSERT INTO public.case_milestones (case_id, facility_milestone_id, recorded_at, recorded_by)
  SELECT
    p_case_id,
    pmc.facility_milestone_id,
    NULL,
    NULL
  FROM public.procedure_milestone_config pmc
  WHERE pmc.procedure_type_id = p_procedure_type_id
    AND pmc.facility_id = p_facility_id
    AND pmc.is_enabled = true;

  -- 5) Verify milestones were created
  IF NOT EXISTS (
    SELECT 1 FROM public.case_milestones WHERE case_id = p_case_id
  ) THEN
    RAISE EXCEPTION 'No milestones configured for procedure % at facility %',
      p_procedure_type_id, p_facility_id;
  END IF;

  RETURN p_case_id;
END;
$$;


--
-- Name: generate_escort_link(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.generate_escort_link(p_checkin_id uuid, p_expires_hours integer DEFAULT 24) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_token TEXT;
  v_facility_id UUID;
  v_user_id UUID;
BEGIN
  -- Get facility ID from checkin
  SELECT facility_id INTO v_facility_id FROM patient_checkins WHERE id = p_checkin_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Check-in not found';
  END IF;
  
  -- Get current user
  v_user_id := auth.uid();
  
  -- Generate random token (URL-safe)
  v_token := encode(gen_random_bytes(24), 'base64');
  -- Make URL-safe: replace + with -, / with _, remove =
  v_token := replace(replace(replace(v_token, '+', '-'), '/', '_'), '=', '');
  
  -- Deactivate any existing links for this checkin
  UPDATE escort_status_links
  SET is_active = false
  WHERE checkin_id = p_checkin_id;
  
  -- Create new link
  INSERT INTO escort_status_links (
    checkin_id,
    facility_id,
    token,
    expires_at,
    created_by
  ) VALUES (
    p_checkin_id,
    v_facility_id,
    v_token,
    NOW() + (p_expires_hours || ' hours')::INTERVAL,
    v_user_id
  );
  
  RETURN v_token;
END;
$$;


--
-- Name: get_anesthesiologist_block_stats(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_anesthesiologist_block_stats(p_facility_id uuid) RETURNS TABLE(anesthesiologist_id uuid, anesthesiologist_name text, median_block_minutes numeric, case_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
    RETURN QUERY
    WITH block_times AS (
        SELECT 
            c.anesthesiologist_id,
            u.first_name || ' ' || u.last_name as anes_name,
            EXTRACT(EPOCH FROM (
                (SELECT cm.recorded_at 
                 FROM case_milestones cm 
                 JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
                 WHERE cm.case_id = c.id AND fm.name = 'anes_end' 
                 LIMIT 1)
                -
                (SELECT cm.recorded_at 
                 FROM case_milestones cm 
                 JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
                 WHERE cm.case_id = c.id AND fm.name = 'anes_start' 
                 LIMIT 1)
            )) / 60 as block_minutes
        FROM cases c
        JOIN users u ON c.anesthesiologist_id = u.id
        JOIN case_statuses cs ON c.status_id = cs.id
        WHERE c.facility_id = p_facility_id
          AND c.anesthesiologist_id IS NOT NULL
          AND cs.name = 'completed'
    )
    SELECT 
        bt.anesthesiologist_id,
        bt.anes_name as anesthesiologist_name,
        ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY bt.block_minutes)::numeric, 1) as median_block_minutes,
        COUNT(*) as case_count
    FROM block_times bt
    WHERE bt.block_minutes IS NOT NULL 
      AND bt.block_minutes > 0
      AND bt.block_minutes < 120  -- Filter outliers
    GROUP BY bt.anesthesiologist_id, bt.anes_name
    HAVING COUNT(*) >= 10;  -- Minimum 10 cases for reliable median
END;
$$;


--
-- Name: get_blocks_for_date_range(uuid, date, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_blocks_for_date_range(p_facility_id uuid, p_start_date date, p_end_date date) RETURNS TABLE(block_id uuid, surgeon_id uuid, surgeon_first_name text, surgeon_last_name text, surgeon_color text, block_date date, start_time time without time zone, end_time time without time zone, recurrence_type text, is_facility_closed boolean)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  WITH date_series AS (
    SELECT generate_series(p_start_date, p_end_date, interval '1 day')::date AS check_date
  ),
  expanded_blocks AS (
    SELECT 
      bs.id AS block_id,
      bs.surgeon_id,
      u.first_name::text AS surgeon_first_name,
      u.last_name::text AS surgeon_last_name,
      '#3B82F6'::text AS surgeon_color,
      ds.check_date AS block_date,
      bs.start_time,
      bs.end_time,
      bs.recurrence_type::text AS recurrence_type,
      false AS is_facility_closed
    FROM date_series ds
    CROSS JOIN block_schedules bs
    INNER JOIN users u ON u.id = bs.surgeon_id
    WHERE 
      bs.facility_id = p_facility_id
      AND bs.deleted_at IS NULL
      -- Exclude exception dates
      AND NOT (ds.check_date = ANY(COALESCE(bs.exception_dates, '{}')))
      -- Match day of week
      AND EXTRACT(DOW FROM ds.check_date)::integer = bs.day_of_week
      -- Check effective dates
      AND ds.check_date >= bs.effective_start
      AND (bs.effective_end IS NULL OR ds.check_date <= bs.effective_end)
      -- Check recurrence pattern
      AND (
        bs.recurrence_type = 'daily'
        OR bs.recurrence_type = 'weekly'
        OR (bs.recurrence_type = 'biweekly' AND 
            MOD((ds.check_date - bs.effective_start)::integer, 14) < 7)
        OR (bs.recurrence_type = 'first_of_month' AND 
            ds.check_date = (
              date_trunc('month', ds.check_date) + 
              ((7 + bs.day_of_week - EXTRACT(DOW FROM date_trunc('month', ds.check_date))::integer) % 7) * interval '1 day'
            )::date)
        OR (bs.recurrence_type = 'second_of_month' AND 
            ds.check_date = (
              date_trunc('month', ds.check_date) + 
              ((7 + bs.day_of_week - EXTRACT(DOW FROM date_trunc('month', ds.check_date))::integer) % 7 + 7) * interval '1 day'
            )::date)
        OR (bs.recurrence_type = 'third_of_month' AND 
            ds.check_date = (
              date_trunc('month', ds.check_date) + 
              ((7 + bs.day_of_week - EXTRACT(DOW FROM date_trunc('month', ds.check_date))::integer) % 7 + 14) * interval '1 day'
            )::date)
        OR (bs.recurrence_type = 'fourth_of_month' AND 
            ds.check_date = (
              date_trunc('month', ds.check_date) + 
              ((7 + bs.day_of_week - EXTRACT(DOW FROM date_trunc('month', ds.check_date))::integer) % 7 + 21) * interval '1 day'
            )::date)
        OR (bs.recurrence_type = 'last_of_month' AND 
            ds.check_date = (
              date_trunc('month', ds.check_date) + interval '1 month' - interval '1 day'
              - ((EXTRACT(DOW FROM (date_trunc('month', ds.check_date) + interval '1 month' - interval '1 day'))::integer 
                  + 7 - bs.day_of_week) % 7) * interval '1 day'
            )::date)
      )
  )
  SELECT * FROM expanded_blocks
  ORDER BY block_date, start_time;
END;
$$;


--
-- Name: get_case_tray_status(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_case_tray_status(p_case_id uuid) RETURNS text
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    v_requires_rep BOOLEAN;
    v_has_companies BOOLEAN;
    v_all_ready BOOLEAN;
    v_any_pending BOOLEAN;
    v_any_awaiting_delivery BOOLEAN;
BEGIN
    -- Check if case requires rep
    v_requires_rep := case_requires_rep(p_case_id);
    
    IF NOT v_requires_rep THEN
        RETURN 'no_rep_needed';
    END IF;
    
    -- Check if any companies are assigned
    SELECT EXISTS(
        SELECT 1 FROM case_device_companies WHERE case_id = p_case_id
    ) INTO v_has_companies;
    
    IF NOT v_has_companies THEN
        RETURN 'no_company_assigned';
    END IF;
    
    -- Check statuses
    SELECT 
        bool_and(tray_status IN ('consignment', 'delivered')),
        bool_or(tray_status = 'pending'),
        bool_or(tray_status = 'loaners_confirmed')
    INTO v_all_ready, v_any_pending, v_any_awaiting_delivery
    FROM case_device_companies 
    WHERE case_id = p_case_id;
    
    IF v_all_ready THEN
        RETURN 'ready';
    ELSIF v_any_pending THEN
        RETURN 'awaiting_response';
    ELSIF v_any_awaiting_delivery THEN
        RETURN 'awaiting_delivery';
    ELSE
        RETURN 'ready';
    END IF;
END;
$$;


--
-- Name: get_current_user_facility(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_current_user_facility() RETURNS uuid
    LANGUAGE sql SECURITY DEFINER
    AS $$
  SELECT facility_id FROM users WHERE id = auth.uid()
$$;


--
-- Name: get_escort_status(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_escort_status(p_token text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_result JSONB;
  v_link_id UUID;
BEGIN
  -- Find the link and verify it's valid
  SELECT id INTO v_link_id
  FROM escort_status_links
  WHERE token = p_token
    AND is_active = true
    AND expires_at > NOW();
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', 'Link not found or expired');
  END IF;
  
  -- Update view count
  UPDATE escort_status_links
  SET view_count = view_count + 1, last_viewed_at = NOW()
  WHERE id = v_link_id;
  
  -- Get the status data
  SELECT jsonb_build_object(
    'facility_name', f.name,
    'facility_logo', f.logo_url,
    'case_number', c.case_number,
    'procedure_name', pt.name,
    'surgeon_name', CONCAT('Dr. ', u.last_name),
    'scheduled_date', c.scheduled_date,
    'scheduled_time', c.start_time,
    'patient_status', jsonb_build_object(
      'name', ps.name,
      'display_name', ps.display_name,
      'description', ps.description,
      'color', ps.color,
      'icon', ps.icon
    ),
    'status_updated_at', pc.status_updated_at,
    'expected_arrival_time', pc.expected_arrival_time,
    'actual_arrival_time', pc.actual_arrival_time,
    'escort_fields', (
      SELECT jsonb_agg(jsonb_build_object(
        'field_key', pcf.field_key,
        'display_label', pcf.display_label,
        'value', pc.checklist_responses->pcf.field_key
      ) ORDER BY pcf.display_order)
      FROM preop_checklist_fields pcf
      WHERE pcf.facility_id = f.id
        AND pcf.show_on_escort_page = true
        AND pcf.is_active = true
        AND pcf.deleted_at IS NULL
    )
  ) INTO v_result
  FROM escort_status_links esl
  JOIN patient_checkins pc ON pc.id = esl.checkin_id
  JOIN cases c ON c.id = pc.case_id
  JOIN facilities f ON f.id = pc.facility_id
  JOIN patient_statuses ps ON ps.id = pc.patient_status_id
  LEFT JOIN procedure_types pt ON pt.id = c.procedure_type_id
  LEFT JOIN users u ON u.id = c.surgeon_id
  WHERE esl.id = v_link_id;
  
  RETURN v_result;
END;
$$;


--
-- Name: get_facility_demo_counts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_facility_demo_counts(p_facility_id uuid) RETURNS TABLE(milestone_count bigint, staff_count bigint, implant_count bigint, delay_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    (SELECT COUNT(*) FROM case_milestones cm 
     JOIN cases c ON cm.case_id = c.id 
     WHERE c.facility_id = p_facility_id) as milestone_count,
    (SELECT COUNT(*) FROM case_staff cs 
     JOIN cases c ON cs.case_id = c.id 
     WHERE c.facility_id = p_facility_id) as staff_count,
    (SELECT COUNT(*) FROM case_implants ci 
     JOIN cases c ON ci.case_id = c.id 
     WHERE c.facility_id = p_facility_id) as implant_count,
    (SELECT COUNT(*) FROM case_delays cd 
     JOIN cases c ON cd.case_id = c.id 
     WHERE c.facility_id = p_facility_id) as delay_count;
END;
$$;


--
-- Name: get_facility_errors(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_facility_errors(p_facility_id uuid, p_hours_ago integer DEFAULT 24) RETURNS TABLE(id uuid, severity text, category text, message text, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    el.id,
    el.severity,
    el.category,
    el.message,
    el.created_at
  FROM error_logs el
  WHERE el.facility_id = p_facility_id
    AND el.created_at > NOW() - (p_hours_ago || ' hours')::INTERVAL
  ORDER BY el.created_at DESC;
END;
$$;


--
-- Name: get_facility_id_from_procedure(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_facility_id_from_procedure(p_procedure_type_id uuid) RETURNS uuid
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  result UUID;
BEGIN
  SELECT facility_id INTO result
  FROM procedure_types
  WHERE id = p_procedure_type_id;
  
  RETURN result;
END;
$$;


--
-- Name: get_facility_id_from_surgeon(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_facility_id_from_surgeon(p_surgeon_id uuid) RETURNS uuid
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  result UUID;
BEGIN
  SELECT facility_id INTO result
  FROM users
  WHERE id = p_surgeon_id;
  
  RETURN result;
END;
$$;


--
-- Name: get_facility_median_block_time(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_facility_median_block_time(p_facility_id uuid) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    result NUMERIC;
BEGIN
    WITH block_times AS (
        SELECT 
            EXTRACT(EPOCH FROM (
                (SELECT cm.recorded_at 
                 FROM case_milestones cm 
                 JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
                 WHERE cm.case_id = c.id AND fm.name = 'anes_end' 
                 LIMIT 1)
                -
                (SELECT cm.recorded_at 
                 FROM case_milestones cm 
                 JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
                 WHERE cm.case_id = c.id AND fm.name = 'anes_start' 
                 LIMIT 1)
            )) / 60 as block_minutes
        FROM cases c
        JOIN case_statuses cs ON c.status_id = cs.id
        WHERE c.facility_id = p_facility_id
          AND c.anesthesiologist_id IS NOT NULL
          AND cs.name = 'completed'
    )
    SELECT ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY bt.block_minutes)::numeric, 1)
    INTO result
    FROM block_times bt
    WHERE bt.block_minutes IS NOT NULL 
      AND bt.block_minutes > 0
      AND bt.block_minutes < 120;
    
    RETURN COALESCE(result, 20.0);  -- Default to 20 min if no data
END;
$$;


--
-- Name: get_facility_median_turnover(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_facility_median_turnover(p_facility_id uuid) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    result NUMERIC;
BEGIN
    WITH room_cases AS (
        SELECT 
            c.id,
            c.or_room_id,
            c.scheduled_date,
            (SELECT cm.recorded_at 
             FROM case_milestones cm 
             JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
             WHERE cm.case_id = c.id AND fm.name = 'patient_out' 
             LIMIT 1) as patient_out,
            (SELECT cm.recorded_at 
             FROM case_milestones cm 
             JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
             WHERE cm.case_id = c.id AND fm.name = 'patient_in' 
             LIMIT 1) as patient_in
        FROM cases c
        WHERE c.facility_id = p_facility_id
          AND c.scheduled_date >= CURRENT_DATE - INTERVAL '90 days'
    ),
    turnovers AS (
        SELECT 
            EXTRACT(EPOCH FROM (r2.patient_in - r1.patient_out)) / 60 as turnover_minutes
        FROM room_cases r1
        JOIN room_cases r2 ON r1.or_room_id = r2.or_room_id 
            AND r1.scheduled_date = r2.scheduled_date
            AND r2.patient_in > r1.patient_out
            AND NOT EXISTS (
                SELECT 1 FROM room_cases r3 
                WHERE r3.or_room_id = r1.or_room_id 
                    AND r3.scheduled_date = r1.scheduled_date
                    AND r3.patient_in > r1.patient_out 
                    AND r3.patient_in < r2.patient_in
            )
        WHERE r1.patient_out IS NOT NULL 
          AND r2.patient_in IS NOT NULL
    )
    SELECT ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY t.turnover_minutes)::numeric, 1)
    INTO result
    FROM turnovers t
    WHERE t.turnover_minutes > 0 
      AND t.turnover_minutes < 120;  -- Filter outliers
    
    RETURN COALESCE(result, 20.0);  -- Default to 20 min if no data
END;
$$;


--
-- Name: get_failed_logins_global(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_failed_logins_global(p_hours_ago integer DEFAULT 24) RETURNS TABLE(facility_id uuid, facility_name text, failed_login_count bigint, unique_users bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    f.id as facility_id,
    f.name as facility_name,
    COUNT(al.id) as failed_login_count,
    COUNT(DISTINCT al.metadata->>'email') as unique_users
  FROM facilities f
  LEFT JOIN audit_log al ON al.facility_id = f.id
  WHERE al.action = 'login'
    AND al.success = false
    AND al.created_at > NOW() - (p_hours_ago || ' hours')::INTERVAL
  GROUP BY f.id, f.name
  HAVING COUNT(al.id) > 0
  ORDER BY failed_login_count DESC;
END;
$$;


--
-- Name: get_full_day_financials(uuid, date, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_full_day_financials(p_surgeon_id uuid, p_scheduled_date date, p_facility_id uuid) RETURNS TABLE(case_id uuid, case_number text, procedure_name text, status text, revenue numeric, total_costs numeric, profit numeric, margin_pct numeric)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id                                                       AS case_id,
    c.case_number::TEXT                                        AS case_number,
    pt.name::TEXT                                              AS procedure_name,
    cs.name::TEXT                                              AS status,
    ccs.reimbursement                                          AS revenue,
    CASE
      WHEN ccs.case_id IS NOT NULL THEN
        COALESCE(ccs.or_time_cost, ccs.or_cost, 0::NUMERIC)
        + COALESCE(ccs.total_debits, ccs.soft_goods_cost, 0::NUMERIC)
        - COALESCE(ccs.total_credits, ccs.hard_goods_cost, 0::NUMERIC)
      ELSE NULL
    END                                                        AS total_costs,
    ccs.profit                                                 AS profit,
    CASE
      WHEN ccs.reimbursement IS NOT NULL
        AND ccs.reimbursement > 0
        AND ccs.profit IS NOT NULL
      THEN (ccs.profit / ccs.reimbursement) * 100
      ELSE NULL
    END                                                        AS margin_pct
  FROM cases c
  JOIN procedure_types pt ON pt.id = c.procedure_type_id
  JOIN case_statuses cs   ON cs.id = c.status_id
  LEFT JOIN case_completion_stats ccs ON ccs.case_id = c.id
  WHERE c.surgeon_id      = p_surgeon_id
    AND c.scheduled_date  = p_scheduled_date
    AND c.facility_id     = p_facility_id
  ORDER BY c.case_number;
END;
$$;


--
-- Name: get_milestone_interval_medians(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_milestone_interval_medians(p_surgeon_id uuid, p_procedure_type_id uuid, p_facility_id uuid) RETURNS TABLE(milestone_name text, facility_milestone_id uuid, display_order integer, phase_group text, surgeon_median_minutes numeric, surgeon_case_count integer, facility_median_minutes numeric, facility_case_count integer)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  WITH
  milestone_order AS (
    SELECT
      fm.id AS fm_id,
      fm.name AS ms_name,
      fm.display_order AS ms_order,
      fm.phase_group AS ms_phase_group
    FROM procedure_milestone_config pmc
    JOIN facility_milestones fm ON fm.id = pmc.facility_milestone_id
    WHERE pmc.procedure_type_id = p_procedure_type_id
      AND pmc.facility_id = p_facility_id
      AND pmc.is_enabled = true
      AND fm.is_active = true
    ORDER BY fm.display_order
  ),

  case_milestone_timestamps AS (
    SELECT
      c.id AS case_id,
      c.surgeon_id AS case_surgeon_id,
      cm.facility_milestone_id AS cm_fm_id,
      cm.recorded_at AS cm_recorded_at,
      mo.ms_order,
      mo.ms_name,
      mo.ms_phase_group
    FROM cases c
    JOIN case_milestones cm ON cm.case_id = c.id
    JOIN milestone_order mo ON mo.fm_id = cm.facility_milestone_id
    JOIN case_statuses cs ON cs.id = c.status_id
    WHERE c.facility_id = p_facility_id
      AND c.procedure_type_id = p_procedure_type_id
      AND cs.name = 'completed'
      AND c.data_validated = true
      AND cm.recorded_at IS NOT NULL
  ),

  intervals AS (
    SELECT
      cmt.case_id,
      cmt.case_surgeon_id,
      cmt.cm_fm_id,
      cmt.ms_name,
      cmt.ms_order,
      cmt.ms_phase_group,
      EXTRACT(EPOCH FROM (
        cmt.cm_recorded_at - LAG(cmt.cm_recorded_at) OVER (
          PARTITION BY cmt.case_id
          ORDER BY cmt.ms_order
        )
      )) / 60.0 AS interval_min
    FROM case_milestone_timestamps cmt
  )

  SELECT
    i.ms_name::TEXT                                                    AS milestone_name,
    i.cm_fm_id                                                         AS facility_milestone_id,
    i.ms_order                                                         AS display_order,
    i.ms_phase_group::TEXT                                             AS phase_group,
    (PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY i.interval_min)
      FILTER (WHERE i.case_surgeon_id = p_surgeon_id
              AND i.interval_min IS NOT NULL
              AND i.interval_min > 0))::NUMERIC                        AS surgeon_median_minutes,
    COUNT(*)
      FILTER (WHERE i.case_surgeon_id = p_surgeon_id
              AND i.interval_min IS NOT NULL
              AND i.interval_min > 0)::INT                             AS surgeon_case_count,
    (PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY i.interval_min)
      FILTER (WHERE i.interval_min IS NOT NULL
              AND i.interval_min > 0))::NUMERIC                        AS facility_median_minutes,
    COUNT(*)
      FILTER (WHERE i.interval_min IS NOT NULL
              AND i.interval_min > 0)::INT                             AS facility_case_count
  FROM intervals i
  GROUP BY i.cm_fm_id, i.ms_name, i.ms_order, i.ms_phase_group
  ORDER BY i.ms_order;
END;
$$;


--
-- Name: get_my_access_level(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_access_level() RETURNS text
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT access_level FROM public.users WHERE id = auth.uid();
$$;


--
-- Name: get_my_facility_id(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_facility_id() RETURNS uuid
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT facility_id FROM public.users WHERE id = auth.uid();
$$;


--
-- Name: get_my_implant_company_id(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_implant_company_id() RETURNS uuid
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  result uuid;
BEGIN
  SELECT implant_company_id INTO result
  FROM public.users
  WHERE id = auth.uid();
  
  RETURN result;
END;
$$;


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: patients; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.patients (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    identifier text,
    first_name text,
    last_name text,
    date_of_birth date,
    mrn text,
    phone text,
    email text,
    emergency_contact_name text,
    emergency_contact_phone text,
    emergency_contact_relationship text,
    notes text,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    deleted_by uuid
);


--
-- Name: get_patient_display_name(public.patients); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_patient_display_name(p_patient public.patients) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  -- If we have first/last name, use that (HIPAA mode)
  IF p_patient.first_name IS NOT NULL AND p_patient.last_name IS NOT NULL THEN
    RETURN p_patient.first_name || ' ' || p_patient.last_name;
  END IF;
  
  -- Otherwise use identifier
  IF p_patient.identifier IS NOT NULL THEN
    RETURN p_patient.identifier;
  END IF;
  
  -- Fallback
  RETURN 'Patient';
END;
$$;


--
-- Name: get_previous_case_for_surgeon(uuid, date, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_previous_case_for_surgeon(p_surgeon_id uuid, p_case_date date, p_incision_time timestamp with time zone) RETURNS TABLE(case_id uuid, closing_time timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id AS case_id,
    cm_close.recorded_at AS closing_time
  FROM cases c
  JOIN case_milestones cm_close ON c.id = cm_close.case_id
  JOIN facility_milestones fm_close ON cm_close.facility_milestone_id = fm_close.id AND fm_close.name = 'closing'
  JOIN case_milestones cm_inc ON c.id = cm_inc.case_id
  JOIN facility_milestones fm_inc ON cm_inc.facility_milestone_id = fm_inc.id AND fm_inc.name = 'incision'
  WHERE c.surgeon_id = p_surgeon_id
    AND c.scheduled_date = p_case_date
    AND cm_inc.recorded_at < p_incision_time
  ORDER BY cm_inc.recorded_at DESC
  LIMIT 1;
END;
$$;


--
-- Name: get_previous_case_in_room(uuid, date, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_previous_case_in_room(p_or_room_id uuid, p_case_date date, p_patient_in_time timestamp with time zone) RETURNS TABLE(case_id uuid, patient_out_time timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id AS case_id,
    cm_out.recorded_at AS patient_out_time
  FROM cases c
  JOIN case_milestones cm_out ON c.id = cm_out.case_id
  JOIN facility_milestones fm_out ON cm_out.facility_milestone_id = fm_out.id AND fm_out.name = 'patient_out'
  WHERE c.or_room_id = p_or_room_id
    AND c.scheduled_date = p_case_date
    AND cm_out.recorded_at < p_patient_in_time
  ORDER BY cm_out.recorded_at DESC
  LIMIT 1;
END;
$$;


--
-- Name: get_previous_case_in_room(uuid, date, timestamp with time zone, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_previous_case_in_room(p_or_room_id uuid, p_case_date date, p_patient_in_time timestamp with time zone, p_surgeon_id uuid) RETURNS TABLE(case_id uuid, patient_out_time timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id AS case_id,
    cm_out.recorded_at AS patient_out_time
  FROM cases c
  JOIN case_milestones cm_out ON c.id = cm_out.case_id
  JOIN facility_milestones fm_out ON cm_out.facility_milestone_id = fm_out.id AND fm_out.name = 'patient_out'
  WHERE c.or_room_id = p_or_room_id
    AND c.scheduled_date = p_case_date
    AND c.surgeon_id = p_surgeon_id
    AND cm_out.recorded_at < p_patient_in_time
  ORDER BY cm_out.recorded_at DESC
  LIMIT 1;
END;
$$;


--
-- Name: get_room_available_minutes(uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_room_available_minutes(p_room_id uuid, p_date date) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_dow SMALLINT;
  v_schedule RECORD;
BEGIN
  v_dow := EXTRACT(DOW FROM p_date)::SMALLINT;

  SELECT open_time, close_time, is_closed
  INTO v_schedule
  FROM room_schedules
  WHERE or_room_id = p_room_id
    AND day_of_week = v_dow
    AND effective_start <= p_date
    AND (effective_end IS NULL OR effective_end >= p_date)
  ORDER BY effective_start DESC
  LIMIT 1;

  IF NOT FOUND OR v_schedule.is_closed THEN
    RETURN 0;
  END IF;

  RETURN EXTRACT(EPOCH FROM (v_schedule.close_time - v_schedule.open_time))::INTEGER / 60;
END;
$$;


--
-- Name: get_room_case_sequence(uuid, date, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_room_case_sequence(p_or_room_id uuid, p_case_date date, p_patient_in_time timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_sequence INTEGER;
BEGIN
  SELECT COUNT(*) + 1 INTO v_sequence
  FROM cases c
  JOIN case_milestones cm ON c.id = cm.case_id
  JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id AND fm.name = 'patient_in'
  WHERE c.or_room_id = p_or_room_id
    AND c.scheduled_date = p_case_date
    AND cm.recorded_at < p_patient_in_time;
  
  RETURN COALESCE(v_sequence, 1);
END;
$$;


--
-- Name: get_room_schedule_for_date(uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_room_schedule_for_date(p_room_id uuid, p_date date) RETURNS TABLE(open_time time without time zone, close_time time without time zone, is_closed boolean)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  SELECT rs.open_time, rs.close_time, rs.is_closed
  FROM room_schedules rs
  WHERE rs.or_room_id = p_room_id
    AND rs.day_of_week = EXTRACT(DOW FROM p_date)::SMALLINT
    AND rs.effective_start <= p_date
    AND (rs.effective_end IS NULL OR rs.effective_end >= p_date)
  ORDER BY rs.effective_start DESC
  LIMIT 1;
END;
$$;


--
-- Name: get_surgeon_case_sequence(uuid, date, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_surgeon_case_sequence(p_surgeon_id uuid, p_case_date date, p_patient_in_time timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_sequence INTEGER;
BEGIN
  SELECT COUNT(*) + 1 INTO v_sequence
  FROM cases c
  JOIN case_milestones cm ON c.id = cm.case_id
  JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id AND fm.name = 'patient_in'
  WHERE c.surgeon_id = p_surgeon_id
    AND c.scheduled_date = p_case_date
    AND cm.recorded_at < p_patient_in_time;
  
  RETURN COALESCE(v_sequence, 1);
END;
$$;


--
-- Name: get_surgeon_day_overview(uuid, uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_surgeon_day_overview(p_surgeon_id uuid, p_facility_id uuid, p_date date DEFAULT CURRENT_DATE) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    result JSON;
    v_cases JSON;
    v_procedure_summary JSON;
    v_median_times JSON;
    v_team_insight JSON;
    v_anes_insight JSON;
    v_turnover_median NUMERIC;
BEGIN
    -- Get today's cases
    SELECT json_agg(row_to_json(c_data))
    INTO v_cases
    FROM (
        SELECT 
            c.id,
            c.case_number,
            c.scheduled_date,
            c.start_time,
            c.notes,
            json_build_object('name', r.name) as or_room,
            json_build_object(
                'name', pt.name,
                'procedure_category_id', pt.procedure_category_id
            ) as procedure_type,
            json_build_object('name', cs.name) as status,
            CASE WHEN c.anesthesiologist_id IS NOT NULL THEN
                json_build_object(
                    'first_name', ua.first_name,
                    'last_name', ua.last_name
                )
            ELSE NULL END as anesthesiologist
        FROM cases c
        LEFT JOIN or_rooms r ON c.or_room_id = r.id
        LEFT JOIN procedure_types pt ON c.procedure_type_id = pt.id
        LEFT JOIN case_statuses cs ON c.status_id = cs.id
        LEFT JOIN users ua ON c.anesthesiologist_id = ua.id
        WHERE c.surgeon_id = p_surgeon_id
          AND c.scheduled_date = p_date
        ORDER BY c.start_time
    ) c_data;

    -- Get procedure category summary
    SELECT json_agg(row_to_json(ps_data))
    INTO v_procedure_summary
    FROM (
        SELECT 
            pc.id as category_id,
            pc.display_name as category_name,
            COUNT(*) as count,
            array_agg(DISTINCT pt.name) as procedures
        FROM cases c
        JOIN procedure_types pt ON c.procedure_type_id = pt.id
        LEFT JOIN procedure_categories pc ON pt.procedure_category_id = pc.id
        WHERE c.surgeon_id = p_surgeon_id
          AND c.scheduled_date = p_date
        GROUP BY pc.id, pc.display_name
        ORDER BY COUNT(*) DESC
    ) ps_data;

    -- Get median times
    SELECT json_agg(row_to_json(mt_data))
    INTO v_median_times
    FROM get_surgeon_median_times(p_surgeon_id) mt_data;

    -- Get turnover median
    SELECT get_facility_median_turnover(p_facility_id)
    INTO v_turnover_median;

    -- Build result
    result := json_build_object(
        'cases', COALESCE(v_cases, '[]'::json),
        'procedure_summary', COALESCE(v_procedure_summary, '[]'::json),
        'median_times', COALESCE(v_median_times, '[]'::json),
        'facility_turnover_median', COALESCE(v_turnover_median, 20)
    );

    RETURN result;
END;
$$;


--
-- Name: get_surgeon_done_time(uuid, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_surgeon_done_time(p_case_id uuid, p_closing_time timestamp with time zone, p_closing_complete_time timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_surgeon_left_at TIMESTAMPTZ;
  v_surgeon_id UUID;
  v_closing_workflow TEXT;
  v_handoff_minutes INTEGER;
BEGIN
  -- Get case data
  SELECT surgeon_left_at, surgeon_id 
  INTO v_surgeon_left_at, v_surgeon_id
  FROM cases 
  WHERE id = p_case_id;
  
  -- Priority 1: If surgeon_left_at is recorded, use it
  IF v_surgeon_left_at IS NOT NULL THEN
    RETURN v_surgeon_left_at;
  END IF;
  
  -- Priority 2: Check surgeon's workflow preference
  IF v_surgeon_id IS NOT NULL THEN
    SELECT closing_workflow, COALESCE(closing_handoff_minutes, 0)
    INTO v_closing_workflow, v_handoff_minutes
    FROM users
    WHERE id = v_surgeon_id;
    
    IF v_closing_workflow = 'pa_closes' AND p_closing_time IS NOT NULL THEN
      -- PA closes: surgeon leaves after handoff_minutes from closing start
      RETURN p_closing_time + (v_handoff_minutes || ' minutes')::INTERVAL;
    END IF;
  END IF;
  
  -- Priority 3: Default to closing_complete (or closing as fallback)
  RETURN COALESCE(p_closing_complete_time, p_closing_time);
END;
$$;


--
-- Name: get_surgeon_median_times(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_surgeon_median_times(p_surgeon_id uuid) RETURNS TABLE(procedure_type_id uuid, procedure_name text, median_surgical_minutes numeric, median_total_minutes numeric, case_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
    RETURN QUERY
    WITH case_times AS (
        SELECT 
            c.procedure_type_id,
            pt.name as procedure_name,
            -- Surgical time: incision  closing
            EXTRACT(EPOCH FROM (
                (SELECT cm.recorded_at 
                 FROM case_milestones cm 
                 JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
                 WHERE cm.case_id = c.id AND fm.name = 'closing' 
                 LIMIT 1)
                -
                (SELECT cm.recorded_at 
                 FROM case_milestones cm 
                 JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
                 WHERE cm.case_id = c.id AND fm.name = 'incision' 
                 LIMIT 1)
            )) / 60 as surgical_minutes,
            -- Total time: patient_in  patient_out
            EXTRACT(EPOCH FROM (
                (SELECT cm.recorded_at 
                 FROM case_milestones cm 
                 JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
                 WHERE cm.case_id = c.id AND fm.name = 'patient_out' 
                 LIMIT 1)
                -
                (SELECT cm.recorded_at 
                 FROM case_milestones cm 
                 JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id 
                 WHERE cm.case_id = c.id AND fm.name = 'patient_in' 
                 LIMIT 1)
            )) / 60 as total_minutes
        FROM cases c
        JOIN procedure_types pt ON c.procedure_type_id = pt.id
        JOIN case_statuses cs ON c.status_id = cs.id
        WHERE c.surgeon_id = p_surgeon_id
          AND cs.name = 'completed'
    )
    SELECT 
        ct.procedure_type_id,
        ct.procedure_name,
        ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ct.surgical_minutes)::numeric, 1) as median_surgical_minutes,
        ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ct.total_minutes)::numeric, 1) as median_total_minutes,
        COUNT(*) as case_count
    FROM case_times ct
    WHERE ct.surgical_minutes IS NOT NULL 
      AND ct.surgical_minutes > 0
      AND ct.total_minutes IS NOT NULL 
      AND ct.total_minutes > 0
    GROUP BY ct.procedure_type_id, ct.procedure_name
    HAVING COUNT(*) >= 5;  -- Minimum 5 cases for reliable median
END;
$$;


--
-- Name: get_surgeon_next_or_day(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_surgeon_next_or_day(p_surgeon_id uuid) RETURNS TABLE(scheduled_date date, case_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.scheduled_date::DATE,
        COUNT(*) as case_count
    FROM cases c
    JOIN case_statuses cs ON c.status_id = cs.id
    WHERE c.surgeon_id = p_surgeon_id
      AND c.scheduled_date > CURRENT_DATE
      AND cs.name != 'cancelled'
    GROUP BY c.scheduled_date
    ORDER BY c.scheduled_date
    LIMIT 1;
END;
$$;


--
-- Name: get_surgeon_room_count(uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_surgeon_room_count(p_surgeon_id uuid, p_case_date date) RETURNS integer
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  SELECT COUNT(DISTINCT or_room_id) INTO v_count
  FROM cases
  WHERE surgeon_id = p_surgeon_id
    AND scheduled_date = p_case_date
    AND or_room_id IS NOT NULL;
  
  RETURN COALESCE(v_count, 0);
END;
$$;


--
-- Name: get_surgeon_team_familiarity(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_surgeon_team_familiarity(p_surgeon_id uuid, p_staff_ids uuid[]) RETURNS TABLE(staff_id uuid, staff_name text, staff_role text, cases_together bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cs.user_id as staff_id,
        u.first_name || ' ' || u.last_name as staff_name,
        ur.name as staff_role,
        COUNT(DISTINCT cs.case_id) as cases_together
    FROM case_staff cs
    JOIN cases c ON cs.case_id = c.id
    JOIN users u ON cs.user_id = u.id
    JOIN user_roles ur ON cs.role_id = ur.id
    WHERE c.surgeon_id = p_surgeon_id
      AND cs.user_id = ANY(p_staff_ids)
    GROUP BY cs.user_id, u.first_name, u.last_name, ur.name
    ORDER BY cases_together DESC;
END;
$$;


--
-- Name: get_trial_days_remaining(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_trial_days_remaining(facility_uuid uuid) RETURNS integer
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    status TEXT;
    trial_end TIMESTAMPTZ;
BEGIN
    SELECT subscription_status, trial_ends_at 
    INTO status, trial_end
    FROM facilities
    WHERE id = facility_uuid;
    
    IF status != 'trial' OR trial_end IS NULL THEN
        RETURN NULL;
    END IF;
    
    RETURN GREATEST(0, EXTRACT(DAY FROM trial_end - NOW())::INTEGER);
END;
$$;


--
-- Name: get_user_permissions(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_user_permissions(p_user_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  v_user_id UUID;
  v_access_level TEXT;
  v_facility_id UUID;
  v_result JSONB;
BEGIN
  v_user_id := COALESCE(p_user_id, auth.uid());

  SELECT access_level, facility_id
  INTO v_access_level, v_facility_id
  FROM users
  WHERE id = v_user_id;

  -- Global admin and facility admin bypass  all permissions granted
  IF v_access_level IN ('global_admin', 'facility_admin') THEN
    SELECT jsonb_object_agg(p.key, true)
    INTO v_result
    FROM permissions p
    WHERE p.is_active = true;
    RETURN v_result;
  END IF;

  -- For 'user' and 'coordinator': resolve from facility_permissions
  SELECT jsonb_object_agg(p.key, COALESCE(fp.granted, false))
  INTO v_result
  FROM permissions p
  LEFT JOIN facility_permissions fp
    ON fp.permission_key = p.key
    AND fp.facility_id = v_facility_id
    AND fp.access_level = v_access_level
  WHERE p.is_active = true;

  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;


--
-- Name: get_week_of_month(date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_week_of_month(p_date date) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  RETURN CEIL(EXTRACT(DAY FROM p_date) / 7.0)::INT;
END;
$$;


--
-- Name: introspect_columns(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.introspect_columns(target_table text) RETURNS TABLE(column_name text, data_type text, is_nullable text, column_default text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
  SELECT
    c.column_name::TEXT,
    c.data_type::TEXT,
    c.is_nullable::TEXT,
    c.column_default::TEXT
  FROM information_schema.columns c
  WHERE c.table_schema = 'public'
    AND c.table_name = target_table
  ORDER BY c.ordinal_position;
$$;


--
-- Name: introspect_foreign_keys(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.introspect_foreign_keys(target_table text) RETURNS TABLE(constraint_name text, column_name text, foreign_table text, foreign_column text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
  SELECT
    tc.constraint_name::TEXT,
    kcu.column_name::TEXT,
    ccu.table_name::TEXT AS foreign_table,
    ccu.column_name::TEXT AS foreign_column
  FROM information_schema.table_constraints tc
  JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
  JOIN information_schema.constraint_column_usage ccu
    ON ccu.constraint_name = tc.constraint_name
    AND ccu.table_schema = tc.table_schema
  WHERE tc.constraint_type = 'FOREIGN KEY'
    AND tc.table_schema = 'public'
    AND tc.table_name = target_table
  ORDER BY kcu.column_name;
$$;


--
-- Name: introspect_indexes(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.introspect_indexes(target_table text) RETURNS TABLE(index_name text, index_definition text, is_unique boolean)
    LANGUAGE sql SECURITY DEFINER
    AS $$
  SELECT
    i.relname::TEXT AS index_name,
    pg_get_indexdef(i.oid)::TEXT AS index_definition,
    ix.indisunique AS is_unique
  FROM pg_class t
  JOIN pg_index ix ON t.oid = ix.indrelid
  JOIN pg_class i ON i.oid = ix.indexrelid
  JOIN pg_namespace n ON n.oid = t.relnamespace
  WHERE n.nspname = 'public'
    AND t.relname = target_table
  ORDER BY i.relname;
$$;


--
-- Name: introspect_row_count(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.introspect_row_count(target_table text) RETURNS TABLE(count bigint)
    LANGUAGE sql SECURITY DEFINER
    AS $$
  SELECT reltuples::BIGINT AS count
  FROM pg_class
  WHERE relname = target_table
    AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public');
$$;


--
-- Name: introspect_triggers(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.introspect_triggers(target_table text) RETURNS TABLE(trigger_name text, event_manipulation text, action_timing text, action_statement text, action_condition text)
    LANGUAGE sql SECURITY DEFINER
    AS $$
  SELECT
    t.trigger_name::TEXT,
    t.event_manipulation::TEXT,
    t.action_timing::TEXT,
    t.action_statement::TEXT,
    t.action_condition::TEXT
  FROM information_schema.triggers t
  WHERE t.event_object_schema = 'public'
    AND t.event_object_table = target_table
  ORDER BY t.trigger_name;
$$;


--
-- Name: is_block_active_on_date(uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_block_active_on_date(p_block_id uuid, p_check_date date) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_block RECORD;
  v_week INT;
BEGIN
  SELECT * INTO v_block FROM block_schedules WHERE id = p_block_id AND deleted_at IS NULL;
  
  IF NOT FOUND THEN RETURN FALSE; END IF;
  
  IF p_check_date < v_block.effective_start THEN RETURN FALSE; END IF;
  IF v_block.effective_end IS NOT NULL AND p_check_date > v_block.effective_end THEN 
    RETURN FALSE; 
  END IF;
  
  IF EXTRACT(DOW FROM p_check_date)::INT != v_block.day_of_week THEN 
    RETURN FALSE; 
  END IF;
  
  v_week := get_week_of_month(p_check_date);
  
  CASE v_block.recurrence_type
    WHEN 'weekly' THEN
      RETURN TRUE;
    WHEN 'first_third_fifth' THEN
      RETURN v_week IN (1, 3, 5);
    WHEN 'second_fourth' THEN
      RETURN v_week IN (2, 4);
    WHEN 'first_only' THEN
      RETURN v_week = 1;
    WHEN 'second_only' THEN
      RETURN v_week = 2;
    WHEN 'third_only' THEN
      RETURN v_week = 3;
    WHEN 'fourth_only' THEN
      RETURN v_week = 4;
    WHEN 'last_only' THEN
      RETURN is_last_weekday_of_month(p_check_date);
    ELSE
      RETURN TRUE;
  END CASE;
END;
$$;


--
-- Name: is_facility_accessible(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_facility_accessible(facility_uuid uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
    status TEXT;
    trial_end TIMESTAMPTZ;
BEGIN
    SELECT subscription_status, trial_ends_at 
    INTO status, trial_end
    FROM facilities
    WHERE id = facility_uuid;
    
    -- Active and demo facilities are always accessible
    IF status IN ('active') THEN
        RETURN true;
    END IF;
    
    -- Trial facilities are accessible if not expired
    IF status = 'trial' THEN
        IF trial_end IS NULL OR trial_end > NOW() THEN
            RETURN true;
        ELSE
            RETURN false;
        END IF;
    END IF;
    
    -- All other statuses (past_due, cancelled, disabled) are not accessible
    RETURN false;
END;
$$;


--
-- Name: is_facility_closed(uuid, date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_facility_closed(p_facility_id uuid, p_check_date date) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_month INT := EXTRACT(MONTH FROM p_check_date)::INT;
  v_day INT := EXTRACT(DAY FROM p_check_date)::INT;
  v_dow INT := EXTRACT(DOW FROM p_check_date)::INT;
  v_week INT := get_week_of_month(p_check_date);
BEGIN
  IF EXISTS (
    SELECT 1 FROM facility_closures 
    WHERE facility_id = p_facility_id AND closure_date = p_check_date
  ) THEN
    RETURN TRUE;
  END IF;
  
  IF EXISTS (
    SELECT 1 FROM facility_holidays
    WHERE facility_id = p_facility_id
      AND is_active = TRUE
      AND month = v_month
      AND (
        (day IS NOT NULL AND day = v_day)
        OR
        (week_of_month IS NOT NULL AND day_of_week IS NOT NULL 
         AND day_of_week = v_dow
         AND (week_of_month = v_week OR (week_of_month = 5 AND is_last_weekday_of_month(p_check_date))))
      )
  ) THEN
    RETURN TRUE;
  END IF;
  
  RETURN FALSE;
END;
$$;


--
-- Name: is_last_weekday_of_month(date); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_last_weekday_of_month(p_date date) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  v_next_week DATE;
BEGIN
  v_next_week := p_date + INTERVAL '7 days';
  RETURN EXTRACT(MONTH FROM v_next_week) != EXTRACT(MONTH FROM p_date);
END;
$$;


--
-- Name: is_soft_deleted(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.is_soft_deleted(p_deleted_at timestamp with time zone) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $$
  SELECT p_deleted_at IS NOT NULL;
$$;


--
-- Name: notify_facility_admins_of_issues(uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_facility_admins_of_issues(p_facility_id uuid, p_issues_count integer) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Insert notification for each facility admin
  INSERT INTO data_quality_notifications (facility_id, user_id, title, message, issues_count)
  SELECT 
    p_facility_id,
    u.id,
    'Data Quality Issues Detected',
    format('%s new data quality issues require attention', p_issues_count),
    p_issues_count
  FROM users u
  WHERE u.facility_id = p_facility_id
    AND u.access_level IN ('facility_admin', 'global_admin');
END;
$$;


--
-- Name: recalculate_surgeon_averages(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.recalculate_surgeon_averages(p_facility_id uuid DEFAULT NULL::uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  procedure_count INT := 0;
  milestone_count INT := 0;
  target_facility_id UUID;
BEGIN
  -- If no facility_id provided, try to get from current user
  -- For service role calls, this will be NULL and we'll process all facilities
  IF p_facility_id IS NOT NULL THEN
    target_facility_id := p_facility_id;
  END IF;

  -- ============================================
  -- 1. SURGEON PROCEDURE AVERAGES
  -- Average total case time (patient_in  patient_out) per surgeon/procedure
  -- ============================================
  
  -- Delete existing averages for the facility (or all if no facility specified)
  IF target_facility_id IS NOT NULL THEN
    DELETE FROM surgeon_procedure_averages 
    WHERE surgeon_id IN (SELECT id FROM users WHERE facility_id = target_facility_id);
  END IF;

  INSERT INTO surgeon_procedure_averages (
    id,
    surgeon_id,
    procedure_type_id,
    avg_total_minutes,
    sample_size,
    updated_at
  )
  SELECT 
    gen_random_uuid() as id,
    c.surgeon_id,
    c.procedure_type_id,
    ROUND(AVG(
      EXTRACT(EPOCH FROM (patient_out.recorded_at - patient_in.recorded_at)) / 60
    )::numeric, 1) as avg_total_minutes,
    COUNT(*) as sample_size,
    NOW() as updated_at
  FROM cases c
  -- Join to get patient_in milestone
  JOIN case_milestones patient_in ON patient_in.case_id = c.id
  JOIN facility_milestones fm_in ON fm_in.id = patient_in.facility_milestone_id AND fm_in.name = 'patient_in'
  -- Join to get patient_out milestone
  JOIN case_milestones patient_out ON patient_out.case_id = c.id
  JOIN facility_milestones fm_out ON fm_out.id = patient_out.facility_milestone_id AND fm_out.name = 'patient_out'
  -- Only completed cases with valid surgeon and procedure
  WHERE c.surgeon_id IS NOT NULL
    AND c.procedure_type_id IS NOT NULL
    AND (target_facility_id IS NULL OR c.facility_id = target_facility_id)
  GROUP BY c.surgeon_id, c.procedure_type_id
  ON CONFLICT (surgeon_id, procedure_type_id) 
  DO UPDATE SET 
    avg_total_minutes = EXCLUDED.avg_total_minutes,
    sample_size = EXCLUDED.sample_size,
    updated_at = NOW();

  GET DIAGNOSTICS procedure_count = ROW_COUNT;

  -- ============================================
  -- 2. SURGEON MILESTONE AVERAGES
  -- Average time from patient_in to each milestone per surgeon/procedure
  -- ============================================
  
  -- Delete existing averages for the facility
  IF target_facility_id IS NOT NULL THEN
    DELETE FROM surgeon_milestone_averages 
    WHERE surgeon_id IN (SELECT id FROM users WHERE facility_id = target_facility_id);
  END IF;

  INSERT INTO surgeon_milestone_averages (
    id,
    surgeon_id,
    procedure_type_id,
    milestone_type_id,
    avg_minutes_from_start,
    sample_size,
    updated_at
  )
  SELECT 
    gen_random_uuid() as id,
    c.surgeon_id,
    c.procedure_type_id,
    fm_milestone.source_milestone_type_id as milestone_type_id,
    ROUND(AVG(
      EXTRACT(EPOCH FROM (milestone.recorded_at - patient_in.recorded_at)) / 60
    )::numeric, 1) as avg_minutes_from_start,
    COUNT(*) as sample_size,
    NOW() as updated_at
  FROM cases c
  -- Join to get patient_in milestone (the baseline)
  JOIN case_milestones patient_in ON patient_in.case_id = c.id
  JOIN facility_milestones fm_in ON fm_in.id = patient_in.facility_milestone_id AND fm_in.name = 'patient_in'
  -- Join to get each other milestone
  JOIN case_milestones milestone ON milestone.case_id = c.id
  JOIN facility_milestones fm_milestone ON fm_milestone.id = milestone.facility_milestone_id
  -- Only milestones AFTER patient_in (exclude patient_in itself)
  WHERE fm_milestone.name != 'patient_in'
    AND milestone.recorded_at > patient_in.recorded_at
    AND c.surgeon_id IS NOT NULL
    AND c.procedure_type_id IS NOT NULL
    AND fm_milestone.source_milestone_type_id IS NOT NULL
    AND (target_facility_id IS NULL OR c.facility_id = target_facility_id)
  GROUP BY c.surgeon_id, c.procedure_type_id, fm_milestone.source_milestone_type_id
  ON CONFLICT (surgeon_id, procedure_type_id, milestone_type_id) 
  DO UPDATE SET 
    avg_minutes_from_start = EXCLUDED.avg_minutes_from_start,
    sample_size = EXCLUDED.sample_size,
    updated_at = NOW();

  GET DIAGNOSTICS milestone_count = ROW_COUNT;

  RETURN json_build_object(
    'success', true,
    'procedure_averages_updated', procedure_count,
    'milestone_averages_updated', milestone_count
  );
END;
$$;


--
-- Name: record_case_stats(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.record_case_stats(p_case_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_case RECORD;
  v_stats RECORD;
  v_patient_in TIMESTAMPTZ;
  v_patient_out TIMESTAMPTZ;
  v_anes_start TIMESTAMPTZ;
  v_anes_end TIMESTAMPTZ;
  v_actual_start_time TIME;
  v_anesthesia_minutes NUMERIC;
  v_call_to_pi_minutes NUMERIC;
  v_schedule_variance NUMERIC;
  v_room_turnover NUMERIC;
  v_surgical_turnover NUMERIC;
  v_is_first_room BOOLEAN := FALSE;
  v_is_first_surgeon BOOLEAN := FALSE;
  v_surgeon_room_count INTEGER := 1;
  v_surgeon_case_seq INTEGER := 1;
  v_room_case_seq INTEGER := 1;
  v_or_hourly_rate NUMERIC;
  v_or_time_cost NUMERIC;
  v_prev_patient_out TIMESTAMPTZ;
  v_prev_closing TIMESTAMPTZ;
  -- [FIX] New variables for corrected profit
  v_final_profit NUMERIC;
  v_total_debits NUMERIC;
  v_total_credits NUMERIC;
BEGIN
  SELECT 
    c.id, c.case_number, c.facility_id, c.surgeon_id, c.procedure_type_id,
    c.payer_id, c.or_room_id, c.scheduled_date, c.start_time, 
    c.data_validated, c.is_excluded_from_metrics, c.call_time
  INTO v_case
  FROM cases c
  WHERE c.id = p_case_id;
  
  IF v_case.id IS NULL THEN
    RAISE EXCEPTION 'Case not found: %', p_case_id;
  END IF;
  
  SELECT * INTO v_stats FROM calculate_case_stats(p_case_id);
  
  IF v_stats.total_time_minutes IS NULL THEN
    RETURN;
  END IF;
  
  IF v_case.data_validated IS NOT TRUE THEN
    RAISE NOTICE 'Case % not validated yet, skipping stats recording', p_case_id;
    RETURN;
  END IF;
  
  IF v_case.is_excluded_from_metrics IS TRUE THEN
    UPDATE case_completion_stats 
    SET 
      is_excluded = TRUE, 
      excluded_at = NOW(),
      exclusion_reason = 'Case excluded from metrics'
    WHERE case_id = p_case_id
      AND (is_excluded = FALSE OR is_excluded IS NULL);
    
    DELETE FROM case_milestone_stats WHERE case_id = p_case_id;
    
    RAISE NOTICE 'Case % is excluded from metrics', p_case_id;
    RETURN;
  END IF;

  SELECT 
    MAX(CASE WHEN fm.name = 'patient_in' THEN cm.recorded_at END),
    MAX(CASE WHEN fm.name = 'patient_out' THEN cm.recorded_at END),
    MAX(CASE WHEN fm.name = 'anes_start' THEN cm.recorded_at END),
    MAX(CASE WHEN fm.name = 'anes_end' THEN cm.recorded_at END)
  INTO v_patient_in, v_patient_out, v_anes_start, v_anes_end
  FROM case_milestones cm
  JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id
  WHERE cm.case_id = p_case_id;

  IF v_patient_in IS NOT NULL THEN
    v_actual_start_time := v_patient_in::TIME;
  END IF;

  IF v_anes_start IS NOT NULL AND v_anes_end IS NOT NULL THEN
    v_anesthesia_minutes := EXTRACT(EPOCH FROM (v_anes_end - v_anes_start)) / 60;
  END IF;

  IF v_case.call_time IS NOT NULL AND v_patient_in IS NOT NULL THEN
    v_call_to_pi_minutes := EXTRACT(EPOCH FROM (v_patient_in - v_case.call_time)) / 60;
  END IF;

  IF v_case.start_time IS NOT NULL AND v_actual_start_time IS NOT NULL THEN
    v_schedule_variance := EXTRACT(EPOCH FROM (v_actual_start_time - v_case.start_time)) / 60;
  END IF;

  SELECT or_hourly_rate INTO v_or_hourly_rate
  FROM facilities WHERE id = v_case.facility_id;

  IF v_or_hourly_rate IS NOT NULL AND v_stats.total_time_minutes IS NOT NULL THEN
    v_or_time_cost := v_stats.total_time_minutes * (v_or_hourly_rate / 60);
  ELSE
    v_or_time_cost := 0;
  END IF;

  SELECT COUNT(*) + 1 INTO v_room_case_seq
  FROM cases c2
  JOIN case_milestones cm2 ON cm2.case_id = c2.id
  JOIN facility_milestones fm2 ON cm2.facility_milestone_id = fm2.id AND fm2.name = 'patient_in'
  WHERE c2.or_room_id = v_case.or_room_id
    AND c2.scheduled_date = v_case.scheduled_date
    AND c2.id != v_case.id
    AND cm2.recorded_at < v_patient_in;
  
  v_is_first_room := (v_room_case_seq = 1);

  SELECT COUNT(*) + 1 INTO v_surgeon_case_seq
  FROM cases c2
  JOIN case_milestones cm2 ON cm2.case_id = c2.id
  JOIN facility_milestones fm2 ON cm2.facility_milestone_id = fm2.id AND fm2.name = 'patient_in'
  WHERE c2.surgeon_id = v_case.surgeon_id
    AND c2.scheduled_date = v_case.scheduled_date
    AND c2.id != v_case.id
    AND cm2.recorded_at < v_patient_in;
  
  v_is_first_surgeon := (v_surgeon_case_seq = 1);

  SELECT COUNT(DISTINCT or_room_id) INTO v_surgeon_room_count
  FROM cases
  WHERE surgeon_id = v_case.surgeon_id
    AND scheduled_date = v_case.scheduled_date;

  IF NOT v_is_first_room AND v_patient_in IS NOT NULL THEN
    SELECT MAX(cm2.recorded_at) INTO v_prev_patient_out
    FROM cases c2
    JOIN case_milestones cm2 ON cm2.case_id = c2.id
    JOIN facility_milestones fm2 ON cm2.facility_milestone_id = fm2.id AND fm2.name = 'patient_out'
    WHERE c2.or_room_id = v_case.or_room_id
      AND c2.scheduled_date = v_case.scheduled_date
      AND c2.id != v_case.id
      AND cm2.recorded_at < v_patient_in;
    
    IF v_prev_patient_out IS NOT NULL THEN
      v_room_turnover := EXTRACT(EPOCH FROM (v_patient_in - v_prev_patient_out)) / 60;
    END IF;
  END IF;

  IF NOT v_is_first_surgeon THEN
    SELECT MAX(cm2.recorded_at) INTO v_prev_closing
    FROM cases c2
    JOIN case_milestones cm2 ON cm2.case_id = c2.id
    JOIN facility_milestones fm2 ON cm2.facility_milestone_id = fm2.id AND fm2.name = 'closing'
    WHERE c2.surgeon_id = v_case.surgeon_id
      AND c2.scheduled_date = v_case.scheduled_date
      AND c2.id != v_case.id
      AND cm2.recorded_at < v_patient_in;
    
    IF v_prev_closing IS NOT NULL THEN
      DECLARE v_incision TIMESTAMPTZ;
      BEGIN
        SELECT cm.recorded_at INTO v_incision
        FROM case_milestones cm
        JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id AND fm.name = 'incision'
        WHERE cm.case_id = p_case_id;
        
        IF v_incision IS NOT NULL THEN
          v_surgical_turnover := EXTRACT(EPOCH FROM (v_incision - v_prev_closing)) / 60;
        END IF;
      END;
    END IF;
  END IF;

  -- [FIX] Use debits/credits from calculate_case_stats, compute profit correctly
  v_total_debits := COALESCE(v_stats.total_debits, 0);
  v_total_credits := COALESCE(v_stats.total_credits, 0);
  
  -- [FIX] Profit = reimbursement - debits + credits - OR time cost
  -- This is the complete profit formula including time cost
  v_final_profit := COALESCE(v_stats.reimbursement, 0) 
                    - v_total_debits 
                    + v_total_credits 
                    - COALESCE(v_or_time_cost, 0);

  INSERT INTO case_completion_stats (
    case_id, case_number, facility_id, surgeon_id, procedure_type_id,
    payer_id, or_room_id, case_date, scheduled_start_time, actual_start_time,
    total_duration_minutes, surgical_duration_minutes, anesthesia_duration_minutes,
    call_to_patient_in_minutes, schedule_variance_minutes,
    room_turnover_minutes, surgical_turnover_minutes,
    is_first_case_of_day_room, is_first_case_of_day_surgeon,
    surgeon_room_count, surgeon_case_sequence, room_case_sequence,
    reimbursement, soft_goods_cost, hard_goods_cost, or_cost, profit, or_hourly_rate,
    total_debits, total_credits, net_cost, or_time_cost, cost_source,
    is_excluded,
    updated_at
  ) VALUES (
    v_case.id, v_case.case_number, v_case.facility_id, v_case.surgeon_id, v_case.procedure_type_id,
    v_case.payer_id, v_case.or_room_id, v_case.scheduled_date, v_case.start_time, v_actual_start_time,
    v_stats.total_time_minutes, v_stats.surgical_time_minutes, v_anesthesia_minutes,
    v_call_to_pi_minutes, v_schedule_variance,
    v_room_turnover, v_surgical_turnover,
    v_is_first_room, v_is_first_surgeon,
    v_surgeon_room_count, v_surgeon_case_seq, v_room_case_seq,
    -- [FIX] Use actual debits/credits instead of hardcoded 0
    v_stats.reimbursement,
    v_total_debits,           -- soft_goods_cost = total debits
    v_total_credits,          -- hard_goods_cost = total credits  
    v_or_time_cost,
    v_final_profit,           -- [FIX] Corrected profit including OR time cost
    v_or_hourly_rate,
    v_total_debits,
    v_total_credits,
    (v_total_debits - v_total_credits),  -- net_cost
    v_or_time_cost,
    v_stats.cost_source,
    FALSE,
    NOW()
  )
  ON CONFLICT (case_id) DO UPDATE SET
    total_duration_minutes = EXCLUDED.total_duration_minutes,
    surgical_duration_minutes = EXCLUDED.surgical_duration_minutes,
    anesthesia_duration_minutes = EXCLUDED.anesthesia_duration_minutes,
    call_to_patient_in_minutes = EXCLUDED.call_to_patient_in_minutes,
    schedule_variance_minutes = EXCLUDED.schedule_variance_minutes,
    room_turnover_minutes = EXCLUDED.room_turnover_minutes,
    surgical_turnover_minutes = EXCLUDED.surgical_turnover_minutes,
    is_first_case_of_day_room = EXCLUDED.is_first_case_of_day_room,
    is_first_case_of_day_surgeon = EXCLUDED.is_first_case_of_day_surgeon,
    surgeon_room_count = EXCLUDED.surgeon_room_count,
    surgeon_case_sequence = EXCLUDED.surgeon_case_sequence,
    room_case_sequence = EXCLUDED.room_case_sequence,
    reimbursement = EXCLUDED.reimbursement,
    soft_goods_cost = EXCLUDED.soft_goods_cost,
    hard_goods_cost = EXCLUDED.hard_goods_cost,
    or_cost = EXCLUDED.or_cost,
    profit = EXCLUDED.profit,
    or_hourly_rate = EXCLUDED.or_hourly_rate,
    total_debits = EXCLUDED.total_debits,
    total_credits = EXCLUDED.total_credits,
    net_cost = EXCLUDED.net_cost,
    or_time_cost = EXCLUDED.or_time_cost,
    cost_source = EXCLUDED.cost_source,
    is_excluded = FALSE,
    excluded_at = NULL,
    excluded_by = NULL,
    exclusion_reason = NULL,
    updated_at = NOW();
  
  -- RECORD MILESTONE STATS
  IF v_patient_in IS NOT NULL THEN
    DELETE FROM case_milestone_stats WHERE case_id = p_case_id;
    
    INSERT INTO case_milestone_stats (
      case_id, facility_id, surgeon_id, procedure_type_id, milestone_type_id,
      case_date, minutes_from_start, recorded_at
    )
    SELECT 
      cm.case_id,
      v_case.facility_id,
      v_case.surgeon_id,
      v_case.procedure_type_id,
      fm.source_milestone_type_id,
      v_case.scheduled_date,
      EXTRACT(EPOCH FROM (cm.recorded_at - v_patient_in)) / 60,
      cm.recorded_at
    FROM case_milestones cm
    JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id
    WHERE cm.case_id = p_case_id
      AND fm.name != 'patient_in'
      AND fm.source_milestone_type_id IS NOT NULL
      AND cm.recorded_at IS NOT NULL
      AND cm.recorded_at >= v_patient_in;
  END IF;
  
  RAISE NOTICE 'Stats recorded for case % (profit: %, debits: %, credits: %, or_cost: %, cost_source: %)', 
    p_case_id, v_final_profit, v_total_debits, v_total_credits, v_or_time_cost, v_stats.cost_source;
END;
$$;


--
-- Name: refresh_all_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_all_stats() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY surgeon_procedure_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY surgeon_milestone_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY facility_procedure_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY facility_milestone_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY surgeon_overall_stats;
END;
$$;


--
-- Name: refresh_case_completion_stats(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_case_completion_stats(p_facility_id uuid DEFAULT NULL::uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count INTEGER := 0;
  v_case RECORD;
  v_costs RECORD;
  v_reimbursement NUMERIC;
  v_or_time_cost NUMERIC;
  v_profit NUMERIC;
  v_or_rate NUMERIC;
BEGIN
  -- Loop through cases that need updating
  FOR v_case IN 
    SELECT 
      ccs.id as stats_id,
      ccs.case_id,
      ccs.facility_id,
      ccs.surgeon_id,
      ccs.procedure_type_id,
      ccs.payer_id,
      ccs.total_duration_minutes
    FROM case_completion_stats ccs
    WHERE (p_facility_id IS NULL OR ccs.facility_id = p_facility_id)
      AND ccs.procedure_type_id IS NOT NULL
  LOOP
    -- Get OR hourly rate for facility
    SELECT or_hourly_rate INTO v_or_rate
    FROM facilities 
    WHERE id = v_case.facility_id;
    
    -- Calculate costs using new function
    SELECT * INTO v_costs
    FROM calculate_case_costs(v_case.procedure_type_id, v_case.surgeon_id, v_case.facility_id);
    
    -- Get reimbursement (payer-specific or default)
    SELECT COALESCE(
      (SELECT pr.reimbursement 
       FROM procedure_reimbursements pr 
       WHERE pr.procedure_type_id = v_case.procedure_type_id 
         AND pr.payer_id = v_case.payer_id
       ORDER BY pr.effective_date DESC 
       LIMIT 1),
      (SELECT pr.reimbursement 
       FROM procedure_reimbursements pr 
       WHERE pr.procedure_type_id = v_case.procedure_type_id 
         AND pr.payer_id IS NULL
       ORDER BY pr.effective_date DESC 
       LIMIT 1),
      0
    ) INTO v_reimbursement;
    
    -- Calculate OR time cost
    v_or_time_cost := CASE 
      WHEN v_or_rate IS NOT NULL AND v_case.total_duration_minutes IS NOT NULL
      THEN v_case.total_duration_minutes * (v_or_rate / 60)
      ELSE 0
    END;
    
    -- Calculate profit: Reimbursement + Credits - Debits - OR Time Cost
    v_profit := v_reimbursement 
                + COALESCE(v_costs.total_credits, 0) 
                - COALESCE(v_costs.total_debits, 0) 
                - v_or_time_cost;
    
    -- Update the stats row
    UPDATE case_completion_stats
    SET 
      reimbursement = v_reimbursement,
      total_debits = COALESCE(v_costs.total_debits, 0),
      total_credits = COALESCE(v_costs.total_credits, 0),
      net_cost = COALESCE(v_costs.net_cost, 0),
      or_time_cost = v_or_time_cost,
      profit = v_profit
    WHERE id = v_case.stats_id;
    
    v_count := v_count + 1;
  END LOOP;
  
  RETURN v_count;
END;
$$;


--
-- Name: refresh_case_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_case_stats() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY surgeon_procedure_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY facility_procedure_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY surgeon_overall_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY surgeon_milestone_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY facility_milestone_stats;
END;
$$;


--
-- Name: refresh_facility_health_scores(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_facility_health_scores() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_facility_health_scores;
END;
$$;


--
-- Name: run_issue_detection_for_case(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.run_issue_detection_for_case(p_case_id uuid) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_facility_id UUID;
  v_issue RECORD;
  v_issue_type_id UUID;
  v_facility_milestone_id UUID;
  v_count INTEGER := 0;
BEGIN
  -- Get facility_id
  SELECT facility_id INTO v_facility_id FROM cases WHERE id = p_case_id;
  IF NOT FOUND THEN
    RETURN 0;
  END IF;

  -- Loop through detected issues
  FOR v_issue IN SELECT * FROM detect_case_issues(p_case_id)
  LOOP
    -- Get issue_type_id
    SELECT id INTO v_issue_type_id FROM issue_types WHERE name = v_issue.issue_type;
    
    -- Get facility_milestone_id if milestone_name provided
    v_facility_milestone_id := NULL;
    IF v_issue.milestone_name IS NOT NULL THEN
      SELECT id INTO v_facility_milestone_id 
      FROM facility_milestones 
      WHERE facility_id = v_facility_id 
        AND display_name = v_issue.milestone_name
        AND deleted_at IS NULL
      LIMIT 1;
    END IF;

    -- Insert issue (on conflict do nothing to avoid duplicates)
    INSERT INTO metric_issues (
      facility_id,
      case_id,
      issue_type_id,
      facility_milestone_id,
      detected_value,
      expected_min,
      expected_max,
      details
    ) VALUES (
      v_facility_id,
      p_case_id,
      v_issue_type_id,
      v_facility_milestone_id,
      v_issue.detected_value,
      v_issue.expected_min,
      v_issue.expected_max,
      v_issue.details
    )
    ON CONFLICT (case_id, facility_milestone_id, issue_type_id) DO UPDATE
    SET 
      detected_value = EXCLUDED.detected_value,
      expected_min = EXCLUDED.expected_min,
      expected_max = EXCLUDED.expected_max,
      details = EXCLUDED.details,
      detected_at = NOW()
    WHERE metric_issues.resolved_at IS NULL;  -- Only update unresolved issues

    v_count := v_count + 1;
  END LOOP;

  RETURN v_count;
END;
$$;


--
-- Name: seed_facility_flag_rules(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.seed_facility_flag_rules(p_facility_id uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_count INTEGER := 0;
BEGIN
  INSERT INTO flag_rules (
    facility_id, name, description, category,
    metric, start_milestone, end_milestone,
    operator, threshold_type, threshold_value, comparison_scope,
    severity, display_order, is_built_in, source_rule_id
  )
  SELECT
    p_facility_id, name, description, category,
    metric, start_milestone, end_milestone,
    operator, threshold_type, threshold_value, comparison_scope,
    severity, display_order, true, id  -- source_rule_id points back to global template
  FROM flag_rules
  WHERE facility_id IS NULL  -- Only global templates
    AND is_built_in = true
    AND NOT EXISTS (
      -- Skip if this facility already has a rule from this template
      SELECT 1 FROM flag_rules fr2
      WHERE fr2.facility_id = p_facility_id
        AND fr2.source_rule_id = flag_rules.id
    );
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;


--
-- Name: seed_facility_milestones(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.seed_facility_milestones(target_facility_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  milestone_rec RECORD;
  new_milestone_id UUID;
  pair_mapping JSONB := '{}';
BEGIN
  -- First pass: Create all milestones (without pair_with_id)
  FOR milestone_rec IN 
    SELECT * FROM milestone_types ORDER BY display_order
  LOOP
    INSERT INTO facility_milestones (
      facility_id,
      name,
      display_name,
      display_order,
      pair_position,
      source_milestone_type_id
    ) VALUES (
      target_facility_id,
      milestone_rec.name,
      milestone_rec.display_name,
      milestone_rec.display_order,
      milestone_rec.pair_position,
      milestone_rec.id
    )
    ON CONFLICT (facility_id, name) DO NOTHING
    RETURNING id INTO new_milestone_id;
    
    -- Store mapping of old ID to new ID
    IF new_milestone_id IS NOT NULL THEN
      pair_mapping := pair_mapping || jsonb_build_object(milestone_rec.id::text, new_milestone_id::text);
    END IF;
  END LOOP;
  
  -- Second pass: Set up pair_with_id references
  UPDATE facility_milestones fm
  SET pair_with_id = (pair_mapping->>global_mt.pair_with_id::text)::uuid
  FROM milestone_types global_mt
  WHERE fm.facility_id = target_facility_id
    AND fm.source_milestone_type_id = global_mt.id
    AND global_mt.pair_with_id IS NOT NULL;
    
END;
$$;


--
-- Name: seed_facility_with_templates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.seed_facility_with_templates(target_facility_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  template_rec RECORD;
  new_procedure_id UUID;
  milestone_rec RECORD;
  new_milestone_id UUID;
  facility_milestone_map JSONB := '{}';
  procedure_map JSONB := '{}';
BEGIN
  -- PART 1: Seed facility_milestones from milestone_types
  FOR milestone_rec IN 
    SELECT * FROM milestone_types ORDER BY display_order
  LOOP
    INSERT INTO facility_milestones (
      facility_id,
      name,
      display_name,
      display_order,
      pair_position,
      source_milestone_type_id
    ) VALUES (
      target_facility_id,
      milestone_rec.name,
      milestone_rec.display_name,
      milestone_rec.display_order,
      milestone_rec.pair_position,
      milestone_rec.id
    )
    ON CONFLICT (facility_id, name) DO UPDATE SET facility_id = target_facility_id
    RETURNING id INTO new_milestone_id;
    
    IF new_milestone_id IS NOT NULL THEN
      facility_milestone_map := facility_milestone_map || jsonb_build_object(milestone_rec.id::text, new_milestone_id::text);
    ELSE
      SELECT id INTO new_milestone_id FROM facility_milestones 
      WHERE facility_id = target_facility_id AND name = milestone_rec.name;
      facility_milestone_map := facility_milestone_map || jsonb_build_object(milestone_rec.id::text, new_milestone_id::text);
    END IF;
  END LOOP;
  
  -- Set up milestone pairing
  UPDATE facility_milestones fm
  SET pair_with_id = (facility_milestone_map->>global_mt.pair_with_id::text)::uuid
  FROM milestone_types global_mt
  WHERE fm.facility_id = target_facility_id
    AND fm.source_milestone_type_id = global_mt.id
    AND global_mt.pair_with_id IS NOT NULL;

  -- PART 2: Seed procedure_types from procedure_type_templates (RENAMED)
  FOR template_rec IN 
    SELECT * FROM procedure_type_templates WHERE is_active = true ORDER BY name
  LOOP
    INSERT INTO procedure_types (
      facility_id,
      name,
      body_region_id,
      implant_category,
      source_template_id
    ) VALUES (
      target_facility_id,
      template_rec.name,
      template_rec.body_region_id,
      template_rec.implant_category,
      template_rec.id
    )
    ON CONFLICT (facility_id, name) DO UPDATE SET facility_id = target_facility_id
    RETURNING id INTO new_procedure_id;
    
    IF new_procedure_id IS NULL THEN
      SELECT id INTO new_procedure_id FROM procedure_types 
      WHERE facility_id = target_facility_id AND name = template_rec.name;
    END IF;
    
    procedure_map := procedure_map || jsonb_build_object(template_rec.id::text, new_procedure_id::text);
  END LOOP;

  -- PART 3: Seed procedure_milestone_config from procedure_milestone_templates (RENAMED)
  INSERT INTO procedure_milestone_config (
    facility_id,
    procedure_type_id,
    facility_milestone_id,
    display_order
  )
  SELECT 
    target_facility_id,
    (procedure_map->>pmt.procedure_type_template_id::text)::uuid,
    (facility_milestone_map->>pmt.milestone_type_id::text)::uuid,
    pmt.display_order
  FROM procedure_milestone_templates pmt
  WHERE (procedure_map->>pmt.procedure_type_template_id::text) IS NOT NULL
    AND (facility_milestone_map->>pmt.milestone_type_id::text) IS NOT NULL
  ON CONFLICT (procedure_type_id, facility_milestone_id) DO NOTHING;

END;
$$;


--
-- Name: set_room_display_order(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_room_display_order() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- If display_order is not set (0 or NULL), assign next available order
  IF NEW.display_order IS NULL OR NEW.display_order = 0 THEN
    SELECT COALESCE(MAX(display_order), 0) + 1 
    INTO NEW.display_order
    FROM or_rooms 
    WHERE facility_id = NEW.facility_id 
    AND deleted_at IS NULL;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: sync_soft_delete_columns(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.sync_soft_delete_columns() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.deleted_at IS NOT NULL AND OLD.deleted_at IS NULL THEN
    NEW.is_active = false;
  END IF;
  
  IF NEW.deleted_at IS NULL AND OLD.deleted_at IS NOT NULL THEN
    NEW.is_active = true;
  END IF;
  
  IF NEW.is_active = false AND OLD.is_active = true AND NEW.deleted_at IS NULL THEN
    NEW.deleted_at = NOW();
  END IF;
  
  IF NEW.is_active = true AND OLD.is_active = false AND NEW.deleted_at IS NOT NULL THEN
    NEW.deleted_at = NULL;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trigger_issue_detection_on_case_update(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_issue_detection_on_case_update() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Only run if status changed
  IF OLD.status_id IS DISTINCT FROM NEW.status_id THEN
    PERFORM run_issue_detection_for_case(NEW.id);
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trigger_issue_detection_on_milestone(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_issue_detection_on_milestone() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Run detection for the case (async would be better but this works for now)
  PERFORM run_issue_detection_for_case(NEW.case_id);
  RETURN NEW;
END;
$$;


--
-- Name: trigger_recalculate_averages(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_recalculate_averages() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_completed_status_id UUID;
BEGIN
    -- Get the completed status ID
    SELECT id INTO v_completed_status_id FROM case_statuses WHERE name = 'completed';
    
    -- Check if status changed to completed
    IF NEW.status_id = v_completed_status_id AND 
       (OLD.status_id IS NULL OR OLD.status_id != v_completed_status_id) THEN
        
        -- Recalculate averages for this facility
        IF NEW.facility_id IS NOT NULL THEN
            PERFORM recalculate_surgeon_averages(NEW.facility_id);
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


--
-- Name: trigger_record_case_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_record_case_stats() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_milestone_name TEXT;
BEGIN
  -- Get the milestone name via facility_milestone_id (the only path now)
  SELECT fm.name INTO v_milestone_name
  FROM facility_milestones fm
  WHERE fm.id = NEW.facility_milestone_id;

  -- Only trigger stats recording on patient_out milestone
  IF v_milestone_name = 'patient_out' THEN
    PERFORM record_case_stats(NEW.case_id);
    PERFORM refresh_case_stats();
  END IF;

  RETURN NEW;
END;
$$;


--
-- Name: trigger_record_stats_on_validation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_record_stats_on_validation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- When case becomes validated (TRUE) and wasn't before
  -- AND case is not excluded from metrics
  IF NEW.data_validated IS TRUE AND 
     (OLD.data_validated IS DISTINCT FROM TRUE) AND
     (NEW.is_excluded_from_metrics IS NOT TRUE) THEN
    
    RAISE NOTICE 'Case % validated, recording stats...', NEW.id;
    
    -- Record stats now that it's validated
    -- This function will check for patient_out and handle all the logic
    PERFORM record_case_stats(NEW.id);
    
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trigger_refresh_stats_on_completion(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_refresh_stats_on_completion() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Only refresh when status changes TO completed
  IF NEW.status_id != OLD.status_id THEN
    -- Check if new status is 'completed'
    IF EXISTS (
      SELECT 1 FROM case_statuses 
      WHERE id = NEW.status_id AND name = 'completed'
    ) THEN
      PERFORM refresh_all_stats();
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: trigger_remove_stats_on_invalidation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_remove_stats_on_invalidation() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- If data_validated changes from TRUE to FALSE, remove stats
  IF (OLD.data_validated = TRUE) AND (NEW.data_validated = FALSE) THEN
    DELETE FROM case_completion_stats WHERE case_id = NEW.id;
    DELETE FROM case_milestone_stats WHERE case_id = NEW.id;
    RAISE NOTICE 'Stats removed for invalidated case %', NEW.id;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trigger_seed_facility_milestones(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_seed_facility_milestones() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  PERFORM seed_facility_milestones(NEW.id);
  RETURN NEW;
END;
$$;


--
-- Name: trigger_seed_facility_on_create(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_seed_facility_on_create() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  PERFORM seed_facility_with_templates(NEW.id);
  RETURN NEW;
END;
$$;


--
-- Name: trigger_sync_exclusion_to_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_sync_exclusion_to_stats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- When case is being EXCLUDED
  IF NEW.is_excluded_from_metrics IS TRUE AND 
     (OLD.is_excluded_from_metrics IS DISTINCT FROM TRUE) THEN
    
    -- Soft delete in stats table (preserve the data for audit)
    UPDATE case_completion_stats 
    SET 
      is_excluded = TRUE,
      excluded_at = NOW(),
      excluded_by = NEW.validated_by,
      exclusion_reason = 'Excluded via Data Quality review'
    WHERE case_id = NEW.id;
    
    -- Hard delete milestone stats (less critical for audit)
    DELETE FROM case_milestone_stats WHERE case_id = NEW.id;
    
    RAISE NOTICE 'Stats marked as excluded for case %', NEW.id;
  
  -- When case is being UN-EXCLUDED
  ELSIF NEW.is_excluded_from_metrics IS FALSE AND 
        OLD.is_excluded_from_metrics IS TRUE THEN
    
    -- If stats exist, un-exclude them
    UPDATE case_completion_stats 
    SET 
      is_excluded = FALSE,
      excluded_at = NULL,
      excluded_by = NULL,
      exclusion_reason = NULL
    WHERE case_id = NEW.id;
    
    -- Re-record the case stats (will also recreate milestone stats)
    IF NEW.data_validated IS TRUE THEN
      PERFORM record_case_stats(NEW.id);
    END IF;
    
    RAISE NOTICE 'Stats restored for case %', NEW.id;
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: trigger_update_case_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trigger_update_case_stats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_has_patient_out BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1
    FROM case_milestones cm
    JOIN facility_milestones fm ON cm.facility_milestone_id = fm.id
    WHERE cm.case_id = NEW.case_id 
      AND fm.name = 'patient_out'
      AND cm.recorded_at IS NOT NULL
  ) INTO v_has_patient_out;
  
  IF v_has_patient_out THEN
    PERFORM record_case_stats(NEW.case_id);
    PERFORM refresh_case_stats();
  END IF;
  
  RETURN NEW;
END;
$$;


--
-- Name: update_analytics_settings_timestamp(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_analytics_settings_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_case_device_companies_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_case_device_companies_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


--
-- Name: update_case_implants_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_case_implants_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


--
-- Name: update_default_complexities_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_default_complexities_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


--
-- Name: update_flag_rules_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_flag_rules_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


--
-- Name: update_last_login(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_last_login() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE public.users 
  SET last_login_at = NOW() 
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$;


--
-- Name: update_page_registry_timestamp(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_page_registry_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


--
-- Name: update_patient_status_from_milestone(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_patient_status_from_milestone() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_milestone_name TEXT;
  v_new_status_name TEXT;
  v_new_status_id UUID;
BEGIN
  -- Get the milestone name
  SELECT fm.name INTO v_milestone_name
  FROM facility_milestones fm
  WHERE fm.id = NEW.facility_milestone_id;
  
  IF NOT FOUND THEN
    RETURN NEW;
  END IF;
  
  -- Map milestone to patient status
  v_new_status_name := CASE v_milestone_name
    WHEN 'patient_in' THEN 'in_pre_op'
    WHEN 'incision' THEN 'in_surgery'
    WHEN 'patient_out' THEN 'in_recovery'
    WHEN 'room_cleaned' THEN 'ready_for_discharge'
    ELSE NULL
  END;
  
  IF v_new_status_name IS NULL THEN
    RETURN NEW;
  END IF;
  
  -- Get the status ID
  SELECT id INTO v_new_status_id FROM patient_statuses WHERE name = v_new_status_name;
  IF NOT FOUND THEN
    RETURN NEW;
  END IF;
  
  -- Update the patient check-in status
  UPDATE patient_checkins
  SET 
    patient_status_id = v_new_status_id,
    status_updated_at = NOW(),
    status_updated_by = NEW.recorded_by,
    updated_at = NOW()
  WHERE case_id = NEW.case_id;
  
  RETURN NEW;
END;
$$;


--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


--
-- Name: user_has_permission(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.user_has_permission(p_key text) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
  v_access_level TEXT;
  v_facility_id UUID;
  v_granted BOOLEAN;
BEGIN
  SELECT access_level, facility_id INTO v_access_level, v_facility_id
  FROM users WHERE id = auth.uid();

  IF v_access_level IN ('global_admin', 'facility_admin') THEN
    RETURN true;
  END IF;

  SELECT granted INTO v_granted
  FROM facility_permissions
  WHERE facility_id = v_facility_id
    AND access_level = v_access_level
    AND permission_key = p_key;

  RETURN COALESCE(v_granted, false);
END;
$$;


--
-- Name: cost_categories; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cost_categories (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    name text NOT NULL,
    type text NOT NULL,
    description text,
    display_order integer DEFAULT 0 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    CONSTRAINT cost_categories_type_check CHECK ((type = ANY (ARRAY['debit'::text, 'credit'::text])))
);


--
-- Name: active_cost_categories; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.active_cost_categories AS
 SELECT id,
    facility_id,
    name,
    type,
    description,
    display_order,
    is_active,
    created_at,
    updated_at,
    deleted_at
   FROM public.cost_categories
  WHERE ((deleted_at IS NULL) AND (is_active = true));


--
-- Name: admin_sessions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.admin_sessions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    admin_user_id uuid NOT NULL,
    viewing_facility_id uuid NOT NULL,
    started_at timestamp with time zone DEFAULT now(),
    ended_at timestamp with time zone,
    is_active boolean DEFAULT true
);


--
-- Name: audit_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.audit_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    user_email text NOT NULL,
    facility_id uuid,
    action text NOT NULL,
    target_type text,
    target_id uuid,
    target_label text,
    old_values jsonb,
    new_values jsonb,
    metadata jsonb,
    success boolean DEFAULT true,
    error_message text,
    ip_address inet,
    user_agent text,
    impersonating_user_id uuid,
    impersonating_user_email text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: facilities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facilities (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    address text,
    created_at timestamp with time zone DEFAULT now(),
    timezone text DEFAULT 'America/New_York'::text,
    subscription_status text DEFAULT 'trial'::text,
    trial_ends_at timestamp with time zone,
    subscription_started_at timestamp with time zone,
    subscription_ends_at timestamp with time zone,
    stripe_customer_id text,
    is_demo boolean DEFAULT false,
    logo_url text,
    or_hourly_rate numeric(10,2),
    case_number_prefix text,
    rep_reminder_hours_before_case integer DEFAULT 24,
    rep_delivery_reminder_hours_before_case integer DEFAULT 4,
    street_address text,
    street_address_2 text,
    city text,
    state text,
    zip_code text,
    country text DEFAULT 'US'::text,
    phone text,
    facility_type text,
    default_arrival_lead_time_minutes integer DEFAULT 90,
    CONSTRAINT facilities_subscription_status_check CHECK ((subscription_status = ANY (ARRAY['trial'::text, 'active'::text, 'past_due'::text, 'cancelled'::text, 'disabled'::text])))
);


--
-- Name: users; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.users (
    id uuid NOT NULL,
    facility_id uuid,
    role_id uuid NOT NULL,
    first_name text NOT NULL,
    last_name text NOT NULL,
    email text,
    created_at timestamp with time zone DEFAULT now(),
    access_level text DEFAULT 'user'::text NOT NULL,
    last_active_at timestamp with time zone,
    invited_by uuid,
    invited_at timestamp with time zone,
    invitation_token text,
    invitation_expires_at timestamp with time zone,
    must_change_password boolean DEFAULT false,
    last_login_at timestamp with time zone,
    is_active boolean DEFAULT true,
    implant_company_id uuid,
    phone text,
    profile_image_url text,
    closing_workflow text DEFAULT 'surgeon_closes'::text,
    closing_handoff_minutes integer DEFAULT 0,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    CONSTRAINT users_closing_workflow_check CHECK ((closing_workflow = ANY (ARRAY['surgeon_closes'::text, 'pa_closes'::text]))),
    CONSTRAINT valid_access_level CHECK ((access_level = ANY (ARRAY['global_admin'::text, 'facility_admin'::text, 'user'::text, 'device_rep'::text])))
);


--
-- Name: audit_log_with_users; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.audit_log_with_users AS
 SELECT al.id,
    al.user_id,
    al.user_email,
    al.facility_id,
    al.action,
    al.target_type,
    al.target_id,
    al.target_label,
    al.old_values,
    al.new_values,
    al.metadata,
    al.success,
    al.error_message,
    al.ip_address,
    al.user_agent,
    al.impersonating_user_id,
    al.impersonating_user_email,
    al.created_at,
    ((u.first_name || ' '::text) || u.last_name) AS user_name,
    f.name AS facility_name,
    ((iu.first_name || ' '::text) || iu.last_name) AS impersonator_name
   FROM (((public.audit_log al
     LEFT JOIN public.users u ON ((al.user_id = u.id)))
     LEFT JOIN public.facilities f ON ((al.facility_id = f.id)))
     LEFT JOIN public.users iu ON ((al.impersonating_user_id = iu.id)));


--
-- Name: block_schedules; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.block_schedules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    surgeon_id uuid NOT NULL,
    day_of_week integer NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    recurrence_type character varying(20) DEFAULT 'weekly'::character varying NOT NULL,
    effective_start date NOT NULL,
    effective_end date,
    notes text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    exception_dates date[] DEFAULT '{}'::date[],
    CONSTRAINT block_schedules_day_of_week_check CHECK (((day_of_week >= 0) AND (day_of_week <= 6))),
    CONSTRAINT valid_time_range CHECK ((end_time > start_time))
);


--
-- Name: body_regions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.body_regions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name character varying(50) NOT NULL,
    display_name character varying(100) NOT NULL,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    deleted_by uuid,
    is_active boolean DEFAULT true
);


--
-- Name: cancellation_reason_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cancellation_reason_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_name text NOT NULL,
    category text NOT NULL,
    display_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: cancellation_reasons; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cancellation_reasons (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    source_template_id uuid,
    name text NOT NULL,
    display_name text NOT NULL,
    category text NOT NULL,
    display_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: case_completion_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_completion_stats (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    case_number text NOT NULL,
    facility_id uuid NOT NULL,
    surgeon_id uuid,
    procedure_type_id uuid,
    payer_id uuid,
    or_room_id uuid,
    case_date date NOT NULL,
    scheduled_start_time time without time zone,
    actual_start_time time without time zone,
    total_duration_minutes numeric,
    surgical_duration_minutes numeric,
    anesthesia_duration_minutes numeric,
    call_to_patient_in_minutes numeric,
    schedule_variance_minutes numeric,
    room_turnover_minutes numeric,
    surgical_turnover_minutes numeric,
    is_first_case_of_day_room boolean DEFAULT false,
    is_first_case_of_day_surgeon boolean DEFAULT false,
    surgeon_room_count integer,
    surgeon_case_sequence integer,
    room_case_sequence integer,
    reimbursement numeric,
    soft_goods_cost numeric,
    hard_goods_cost numeric,
    or_cost numeric,
    profit numeric,
    or_hourly_rate numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    data_validated boolean DEFAULT true,
    total_debits numeric DEFAULT 0,
    total_credits numeric DEFAULT 0,
    net_cost numeric DEFAULT 0,
    or_time_cost numeric DEFAULT 0,
    is_excluded boolean DEFAULT false,
    excluded_at timestamp with time zone,
    excluded_by uuid,
    exclusion_reason text,
    cost_source text
);


--
-- Name: case_complexities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_complexities (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    complexity_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    created_by uuid
);


--
-- Name: case_delays; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_delays (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    delay_type_id uuid NOT NULL,
    notes text,
    duration_minutes integer,
    recorded_at timestamp with time zone DEFAULT now(),
    recorded_by uuid,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: case_device_activity; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_device_activity (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    implant_company_id uuid,
    activity_type text NOT NULL,
    actor_id uuid,
    actor_type text,
    message text NOT NULL,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT case_device_activity_activity_type_check CHECK ((activity_type = ANY (ARRAY['case_created'::text, 'company_assigned'::text, 'company_removed'::text, 'consignment_confirmed'::text, 'loaners_confirmed'::text, 'trays_delivered'::text, 'reminder_sent'::text, 'status_reset'::text]))),
    CONSTRAINT case_device_activity_actor_type_check CHECK ((actor_type = ANY (ARRAY['facility_staff'::text, 'device_rep'::text, 'system'::text])))
);


--
-- Name: case_device_companies; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_device_companies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    implant_company_id uuid NOT NULL,
    tray_status text DEFAULT 'pending'::text NOT NULL,
    loaner_tray_count integer,
    delivered_tray_count integer,
    confirmed_at timestamp with time zone,
    confirmed_by uuid,
    delivered_at timestamp with time zone,
    delivered_by uuid,
    rep_notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_modified_platform text DEFAULT 'web'::text,
    CONSTRAINT case_device_companies_tray_status_check CHECK ((tray_status = ANY (ARRAY['pending'::text, 'consignment'::text, 'loaners_confirmed'::text, 'delivered'::text])))
);


--
-- Name: cases; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cases (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    case_number text NOT NULL,
    or_room_id uuid,
    procedure_type_id uuid,
    status_id uuid NOT NULL,
    surgeon_id uuid,
    anesthesiologist_id uuid,
    scheduled_date date NOT NULL,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    start_time time without time zone,
    operative_side text,
    call_time timestamp with time zone,
    call_time_recorded_by uuid,
    called_next_case_id uuid,
    payer_id uuid,
    called_back_at timestamp with time zone,
    called_back_by uuid,
    rep_required_override boolean,
    scheduled_duration_minutes integer,
    data_validated boolean DEFAULT false,
    validated_at timestamp with time zone,
    validated_by uuid,
    surgeon_left_at timestamp with time zone,
    cancelled_at timestamp with time zone,
    cancelled_by uuid,
    cancellation_reason_id uuid,
    cancellation_notes text,
    is_excluded_from_metrics boolean DEFAULT false,
    patient_id uuid,
    is_draft boolean DEFAULT false NOT NULL,
    created_by uuid,
    CONSTRAINT cases_operative_side_check CHECK ((operative_side = ANY (ARRAY['left'::text, 'right'::text, 'bilateral'::text, 'n/a'::text])))
);


--
-- Name: implant_companies; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.implant_companies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    facility_id uuid,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    deleted_by uuid,
    is_active boolean DEFAULT true NOT NULL
);


--
-- Name: case_device_companies_detail; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.case_device_companies_detail AS
 SELECT cdc.id,
    cdc.case_id,
    cdc.implant_company_id,
    cdc.tray_status,
    cdc.loaner_tray_count,
    cdc.delivered_tray_count,
    cdc.confirmed_at,
    cdc.confirmed_by,
    cdc.delivered_at,
    cdc.delivered_by,
    cdc.rep_notes,
    cdc.created_at,
    cdc.updated_at,
    ic.name AS company_name,
    c.case_number,
    c.facility_id,
    c.scheduled_date,
    c.start_time,
    confirmed_user.first_name AS confirmed_by_first_name,
    confirmed_user.last_name AS confirmed_by_last_name,
    delivered_user.first_name AS delivered_by_first_name,
    delivered_user.last_name AS delivered_by_last_name
   FROM ((((public.case_device_companies cdc
     JOIN public.implant_companies ic ON ((cdc.implant_company_id = ic.id)))
     JOIN public.cases c ON ((cdc.case_id = c.id)))
     LEFT JOIN public.users confirmed_user ON ((cdc.confirmed_by = confirmed_user.id)))
     LEFT JOIN public.users delivered_user ON ((cdc.delivered_by = delivered_user.id)));


--
-- Name: case_flags; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_flags (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    facility_id uuid NOT NULL,
    flag_type text NOT NULL,
    flag_rule_id uuid,
    metric_value numeric,
    threshold_value numeric,
    comparison_scope text,
    delay_type_id uuid,
    duration_minutes integer,
    severity text DEFAULT 'warning'::text NOT NULL,
    note text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    facility_milestone_id uuid,
    CONSTRAINT case_flags_flag_type_check CHECK ((flag_type = ANY (ARRAY['threshold'::text, 'delay'::text]))),
    CONSTRAINT case_flags_severity_check CHECK ((severity = ANY (ARRAY['info'::text, 'warning'::text, 'critical'::text])))
);


--
-- Name: case_implant_companies; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_implant_companies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    implant_company_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: case_implants; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_implants (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid,
    fixation_type text,
    cup_brand text,
    cup_size_templated text,
    cup_size_final text,
    stem_brand text,
    stem_size_templated text,
    stem_size_final text,
    head_size_templated text,
    head_size_final text,
    liner_size_templated text,
    liner_size_final text,
    femur_brand text,
    femur_type text,
    femur_size_templated text,
    femur_size_final text,
    tibia_brand text,
    tibia_size_templated text,
    tibia_size_final text,
    poly_brand text,
    poly_size_templated text,
    poly_size_final text,
    patella_brand text,
    patella_type text,
    patella_size_templated text,
    patella_size_final text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    rep_notes text,
    CONSTRAINT case_implants_femur_type_check CHECK ((femur_type = ANY (ARRAY['PS'::text, 'CR'::text]))),
    CONSTRAINT case_implants_fixation_type_check CHECK ((fixation_type = ANY (ARRAY['cemented'::text, 'pressfit'::text]))),
    CONSTRAINT case_implants_patella_type_check CHECK ((patella_type = ANY (ARRAY['asymmetric'::text, 'symmetric'::text])))
);


--
-- Name: case_milestone_stats; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_milestone_stats (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    facility_id uuid NOT NULL,
    surgeon_id uuid,
    procedure_type_id uuid,
    milestone_type_id uuid NOT NULL,
    case_date date NOT NULL,
    minutes_from_start numeric NOT NULL,
    recorded_at timestamp with time zone NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: case_milestones; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_milestones (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    recorded_at timestamp with time zone,
    recorded_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    facility_milestone_id uuid,
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: case_staff; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_staff (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    user_id uuid NOT NULL,
    role_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    removed_at timestamp with time zone,
    removed_by uuid
);


--
-- Name: case_statuses; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.case_statuses (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_order integer,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: complexities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.complexities (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid,
    name character varying(100) NOT NULL,
    display_name character varying(100) NOT NULL,
    description text,
    procedure_category_ids uuid[] DEFAULT '{}'::uuid[],
    is_active boolean DEFAULT true,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    source_template_id uuid,
    deleted_at timestamp with time zone,
    deleted_by uuid
);


--
-- Name: complexity_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.complexity_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name character varying(100) NOT NULL,
    display_name character varying(150) NOT NULL,
    description text,
    procedure_category_ids uuid[] DEFAULT '{}'::uuid[],
    is_active boolean DEFAULT true,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    deleted_by uuid
);


--
-- Name: cost_category_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cost_category_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    type text NOT NULL,
    description text,
    display_order integer DEFAULT 0 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    CONSTRAINT default_cost_categories_type_check CHECK ((type = ANY (ARRAY['debit'::text, 'credit'::text])))
);


--
-- Name: data_quality_notifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.data_quality_notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    user_id uuid,
    title text NOT NULL,
    message text NOT NULL,
    notification_type text DEFAULT 'data_quality'::text NOT NULL,
    issues_count integer DEFAULT 0,
    is_read boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    read_at timestamp with time zone
);


--
-- Name: delay_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.delay_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    display_name text NOT NULL,
    facility_id uuid,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    is_active boolean DEFAULT true NOT NULL
);


--
-- Name: device_rep_facility_access; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.device_rep_facility_access (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    facility_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: device_rep_invites; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.device_rep_invites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    email text NOT NULL,
    implant_company_id uuid NOT NULL,
    invited_by uuid,
    invite_token text NOT NULL,
    expires_at timestamp with time zone DEFAULT (now() + '7 days'::interval) NOT NULL,
    accepted_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: device_tokens; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.device_tokens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    token text NOT NULL,
    platform text DEFAULT 'ios'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: error_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.error_logs (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    severity text NOT NULL,
    category text NOT NULL,
    message text NOT NULL,
    stack text,
    context jsonb,
    user_agent text,
    url text,
    facility_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT error_logs_category_check CHECK ((category = ANY (ARRAY['authentication'::text, 'database'::text, 'api'::text, 'validation'::text, 'network'::text, 'system'::text, 'general'::text]))),
    CONSTRAINT error_logs_severity_check CHECK ((severity = ANY (ARRAY['debug'::text, 'info'::text, 'warning'::text, 'error'::text, 'critical'::text])))
);


--
-- Name: escort_status_links; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.escort_status_links (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    checkin_id uuid NOT NULL,
    facility_id uuid NOT NULL,
    token text NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    is_active boolean DEFAULT true,
    view_count integer DEFAULT 0,
    last_viewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    created_by uuid
);


--
-- Name: facility_analytics_settings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facility_analytics_settings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    fcots_milestone text DEFAULT 'patient_in'::text NOT NULL,
    fcots_grace_minutes numeric DEFAULT 2 NOT NULL,
    fcots_target_percent numeric DEFAULT 85 NOT NULL,
    turnover_target_same_surgeon numeric DEFAULT 30 NOT NULL,
    turnover_target_flip_room numeric DEFAULT 45 NOT NULL,
    utilization_target_percent numeric DEFAULT 80 NOT NULL,
    cancellation_target_percent numeric DEFAULT 5 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    start_time_milestone text DEFAULT 'patient_in'::text,
    start_time_grace_minutes integer DEFAULT 3,
    start_time_floor_minutes integer DEFAULT 20,
    waiting_on_surgeon_minutes integer DEFAULT 3,
    waiting_on_surgeon_floor_minutes integer DEFAULT 10,
    min_procedure_cases integer DEFAULT 3,
    CONSTRAINT facility_analytics_settings_fcots_grace_minutes_check CHECK (((fcots_grace_minutes >= (0)::numeric) AND (fcots_grace_minutes <= (30)::numeric))),
    CONSTRAINT facility_analytics_settings_fcots_milestone_check CHECK ((fcots_milestone = ANY (ARRAY['patient_in'::text, 'incision'::text]))),
    CONSTRAINT facility_analytics_settings_fcots_target_percent_check CHECK (((fcots_target_percent >= (0)::numeric) AND (fcots_target_percent <= (100)::numeric))),
    CONSTRAINT facility_analytics_settings_min_procedure_cases_check CHECK (((min_procedure_cases >= 1) AND (min_procedure_cases <= 10))),
    CONSTRAINT facility_analytics_settings_start_time_floor_minutes_check CHECK (((start_time_floor_minutes >= 5) AND (start_time_floor_minutes <= 60))),
    CONSTRAINT facility_analytics_settings_start_time_grace_minutes_check CHECK (((start_time_grace_minutes >= 0) AND (start_time_grace_minutes <= 15))),
    CONSTRAINT facility_analytics_settings_start_time_milestone_check CHECK ((start_time_milestone = ANY (ARRAY['patient_in'::text, 'incision'::text]))),
    CONSTRAINT facility_analytics_settings_waiting_on_surgeon_floor_minu_check CHECK (((waiting_on_surgeon_floor_minutes >= 3) AND (waiting_on_surgeon_floor_minutes <= 30))),
    CONSTRAINT facility_analytics_settings_waiting_on_surgeon_minutes_check CHECK (((waiting_on_surgeon_minutes >= 0) AND (waiting_on_surgeon_minutes <= 15)))
);


--
-- Name: facility_closures; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facility_closures (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    closure_date date NOT NULL,
    reason character varying(200),
    created_by uuid,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: facility_device_reps; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facility_device_reps (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    user_id uuid NOT NULL,
    invited_by uuid,
    invited_at timestamp with time zone DEFAULT now(),
    accepted_at timestamp with time zone,
    status text DEFAULT 'pending'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT facility_device_reps_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'revoked'::text])))
);


--
-- Name: facility_features; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facility_features (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    feature_id uuid NOT NULL,
    is_enabled boolean DEFAULT true,
    enabled_at timestamp with time zone DEFAULT now(),
    enabled_by uuid,
    disabled_at timestamp with time zone,
    disabled_by uuid,
    trial_ends_at timestamp with time zone,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: facility_holidays; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facility_holidays (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    name character varying(100) NOT NULL,
    month integer,
    day integer,
    week_of_month integer,
    day_of_week integer,
    is_active boolean DEFAULT true,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT facility_holidays_day_check CHECK (((day >= 1) AND (day <= 31))),
    CONSTRAINT facility_holidays_day_of_week_check CHECK (((day_of_week >= 0) AND (day_of_week <= 6))),
    CONSTRAINT facility_holidays_month_check CHECK (((month >= 1) AND (month <= 12))),
    CONSTRAINT facility_holidays_week_of_month_check CHECK (((week_of_month >= 1) AND (week_of_month <= 5))),
    CONSTRAINT valid_holiday_definition CHECK ((((day IS NOT NULL) AND (month IS NOT NULL)) OR ((week_of_month IS NOT NULL) AND (day_of_week IS NOT NULL) AND (month IS NOT NULL))))
);


--
-- Name: milestone_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.milestone_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_name text NOT NULL,
    display_order integer,
    created_at timestamp with time zone DEFAULT now(),
    pair_with_id uuid,
    pair_position text,
    is_active boolean DEFAULT true,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    CONSTRAINT milestone_types_pair_position_check CHECK ((pair_position = ANY (ARRAY['start'::text, 'end'::text])))
);


--
-- Name: facility_milestone_stats; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.facility_milestone_stats AS
 SELECT cms.facility_id,
    cms.procedure_type_id,
    cms.milestone_type_id,
    mt.name AS milestone_name,
    mt.display_name AS milestone_display_name,
    count(*) AS sample_size,
    count(DISTINCT cms.surgeon_id) AS surgeon_count,
    avg(cms.minutes_from_start) AS avg_minutes_from_start,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((cms.minutes_from_start)::double precision)) AS median_minutes_from_start,
    stddev(cms.minutes_from_start) AS stddev_minutes_from_start,
    percentile_cont((0.25)::double precision) WITHIN GROUP (ORDER BY ((cms.minutes_from_start)::double precision)) AS p25_minutes_from_start,
    percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((cms.minutes_from_start)::double precision)) AS p75_minutes_from_start,
    min(cms.minutes_from_start) AS min_minutes_from_start,
    max(cms.minutes_from_start) AS max_minutes_from_start
   FROM (public.case_milestone_stats cms
     JOIN public.milestone_types mt ON ((cms.milestone_type_id = mt.id)))
  WHERE (cms.procedure_type_id IS NOT NULL)
  GROUP BY cms.facility_id, cms.procedure_type_id, cms.milestone_type_id, mt.name, mt.display_name
  WITH NO DATA;


--
-- Name: facility_milestones; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facility_milestones (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    name text NOT NULL,
    display_name text NOT NULL,
    display_order integer DEFAULT 0 NOT NULL,
    pair_with_id uuid,
    pair_position text,
    source_milestone_type_id uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    min_minutes integer DEFAULT 1,
    max_minutes integer DEFAULT 90,
    validation_type text DEFAULT 'sequence_gap'::text,
    deleted_by uuid,
    phase_group text,
    CONSTRAINT facility_milestones_pair_position_check CHECK ((pair_position = ANY (ARRAY['start'::text, 'end'::text]))),
    CONSTRAINT facility_milestones_phase_group_check CHECK ((phase_group = ANY (ARRAY['pre_op'::text, 'surgical'::text, 'closing'::text, 'post_op'::text]))),
    CONSTRAINT facility_milestones_validation_type_check CHECK ((validation_type = ANY (ARRAY['duration'::text, 'sequence_gap'::text])))
);


--
-- Name: facility_permissions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.facility_permissions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    access_level text NOT NULL,
    permission_key text NOT NULL,
    granted boolean DEFAULT false NOT NULL,
    updated_at timestamp with time zone DEFAULT now(),
    updated_by uuid
);


--
-- Name: facility_procedure_stats; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.facility_procedure_stats AS
 SELECT facility_id,
    procedure_type_id,
    count(*) AS sample_size,
    count(DISTINCT surgeon_id) AS surgeon_count,
    avg(total_duration_minutes) AS avg_duration,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((total_duration_minutes)::double precision)) AS median_duration,
    stddev(total_duration_minutes) AS stddev_duration,
    percentile_cont((0.25)::double precision) WITHIN GROUP (ORDER BY ((total_duration_minutes)::double precision)) AS p25_duration,
    percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((total_duration_minutes)::double precision)) AS p75_duration,
    min(total_duration_minutes) AS min_duration,
    max(total_duration_minutes) AS max_duration,
    avg(surgical_duration_minutes) AS avg_surgical_duration,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((surgical_duration_minutes)::double precision)) AS median_surgical_duration,
    stddev(surgical_duration_minutes) AS stddev_surgical_duration,
    avg(anesthesia_duration_minutes) AS avg_anesthesia_duration,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((anesthesia_duration_minutes)::double precision)) AS median_anesthesia_duration,
    avg(call_to_patient_in_minutes) AS avg_call_to_patient_in,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((call_to_patient_in_minutes)::double precision)) AS median_call_to_patient_in,
    stddev(call_to_patient_in_minutes) AS stddev_call_to_patient_in,
    avg(schedule_variance_minutes) AS avg_schedule_variance,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((schedule_variance_minutes)::double precision)) AS median_schedule_variance,
    avg(room_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_room)) AS avg_room_turnover,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((room_turnover_minutes)::double precision)) FILTER (WHERE (NOT is_first_case_of_day_room)) AS median_room_turnover,
    stddev(room_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_room)) AS stddev_room_turnover,
    avg(surgical_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_surgeon)) AS avg_surgical_turnover,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((surgical_turnover_minutes)::double precision)) FILTER (WHERE (NOT is_first_case_of_day_surgeon)) AS median_surgical_turnover,
    stddev(surgical_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_surgeon)) AS stddev_surgical_turnover,
    avg(schedule_variance_minutes) FILTER (WHERE is_first_case_of_day_room) AS avg_first_case_delay,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((schedule_variance_minutes)::double precision)) FILTER (WHERE is_first_case_of_day_room) AS median_first_case_delay,
    count(*) FILTER (WHERE is_first_case_of_day_room) AS first_case_count,
    avg(profit) AS avg_profit,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((profit)::double precision)) AS median_profit,
    stddev(profit) AS stddev_profit,
    percentile_cont((0.25)::double precision) WITHIN GROUP (ORDER BY ((profit)::double precision)) AS p25_profit,
    percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((profit)::double precision)) AS p75_profit,
    sum(profit) AS total_profit,
    avg(reimbursement) AS avg_reimbursement,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((reimbursement)::double precision)) AS median_reimbursement,
    max(case_date) AS last_case_date,
    min(case_date) AS first_case_date
   FROM public.case_completion_stats
  WHERE ((procedure_type_id IS NOT NULL) AND (total_duration_minutes IS NOT NULL) AND ((is_excluded = false) OR (is_excluded IS NULL)))
  GROUP BY facility_id, procedure_type_id
  WITH NO DATA;


--
-- Name: features; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.features (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_name text NOT NULL,
    description text,
    icon text,
    is_base_feature boolean DEFAULT false,
    is_active boolean DEFAULT true,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: flag_rules; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.flag_rules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid,
    name text NOT NULL,
    description text,
    category text DEFAULT 'timing'::text NOT NULL,
    metric text NOT NULL,
    start_milestone text,
    end_milestone text,
    operator text DEFAULT 'gt'::text NOT NULL,
    threshold_type text DEFAULT 'median_plus_sd'::text NOT NULL,
    threshold_value numeric DEFAULT 1.0 NOT NULL,
    comparison_scope text DEFAULT 'facility'::text NOT NULL,
    severity text DEFAULT 'warning'::text NOT NULL,
    display_order integer DEFAULT 0,
    is_built_in boolean DEFAULT false,
    is_enabled boolean DEFAULT true,
    source_rule_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: global_milestone_settings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.global_milestone_settings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    milestone_type_id uuid,
    min_minutes integer DEFAULT 1,
    max_minutes integer DEFAULT 90,
    validation_type text DEFAULT 'sequence_gap'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT global_milestone_settings_validation_type_check CHECK ((validation_type = ANY (ARRAY['duration'::text, 'sequence_gap'::text])))
);


--
-- Name: user_sessions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_sessions (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    remember_me boolean DEFAULT false,
    expires_at timestamp with time zone NOT NULL,
    user_agent text,
    ip_address text,
    last_activity timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: global_security_stats; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.global_security_stats AS
 SELECT f.id AS facility_id,
    f.name AS facility_name,
    f.city,
    f.state,
    count(DISTINCT el.id) FILTER (WHERE (el.created_at > (now() - '24:00:00'::interval))) AS errors_24h,
    count(DISTINCT el.id) FILTER (WHERE (el.created_at > (now() - '7 days'::interval))) AS errors_7d,
    count(DISTINCT el.id) FILTER (WHERE (el.severity = ANY (ARRAY['critical'::text, 'error'::text]))) AS critical_errors,
    count(DISTINCT al.id) FILTER (WHERE (al.created_at > (now() - '24:00:00'::interval))) AS actions_24h,
    count(DISTINCT al.id) FILTER (WHERE (al.created_at > (now() - '7 days'::interval))) AS actions_7d,
    count(DISTINCT al.id) FILTER (WHERE ((al.action = 'login'::text) AND (al.success = false))) AS failed_logins,
    count(DISTINCT us.id) FILTER (WHERE (us.expires_at > now())) AS active_sessions
   FROM ((((public.facilities f
     LEFT JOIN public.error_logs el ON ((el.facility_id = f.id)))
     LEFT JOIN public.audit_log al ON ((al.facility_id = f.id)))
     LEFT JOIN public.users u ON ((u.facility_id = f.id)))
     LEFT JOIN public.user_sessions us ON (((us.user_id = u.id) AND (us.expires_at > now()))))
  GROUP BY f.id, f.name, f.city, f.state
  ORDER BY f.name;


--
-- Name: issue_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.issue_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_name text NOT NULL,
    description text,
    severity text DEFAULT 'warning'::text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT issue_types_severity_check CHECK ((severity = ANY (ARRAY['info'::text, 'warning'::text, 'error'::text])))
);


--
-- Name: login_attempts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.login_attempts (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    email text NOT NULL,
    ip_address text,
    attempt_count integer DEFAULT 1,
    blocked_until timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: metric_issues; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.metric_issues (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    case_id uuid NOT NULL,
    issue_type_id uuid NOT NULL,
    facility_milestone_id uuid,
    detected_value numeric,
    expected_min numeric,
    expected_max numeric,
    details jsonb,
    resolution_type_id uuid,
    resolved_at timestamp with time zone,
    resolved_by uuid,
    resolution_notes text,
    detected_at timestamp with time zone DEFAULT now(),
    expires_at timestamp with time zone DEFAULT (now() + '30 days'::interval),
    created_at timestamp with time zone DEFAULT now(),
    milestone_id uuid
);


--
-- Name: mv_facility_health_scores; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.mv_facility_health_scores AS
 SELECT f.id AS facility_id,
    f.name AS facility_name,
    f.city,
    f.state,
    count(DISTINCT el.id) FILTER (WHERE (el.created_at > (now() - '7 days'::interval))) AS errors_7d,
    count(DISTINCT el.id) FILTER (WHERE ((el.severity = ANY (ARRAY['critical'::text, 'error'::text])) AND (el.created_at > (now() - '7 days'::interval)))) AS critical_errors_7d,
    count(DISTINCT al.id) FILTER (WHERE ((al.action = 'login'::text) AND (al.success = false) AND (al.created_at > (now() - '7 days'::interval)))) AS failed_logins_7d,
    GREATEST((0)::bigint, ((100 - (count(DISTINCT el.id) FILTER (WHERE ((el.severity = ANY (ARRAY['critical'::text, 'error'::text])) AND (el.created_at > (now() - '7 days'::interval)))) * 10)) - (count(DISTINCT al.id) FILTER (WHERE ((al.action = 'login'::text) AND (al.success = false) AND (al.created_at > (now() - '7 days'::interval)))) * 5))) AS health_score,
    now() AS last_updated
   FROM ((public.facilities f
     LEFT JOIN public.error_logs el ON ((el.facility_id = f.id)))
     LEFT JOIN public.audit_log al ON ((al.facility_id = f.id)))
  GROUP BY f.id, f.name, f.city, f.state
  WITH NO DATA;


--
-- Name: notification_reads; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notification_reads (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    notification_id uuid NOT NULL,
    user_id uuid NOT NULL,
    read_at timestamp with time zone DEFAULT now()
);


--
-- Name: notifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    type text DEFAULT 'patient_call'::text NOT NULL,
    title text NOT NULL,
    message text,
    room_id uuid,
    case_id uuid,
    sent_by uuid,
    expires_at timestamp with time zone DEFAULT (now() + '24:00:00'::interval) NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: or_rooms; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.or_rooms (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    deleted_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    display_order integer DEFAULT 0,
    available_hours numeric DEFAULT 10
);


--
-- Name: outlier_review_notes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.outlier_review_notes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    outlier_review_id uuid NOT NULL,
    note text NOT NULL,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    is_system_note boolean DEFAULT false
);


--
-- Name: outlier_reviews; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.outlier_reviews (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    facility_id uuid NOT NULL,
    status text DEFAULT 'needs_review'::text NOT NULL,
    reviewed_by uuid,
    reviewed_at timestamp with time zone,
    excluded_reason text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT outlier_reviews_status_check CHECK ((status = ANY (ARRAY['needs_review'::text, 'reviewed'::text, 'excluded'::text])))
);


--
-- Name: page_registry; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.page_registry (
    id text NOT NULL,
    name text NOT NULL,
    route text NOT NULL,
    category text DEFAULT 'Shared'::text NOT NULL,
    description text DEFAULT ''::text NOT NULL,
    roles text[] DEFAULT '{}'::text[] NOT NULL,
    reads text[] DEFAULT '{}'::text[] NOT NULL,
    writes text[] DEFAULT '{}'::text[] NOT NULL,
    rpcs text[] DEFAULT '{}'::text[] NOT NULL,
    realtime text[] DEFAULT '{}'::text[] NOT NULL,
    materialized_views text[] DEFAULT '{}'::text[] NOT NULL,
    calculation_engine text,
    key_validations text[] DEFAULT '{}'::text[] NOT NULL,
    timezone_aware boolean DEFAULT false NOT NULL,
    ios_exists boolean DEFAULT false NOT NULL,
    ios_view_name text,
    ios_notes text,
    parity_notes text,
    components text[] DEFAULT '{}'::text[] NOT NULL,
    interactions text[] DEFAULT '{}'::text[] NOT NULL,
    state_management text,
    api_routes text[] DEFAULT '{}'::text[] NOT NULL,
    owner text,
    notes text,
    display_order integer DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    http_methods text[] DEFAULT '{}'::text[] NOT NULL
);


--
-- Name: page_registry_categories; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.page_registry_categories (
    id text NOT NULL,
    name text NOT NULL,
    description text DEFAULT ''::text NOT NULL,
    color text DEFAULT 'slate'::text NOT NULL,
    display_order integer DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: patient_checkins; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.patient_checkins (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    case_id uuid NOT NULL,
    facility_id uuid NOT NULL,
    patient_status_id uuid NOT NULL,
    status_updated_at timestamp with time zone DEFAULT now(),
    status_updated_by uuid,
    expected_arrival_time timestamp with time zone,
    actual_arrival_time timestamp with time zone,
    checked_in_at timestamp with time zone,
    checked_in_by uuid,
    checklist_responses jsonb DEFAULT '{}'::jsonb,
    checklist_completed_at timestamp with time zone,
    checklist_completed_by uuid,
    escort_name text,
    escort_phone text,
    escort_relationship text,
    escort_notified_at timestamp with time zone,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    patient_id uuid
);


--
-- Name: patient_statuses; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.patient_statuses (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_name text NOT NULL,
    description text,
    color text,
    icon text,
    show_on_escort_page boolean DEFAULT true,
    display_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: payers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.payers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    deleted_by uuid,
    is_active boolean DEFAULT true NOT NULL
);


--
-- Name: user_invites; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_invites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    email text NOT NULL,
    first_name text NOT NULL,
    last_name text NOT NULL,
    facility_id uuid NOT NULL,
    role_id uuid,
    access_level text DEFAULT 'user'::text NOT NULL,
    invite_token text NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    invited_by uuid,
    accepted_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    existing_user_id uuid,
    CONSTRAINT user_invites_access_level_check CHECK ((access_level = ANY (ARRAY['facility_admin'::text, 'user'::text])))
);


--
-- Name: user_roles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_roles (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: pending_user_invites; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.pending_user_invites AS
 SELECT ui.id,
    ui.email,
    ui.first_name,
    ui.last_name,
    ui.facility_id,
    f.name AS facility_name,
    ui.role_id,
    ur.name AS role_name,
    ui.access_level,
    ui.invite_token,
    ui.expires_at,
    ui.invited_by,
    ui.created_at,
        CASE
            WHEN (ui.expires_at < now()) THEN 'expired'::text
            ELSE 'pending'::text
        END AS status
   FROM ((public.user_invites ui
     LEFT JOIN public.facilities f ON ((ui.facility_id = f.id)))
     LEFT JOIN public.user_roles ur ON ((ui.role_id = ur.id)))
  WHERE (ui.accepted_at IS NULL);


--
-- Name: permission_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.permission_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    access_level text NOT NULL,
    permission_key text NOT NULL,
    granted boolean DEFAULT false NOT NULL,
    updated_at timestamp with time zone DEFAULT now(),
    updated_by uuid
);


--
-- Name: permissions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.permissions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    key text NOT NULL,
    label text NOT NULL,
    description text,
    category text NOT NULL,
    resource text NOT NULL,
    resource_type text DEFAULT 'page'::text NOT NULL,
    action text NOT NULL,
    sort_order integer DEFAULT 0 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: preop_checklist_field_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.preop_checklist_field_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    field_key text NOT NULL,
    display_label text NOT NULL,
    field_type text DEFAULT 'toggle'::text NOT NULL,
    options jsonb,
    default_value text,
    placeholder text,
    is_required boolean DEFAULT false,
    show_on_escort_page boolean DEFAULT false,
    display_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    deleted_by uuid
);


--
-- Name: preop_checklist_fields; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.preop_checklist_fields (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    source_template_id uuid,
    field_key text NOT NULL,
    display_label text NOT NULL,
    field_type text DEFAULT 'toggle'::text NOT NULL,
    options jsonb,
    default_value text,
    placeholder text,
    is_required boolean DEFAULT false,
    show_on_escort_page boolean DEFAULT false,
    display_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: procedure_categories; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procedure_categories (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_name text NOT NULL,
    display_order integer DEFAULT 0 NOT NULL,
    body_region_id uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    deleted_by uuid
);


--
-- Name: procedure_cost_items; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procedure_cost_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    procedure_type_id uuid NOT NULL,
    cost_category_id uuid NOT NULL,
    amount numeric DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    effective_from date DEFAULT CURRENT_DATE NOT NULL,
    effective_to date
);


--
-- Name: procedure_milestone_config; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procedure_milestone_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    procedure_type_id uuid NOT NULL,
    facility_milestone_id uuid NOT NULL,
    display_order integer DEFAULT 0 NOT NULL,
    is_enabled boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: procedure_milestone_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procedure_milestone_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    procedure_type_template_id uuid NOT NULL,
    milestone_type_id uuid NOT NULL,
    display_order integer DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: procedure_reimbursements; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procedure_reimbursements (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    procedure_type_id uuid NOT NULL,
    payer_id uuid,
    reimbursement numeric DEFAULT 0 NOT NULL,
    effective_date date DEFAULT CURRENT_DATE NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: procedure_techniques; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procedure_techniques (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name character varying(50) NOT NULL,
    display_name character varying(100) NOT NULL,
    display_order integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: procedure_type_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procedure_type_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    body_region_id uuid,
    is_active boolean DEFAULT true,
    display_order integer,
    created_at timestamp with time zone DEFAULT now(),
    implant_category text,
    procedure_category_id uuid,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    CONSTRAINT default_procedure_types_implant_category_check CHECK ((implant_category = ANY (ARRAY['total_hip'::text, 'total_knee'::text])))
);


--
-- Name: procedure_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procedure_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    body_region_id uuid,
    technique_id uuid,
    implant_category text,
    source_template_id uuid,
    procedure_category_id uuid,
    requires_rep boolean DEFAULT false,
    deleted_at timestamp with time zone,
    deleted_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    arrival_lead_time_minutes integer,
    requires_operative_side boolean DEFAULT false NOT NULL,
    CONSTRAINT procedure_types_implant_category_check CHECK ((implant_category = ANY (ARRAY['total_hip'::text, 'total_knee'::text])))
);


--
-- Name: resolution_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.resolution_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    display_name text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: room_schedules; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.room_schedules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    or_room_id uuid NOT NULL,
    day_of_week smallint NOT NULL,
    open_time time without time zone DEFAULT '07:00:00'::time without time zone NOT NULL,
    close_time time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    is_closed boolean DEFAULT false NOT NULL,
    effective_start date DEFAULT CURRENT_DATE NOT NULL,
    effective_end date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT room_schedules_day_of_week_check CHECK (((day_of_week >= 0) AND (day_of_week <= 6))),
    CONSTRAINT room_schedules_valid_dates CHECK (((effective_end IS NULL) OR (effective_end >= effective_start))),
    CONSTRAINT room_schedules_valid_times CHECK (((is_closed = true) OR (close_time > open_time)))
);


--
-- Name: spd_case_summary; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.spd_case_summary AS
 SELECT c.id AS case_id,
    c.case_number,
    c.facility_id,
    c.scheduled_date,
    c.start_time,
    c.or_room_id,
    r.name AS room_name,
    pt.name AS procedure_name,
    pt.requires_rep AS procedure_requires_rep,
    c.rep_required_override,
    COALESCE(c.rep_required_override, pt.requires_rep, false) AS requires_rep,
    s.first_name AS surgeon_first_name,
    s.last_name AS surgeon_last_name,
    cs.name AS case_status,
    public.get_case_tray_status(c.id) AS tray_status,
    ( SELECT COALESCE(sum(cdc.loaner_tray_count), (0)::bigint) AS "coalesce"
           FROM public.case_device_companies cdc
          WHERE ((cdc.case_id = c.id) AND (cdc.tray_status = ANY (ARRAY['loaners_confirmed'::text, 'delivered'::text])))) AS total_expected_trays,
    ( SELECT COALESCE(sum(cdc.delivered_tray_count), (0)::bigint) AS "coalesce"
           FROM public.case_device_companies cdc
          WHERE ((cdc.case_id = c.id) AND (cdc.tray_status = 'delivered'::text))) AS total_delivered_trays,
    ( SELECT count(*) AS count
           FROM public.case_device_companies cdc
          WHERE (cdc.case_id = c.id)) AS device_company_count,
    ( SELECT count(*) AS count
           FROM public.case_device_companies cdc
          WHERE ((cdc.case_id = c.id) AND (cdc.tray_status = 'pending'::text))) AS pending_company_count
   FROM ((((public.cases c
     LEFT JOIN public.procedure_types pt ON ((c.procedure_type_id = pt.id)))
     LEFT JOIN public.or_rooms r ON ((c.or_room_id = r.id)))
     LEFT JOIN public.users s ON ((c.surgeon_id = s.id)))
     LEFT JOIN public.case_statuses cs ON ((c.status_id = cs.id)))
  WHERE (cs.name <> 'cancelled'::text);


--
-- Name: surgeon_colors; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.surgeon_colors (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    surgeon_id uuid NOT NULL,
    color character varying(7) NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: surgeon_cost_items; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.surgeon_cost_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    surgeon_id uuid NOT NULL,
    procedure_type_id uuid NOT NULL,
    cost_category_id uuid NOT NULL,
    amount numeric DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    effective_from date DEFAULT CURRENT_DATE NOT NULL,
    effective_to date
);


--
-- Name: surgeon_milestone_averages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.surgeon_milestone_averages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    surgeon_id uuid NOT NULL,
    procedure_type_id uuid NOT NULL,
    milestone_type_id uuid NOT NULL,
    avg_minutes_from_start numeric(10,2) NOT NULL,
    sample_size integer DEFAULT 0 NOT NULL,
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: surgeon_milestone_stats; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.surgeon_milestone_stats AS
 SELECT cms.facility_id,
    cms.surgeon_id,
    cms.procedure_type_id,
    cms.milestone_type_id,
    mt.name AS milestone_name,
    mt.display_name AS milestone_display_name,
    count(*) AS sample_size,
    avg(cms.minutes_from_start) AS avg_minutes_from_start,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((cms.minutes_from_start)::double precision)) AS median_minutes_from_start,
    stddev(cms.minutes_from_start) AS stddev_minutes_from_start,
    percentile_cont((0.25)::double precision) WITHIN GROUP (ORDER BY ((cms.minutes_from_start)::double precision)) AS p25_minutes_from_start,
    percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((cms.minutes_from_start)::double precision)) AS p75_minutes_from_start,
    min(cms.minutes_from_start) AS min_minutes_from_start,
    max(cms.minutes_from_start) AS max_minutes_from_start
   FROM (public.case_milestone_stats cms
     JOIN public.milestone_types mt ON ((cms.milestone_type_id = mt.id)))
  WHERE ((cms.surgeon_id IS NOT NULL) AND (cms.procedure_type_id IS NOT NULL))
  GROUP BY cms.facility_id, cms.surgeon_id, cms.procedure_type_id, cms.milestone_type_id, mt.name, mt.display_name
  WITH NO DATA;


--
-- Name: surgeon_overall_stats; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.surgeon_overall_stats AS
 SELECT facility_id,
    surgeon_id,
    count(*) AS total_cases,
    count(DISTINCT procedure_type_id) AS procedure_type_count,
    count(DISTINCT case_date) AS days_worked,
    avg(total_duration_minutes) AS avg_duration,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((total_duration_minutes)::double precision)) AS median_duration,
    stddev(total_duration_minutes) AS stddev_duration,
    avg(surgical_duration_minutes) AS avg_surgical_duration,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((surgical_duration_minutes)::double precision)) AS median_surgical_duration,
    avg(surgical_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_surgeon)) AS avg_surgical_turnover,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((surgical_turnover_minutes)::double precision)) FILTER (WHERE (NOT is_first_case_of_day_surgeon)) AS median_surgical_turnover,
    avg(surgeon_room_count) AS avg_rooms_per_day,
    max(surgeon_room_count) AS max_rooms_per_day,
    count(*) FILTER (WHERE (surgeon_room_count > 1)) AS multi_room_case_count,
    sum(profit) AS total_profit,
    avg(profit) AS avg_profit,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((profit)::double precision)) AS median_profit,
    stddev(profit) AS stddev_profit,
    max(case_date) AS last_case_date,
    min(case_date) AS first_case_date,
    count(*) FILTER (WHERE (case_date >= (CURRENT_DATE - '30 days'::interval))) AS cases_last_30_days,
    count(*) FILTER (WHERE (case_date >= (CURRENT_DATE - '90 days'::interval))) AS cases_last_90_days
   FROM public.case_completion_stats
  WHERE (surgeon_id IS NOT NULL)
  GROUP BY facility_id, surgeon_id
  WITH NO DATA;


--
-- Name: surgeon_preference_companies; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.surgeon_preference_companies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    surgeon_preference_id uuid NOT NULL,
    implant_company_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


--
-- Name: surgeon_preferences; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.surgeon_preferences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    facility_id uuid NOT NULL,
    surgeon_id uuid NOT NULL,
    procedure_type_id uuid NOT NULL,
    name text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: surgeon_procedure_averages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.surgeon_procedure_averages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    surgeon_id uuid NOT NULL,
    procedure_type_id uuid NOT NULL,
    avg_total_minutes numeric(10,2) NOT NULL,
    sample_size integer DEFAULT 0 NOT NULL,
    updated_at timestamp with time zone DEFAULT now()
);


--
-- Name: surgeon_procedure_stats; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.surgeon_procedure_stats AS
 SELECT facility_id,
    surgeon_id,
    procedure_type_id,
    count(*) AS sample_size,
    avg(total_duration_minutes) AS avg_duration,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((total_duration_minutes)::double precision)) AS median_duration,
    stddev(total_duration_minutes) AS stddev_duration,
    percentile_cont((0.25)::double precision) WITHIN GROUP (ORDER BY ((total_duration_minutes)::double precision)) AS p25_duration,
    percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((total_duration_minutes)::double precision)) AS p75_duration,
    min(total_duration_minutes) AS min_duration,
    max(total_duration_minutes) AS max_duration,
    avg(surgical_duration_minutes) AS avg_surgical_duration,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((surgical_duration_minutes)::double precision)) AS median_surgical_duration,
    stddev(surgical_duration_minutes) AS stddev_surgical_duration,
    avg(anesthesia_duration_minutes) AS avg_anesthesia_duration,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((anesthesia_duration_minutes)::double precision)) AS median_anesthesia_duration,
    avg(call_to_patient_in_minutes) AS avg_call_to_patient_in,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((call_to_patient_in_minutes)::double precision)) AS median_call_to_patient_in,
    stddev(call_to_patient_in_minutes) AS stddev_call_to_patient_in,
    avg(schedule_variance_minutes) AS avg_schedule_variance,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((schedule_variance_minutes)::double precision)) AS median_schedule_variance,
    avg(room_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_room)) AS avg_room_turnover,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((room_turnover_minutes)::double precision)) FILTER (WHERE (NOT is_first_case_of_day_room)) AS median_room_turnover,
    stddev(room_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_room)) AS stddev_room_turnover,
    avg(surgical_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_surgeon)) AS avg_surgical_turnover,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((surgical_turnover_minutes)::double precision)) FILTER (WHERE (NOT is_first_case_of_day_surgeon)) AS median_surgical_turnover,
    stddev(surgical_turnover_minutes) FILTER (WHERE (NOT is_first_case_of_day_surgeon)) AS stddev_surgical_turnover,
    avg(schedule_variance_minutes) FILTER (WHERE is_first_case_of_day_room) AS avg_first_case_delay,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((schedule_variance_minutes)::double precision)) FILTER (WHERE is_first_case_of_day_room) AS median_first_case_delay,
    count(*) FILTER (WHERE is_first_case_of_day_room) AS first_case_count,
    avg(profit) AS avg_profit,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((profit)::double precision)) AS median_profit,
    stddev(profit) AS stddev_profit,
    percentile_cont((0.25)::double precision) WITHIN GROUP (ORDER BY ((profit)::double precision)) AS p25_profit,
    percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((profit)::double precision)) AS p75_profit,
    sum(profit) AS total_profit,
    avg(reimbursement) AS avg_reimbursement,
    percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((reimbursement)::double precision)) AS median_reimbursement,
    max(case_date) AS last_case_date,
    min(case_date) AS first_case_date
   FROM public.case_completion_stats
  WHERE ((surgeon_id IS NOT NULL) AND (procedure_type_id IS NOT NULL) AND (total_duration_minutes IS NOT NULL) AND ((is_excluded = false) OR (is_excluded IS NULL)))
  GROUP BY facility_id, surgeon_id, procedure_type_id
  WITH NO DATA;


--
-- Name: v_daily_checkins; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.v_daily_checkins AS
 SELECT c.id AS case_id,
    c.case_number,
    c.facility_id,
    c.scheduled_date,
    c.start_time,
    c.or_room_id,
    c.procedure_type_id,
    c.surgeon_id,
    c.patient_id,
    p.identifier AS patient_identifier,
    p.first_name AS patient_first_name,
    p.last_name AS patient_last_name,
    pc.id AS checkin_id,
    pc.patient_status_id,
    pc.expected_arrival_time,
    pc.actual_arrival_time,
    pc.checked_in_at,
    pc.escort_name,
    pc.escort_phone,
    pc.checklist_responses,
    pc.checklist_completed_at,
        CASE
            WHEN (pc.id IS NULL) THEN 'no_record'::text
            WHEN (pc.checklist_completed_at IS NOT NULL) THEN 'complete'::text
            WHEN (pc.checked_in_at IS NOT NULL) THEN 'checked_in'::text
            ELSE 'pending'::text
        END AS checkin_status
   FROM ((public.cases c
     LEFT JOIN public.patients p ON ((c.patient_id = p.id)))
     LEFT JOIN public.patient_checkins pc ON ((c.id = pc.case_id)));


--
-- Name: admin_sessions admin_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.admin_sessions
    ADD CONSTRAINT admin_sessions_pkey PRIMARY KEY (id);


--
-- Name: audit_log audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_pkey PRIMARY KEY (id);


--
-- Name: block_schedules block_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.block_schedules
    ADD CONSTRAINT block_schedules_pkey PRIMARY KEY (id);


--
-- Name: body_regions body_regions_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.body_regions
    ADD CONSTRAINT body_regions_name_key UNIQUE (name);


--
-- Name: body_regions body_regions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.body_regions
    ADD CONSTRAINT body_regions_pkey PRIMARY KEY (id);


--
-- Name: cancellation_reason_templates cancellation_reason_templates_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cancellation_reason_templates
    ADD CONSTRAINT cancellation_reason_templates_name_key UNIQUE (name);


--
-- Name: cancellation_reason_templates cancellation_reason_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cancellation_reason_templates
    ADD CONSTRAINT cancellation_reason_templates_pkey PRIMARY KEY (id);


--
-- Name: cancellation_reasons cancellation_reasons_facility_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cancellation_reasons
    ADD CONSTRAINT cancellation_reasons_facility_id_name_key UNIQUE (facility_id, name);


--
-- Name: cancellation_reasons cancellation_reasons_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cancellation_reasons
    ADD CONSTRAINT cancellation_reasons_pkey PRIMARY KEY (id);


--
-- Name: case_completion_stats case_completion_stats_case_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_case_id_key UNIQUE (case_id);


--
-- Name: case_completion_stats case_completion_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_pkey PRIMARY KEY (id);


--
-- Name: case_complexities case_complexities_case_id_complexity_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_complexities
    ADD CONSTRAINT case_complexities_case_id_complexity_id_key UNIQUE (case_id, complexity_id);


--
-- Name: case_complexities case_complexities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_complexities
    ADD CONSTRAINT case_complexities_pkey PRIMARY KEY (id);


--
-- Name: case_delays case_delays_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_delays
    ADD CONSTRAINT case_delays_pkey PRIMARY KEY (id);


--
-- Name: case_device_activity case_device_activity_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_activity
    ADD CONSTRAINT case_device_activity_pkey PRIMARY KEY (id);


--
-- Name: case_device_companies case_device_companies_case_id_implant_company_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_companies
    ADD CONSTRAINT case_device_companies_case_id_implant_company_id_key UNIQUE (case_id, implant_company_id);


--
-- Name: case_device_companies case_device_companies_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_companies
    ADD CONSTRAINT case_device_companies_pkey PRIMARY KEY (id);


--
-- Name: case_flags case_flags_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_flags
    ADD CONSTRAINT case_flags_pkey PRIMARY KEY (id);


--
-- Name: case_implant_companies case_implant_companies_case_id_implant_company_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_implant_companies
    ADD CONSTRAINT case_implant_companies_case_id_implant_company_id_key UNIQUE (case_id, implant_company_id);


--
-- Name: case_implant_companies case_implant_companies_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_implant_companies
    ADD CONSTRAINT case_implant_companies_pkey PRIMARY KEY (id);


--
-- Name: case_implants case_implants_case_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_implants
    ADD CONSTRAINT case_implants_case_id_key UNIQUE (case_id);


--
-- Name: case_implants case_implants_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_implants
    ADD CONSTRAINT case_implants_pkey PRIMARY KEY (id);


--
-- Name: case_milestone_stats case_milestone_stats_case_id_milestone_type_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestone_stats
    ADD CONSTRAINT case_milestone_stats_case_id_milestone_type_id_key UNIQUE (case_id, milestone_type_id);


--
-- Name: case_milestone_stats case_milestone_stats_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestone_stats
    ADD CONSTRAINT case_milestone_stats_pkey PRIMARY KEY (id);


--
-- Name: case_milestones case_milestones_case_id_facility_milestone_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestones
    ADD CONSTRAINT case_milestones_case_id_facility_milestone_id_key UNIQUE (case_id, facility_milestone_id);


--
-- Name: case_milestones case_milestones_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestones
    ADD CONSTRAINT case_milestones_pkey PRIMARY KEY (id);


--
-- Name: case_staff case_staff_case_id_user_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_staff
    ADD CONSTRAINT case_staff_case_id_user_id_key UNIQUE (case_id, user_id);


--
-- Name: case_staff case_staff_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_staff
    ADD CONSTRAINT case_staff_pkey PRIMARY KEY (id);


--
-- Name: case_statuses case_statuses_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_statuses
    ADD CONSTRAINT case_statuses_name_key UNIQUE (name);


--
-- Name: case_statuses case_statuses_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_statuses
    ADD CONSTRAINT case_statuses_pkey PRIMARY KEY (id);


--
-- Name: cases cases_facility_id_case_number_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_facility_id_case_number_key UNIQUE (facility_id, case_number);


--
-- Name: cases cases_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_pkey PRIMARY KEY (id);


--
-- Name: complexities complexities_facility_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.complexities
    ADD CONSTRAINT complexities_facility_id_name_key UNIQUE (facility_id, name);


--
-- Name: complexities complexities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.complexities
    ADD CONSTRAINT complexities_pkey PRIMARY KEY (id);


--
-- Name: complexity_templates complexity_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.complexity_templates
    ADD CONSTRAINT complexity_templates_pkey PRIMARY KEY (id);


--
-- Name: cost_categories cost_categories_facility_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_categories
    ADD CONSTRAINT cost_categories_facility_id_name_key UNIQUE (facility_id, name);


--
-- Name: cost_categories cost_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_categories
    ADD CONSTRAINT cost_categories_pkey PRIMARY KEY (id);


--
-- Name: cost_category_templates cost_category_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_category_templates
    ADD CONSTRAINT cost_category_templates_pkey PRIMARY KEY (id);


--
-- Name: data_quality_notifications data_quality_notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.data_quality_notifications
    ADD CONSTRAINT data_quality_notifications_pkey PRIMARY KEY (id);


--
-- Name: delay_types delay_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.delay_types
    ADD CONSTRAINT delay_types_pkey PRIMARY KEY (id);


--
-- Name: device_rep_facility_access device_rep_facility_access_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_facility_access
    ADD CONSTRAINT device_rep_facility_access_pkey PRIMARY KEY (id);


--
-- Name: device_rep_facility_access device_rep_facility_access_user_id_facility_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_facility_access
    ADD CONSTRAINT device_rep_facility_access_user_id_facility_id_key UNIQUE (user_id, facility_id);


--
-- Name: device_rep_invites device_rep_invites_facility_id_email_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_invites
    ADD CONSTRAINT device_rep_invites_facility_id_email_key UNIQUE (facility_id, email);


--
-- Name: device_rep_invites device_rep_invites_invite_token_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_invites
    ADD CONSTRAINT device_rep_invites_invite_token_key UNIQUE (invite_token);


--
-- Name: device_rep_invites device_rep_invites_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_invites
    ADD CONSTRAINT device_rep_invites_pkey PRIMARY KEY (id);


--
-- Name: device_tokens device_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_tokens
    ADD CONSTRAINT device_tokens_pkey PRIMARY KEY (id);


--
-- Name: device_tokens device_tokens_user_id_token_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_tokens
    ADD CONSTRAINT device_tokens_user_id_token_key UNIQUE (user_id, token);


--
-- Name: error_logs error_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.error_logs
    ADD CONSTRAINT error_logs_pkey PRIMARY KEY (id);


--
-- Name: escort_status_links escort_status_links_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.escort_status_links
    ADD CONSTRAINT escort_status_links_pkey PRIMARY KEY (id);


--
-- Name: escort_status_links escort_status_links_token_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.escort_status_links
    ADD CONSTRAINT escort_status_links_token_key UNIQUE (token);


--
-- Name: facilities facilities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facilities
    ADD CONSTRAINT facilities_pkey PRIMARY KEY (id);


--
-- Name: facility_analytics_settings facility_analytics_settings_facility_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_analytics_settings
    ADD CONSTRAINT facility_analytics_settings_facility_id_key UNIQUE (facility_id);


--
-- Name: facility_analytics_settings facility_analytics_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_analytics_settings
    ADD CONSTRAINT facility_analytics_settings_pkey PRIMARY KEY (id);


--
-- Name: facility_closures facility_closures_facility_id_closure_date_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_closures
    ADD CONSTRAINT facility_closures_facility_id_closure_date_key UNIQUE (facility_id, closure_date);


--
-- Name: facility_closures facility_closures_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_closures
    ADD CONSTRAINT facility_closures_pkey PRIMARY KEY (id);


--
-- Name: facility_device_reps facility_device_reps_facility_id_user_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_device_reps
    ADD CONSTRAINT facility_device_reps_facility_id_user_id_key UNIQUE (facility_id, user_id);


--
-- Name: facility_device_reps facility_device_reps_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_device_reps
    ADD CONSTRAINT facility_device_reps_pkey PRIMARY KEY (id);


--
-- Name: facility_features facility_features_facility_id_feature_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_features
    ADD CONSTRAINT facility_features_facility_id_feature_id_key UNIQUE (facility_id, feature_id);


--
-- Name: facility_features facility_features_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_features
    ADD CONSTRAINT facility_features_pkey PRIMARY KEY (id);


--
-- Name: facility_holidays facility_holidays_facility_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_holidays
    ADD CONSTRAINT facility_holidays_facility_id_name_key UNIQUE (facility_id, name);


--
-- Name: facility_holidays facility_holidays_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_holidays
    ADD CONSTRAINT facility_holidays_pkey PRIMARY KEY (id);


--
-- Name: facility_milestones facility_milestones_facility_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_milestones
    ADD CONSTRAINT facility_milestones_facility_id_name_key UNIQUE (facility_id, name);


--
-- Name: facility_milestones facility_milestones_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_milestones
    ADD CONSTRAINT facility_milestones_pkey PRIMARY KEY (id);


--
-- Name: facility_permissions facility_permissions_facility_id_access_level_permission_ke_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_permissions
    ADD CONSTRAINT facility_permissions_facility_id_access_level_permission_ke_key UNIQUE (facility_id, access_level, permission_key);


--
-- Name: facility_permissions facility_permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_permissions
    ADD CONSTRAINT facility_permissions_pkey PRIMARY KEY (id);


--
-- Name: features features_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.features
    ADD CONSTRAINT features_name_key UNIQUE (name);


--
-- Name: features features_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.features
    ADD CONSTRAINT features_pkey PRIMARY KEY (id);


--
-- Name: flag_rules flag_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.flag_rules
    ADD CONSTRAINT flag_rules_pkey PRIMARY KEY (id);


--
-- Name: global_milestone_settings global_milestone_settings_milestone_type_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.global_milestone_settings
    ADD CONSTRAINT global_milestone_settings_milestone_type_id_key UNIQUE (milestone_type_id);


--
-- Name: global_milestone_settings global_milestone_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.global_milestone_settings
    ADD CONSTRAINT global_milestone_settings_pkey PRIMARY KEY (id);


--
-- Name: implant_companies implant_companies_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.implant_companies
    ADD CONSTRAINT implant_companies_pkey PRIMARY KEY (id);


--
-- Name: issue_types issue_types_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.issue_types
    ADD CONSTRAINT issue_types_name_key UNIQUE (name);


--
-- Name: issue_types issue_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.issue_types
    ADD CONSTRAINT issue_types_pkey PRIMARY KEY (id);


--
-- Name: login_attempts login_attempts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.login_attempts
    ADD CONSTRAINT login_attempts_pkey PRIMARY KEY (id);


--
-- Name: metric_issues metric_issues_case_id_facility_milestone_id_issue_type_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_case_id_facility_milestone_id_issue_type_id_key UNIQUE (case_id, facility_milestone_id, issue_type_id);


--
-- Name: metric_issues metric_issues_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_pkey PRIMARY KEY (id);


--
-- Name: milestone_types milestone_types_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.milestone_types
    ADD CONSTRAINT milestone_types_name_key UNIQUE (name);


--
-- Name: milestone_types milestone_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.milestone_types
    ADD CONSTRAINT milestone_types_pkey PRIMARY KEY (id);


--
-- Name: notification_reads notification_reads_notification_id_user_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_reads
    ADD CONSTRAINT notification_reads_notification_id_user_id_key UNIQUE (notification_id, user_id);


--
-- Name: notification_reads notification_reads_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_reads
    ADD CONSTRAINT notification_reads_pkey PRIMARY KEY (id);


--
-- Name: notifications notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_pkey PRIMARY KEY (id);


--
-- Name: or_rooms or_rooms_facility_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.or_rooms
    ADD CONSTRAINT or_rooms_facility_id_name_key UNIQUE (facility_id, name);


--
-- Name: or_rooms or_rooms_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.or_rooms
    ADD CONSTRAINT or_rooms_pkey PRIMARY KEY (id);


--
-- Name: outlier_review_notes outlier_review_notes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.outlier_review_notes
    ADD CONSTRAINT outlier_review_notes_pkey PRIMARY KEY (id);


--
-- Name: outlier_reviews outlier_reviews_case_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.outlier_reviews
    ADD CONSTRAINT outlier_reviews_case_id_key UNIQUE (case_id);


--
-- Name: outlier_reviews outlier_reviews_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.outlier_reviews
    ADD CONSTRAINT outlier_reviews_pkey PRIMARY KEY (id);


--
-- Name: page_registry_categories page_registry_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.page_registry_categories
    ADD CONSTRAINT page_registry_categories_pkey PRIMARY KEY (id);


--
-- Name: page_registry page_registry_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.page_registry
    ADD CONSTRAINT page_registry_pkey PRIMARY KEY (id);


--
-- Name: patient_checkins patient_checkins_case_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_case_id_key UNIQUE (case_id);


--
-- Name: patient_checkins patient_checkins_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_pkey PRIMARY KEY (id);


--
-- Name: patient_statuses patient_statuses_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_statuses
    ADD CONSTRAINT patient_statuses_name_key UNIQUE (name);


--
-- Name: patient_statuses patient_statuses_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_statuses
    ADD CONSTRAINT patient_statuses_pkey PRIMARY KEY (id);


--
-- Name: patients patients_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patients
    ADD CONSTRAINT patients_pkey PRIMARY KEY (id);


--
-- Name: payers payers_facility_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payers
    ADD CONSTRAINT payers_facility_id_name_key UNIQUE (facility_id, name);


--
-- Name: payers payers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payers
    ADD CONSTRAINT payers_pkey PRIMARY KEY (id);


--
-- Name: permission_templates permission_templates_access_level_permission_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.permission_templates
    ADD CONSTRAINT permission_templates_access_level_permission_key_key UNIQUE (access_level, permission_key);


--
-- Name: permission_templates permission_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.permission_templates
    ADD CONSTRAINT permission_templates_pkey PRIMARY KEY (id);


--
-- Name: permissions permissions_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.permissions
    ADD CONSTRAINT permissions_key_key UNIQUE (key);


--
-- Name: permissions permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.permissions
    ADD CONSTRAINT permissions_pkey PRIMARY KEY (id);


--
-- Name: preop_checklist_field_templates preop_checklist_field_templates_field_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preop_checklist_field_templates
    ADD CONSTRAINT preop_checklist_field_templates_field_key_key UNIQUE (field_key);


--
-- Name: preop_checklist_field_templates preop_checklist_field_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preop_checklist_field_templates
    ADD CONSTRAINT preop_checklist_field_templates_pkey PRIMARY KEY (id);


--
-- Name: preop_checklist_fields preop_checklist_fields_facility_id_field_key_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preop_checklist_fields
    ADD CONSTRAINT preop_checklist_fields_facility_id_field_key_key UNIQUE (facility_id, field_key);


--
-- Name: preop_checklist_fields preop_checklist_fields_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preop_checklist_fields
    ADD CONSTRAINT preop_checklist_fields_pkey PRIMARY KEY (id);


--
-- Name: procedure_categories procedure_categories_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_categories
    ADD CONSTRAINT procedure_categories_name_key UNIQUE (name);


--
-- Name: procedure_categories procedure_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_categories
    ADD CONSTRAINT procedure_categories_pkey PRIMARY KEY (id);


--
-- Name: procedure_cost_items procedure_cost_items_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_cost_items
    ADD CONSTRAINT procedure_cost_items_pkey PRIMARY KEY (id);


--
-- Name: procedure_cost_items procedure_cost_items_procedure_type_id_cost_category_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_cost_items
    ADD CONSTRAINT procedure_cost_items_procedure_type_id_cost_category_id_key UNIQUE (procedure_type_id, cost_category_id);


--
-- Name: procedure_milestone_config procedure_milestone_config_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_config
    ADD CONSTRAINT procedure_milestone_config_pkey PRIMARY KEY (id);


--
-- Name: procedure_milestone_config procedure_milestone_config_procedure_type_id_facility_miles_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_config
    ADD CONSTRAINT procedure_milestone_config_procedure_type_id_facility_miles_key UNIQUE (procedure_type_id, facility_milestone_id);


--
-- Name: procedure_milestone_templates procedure_milestone_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_templates
    ADD CONSTRAINT procedure_milestone_templates_pkey PRIMARY KEY (id);


--
-- Name: procedure_milestone_templates procedure_milestone_templates_procedure_type_template_id_milest; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_templates
    ADD CONSTRAINT procedure_milestone_templates_procedure_type_template_id_milest UNIQUE (procedure_type_template_id, milestone_type_id);


--
-- Name: procedure_reimbursements procedure_reimbursements_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_reimbursements
    ADD CONSTRAINT procedure_reimbursements_pkey PRIMARY KEY (id);


--
-- Name: procedure_techniques procedure_techniques_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_techniques
    ADD CONSTRAINT procedure_techniques_name_key UNIQUE (name);


--
-- Name: procedure_techniques procedure_techniques_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_techniques
    ADD CONSTRAINT procedure_techniques_pkey PRIMARY KEY (id);


--
-- Name: procedure_type_templates procedure_type_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_type_templates
    ADD CONSTRAINT procedure_type_templates_pkey PRIMARY KEY (id);


--
-- Name: procedure_types procedure_types_facility_id_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_types
    ADD CONSTRAINT procedure_types_facility_id_name_key UNIQUE (facility_id, name);


--
-- Name: procedure_types procedure_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_types
    ADD CONSTRAINT procedure_types_pkey PRIMARY KEY (id);


--
-- Name: resolution_types resolution_types_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.resolution_types
    ADD CONSTRAINT resolution_types_name_key UNIQUE (name);


--
-- Name: resolution_types resolution_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.resolution_types
    ADD CONSTRAINT resolution_types_pkey PRIMARY KEY (id);


--
-- Name: room_schedules room_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.room_schedules
    ADD CONSTRAINT room_schedules_pkey PRIMARY KEY (id);


--
-- Name: surgeon_colors surgeon_colors_facility_id_surgeon_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_colors
    ADD CONSTRAINT surgeon_colors_facility_id_surgeon_id_key UNIQUE (facility_id, surgeon_id);


--
-- Name: surgeon_colors surgeon_colors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_colors
    ADD CONSTRAINT surgeon_colors_pkey PRIMARY KEY (id);


--
-- Name: surgeon_cost_items surgeon_cost_items_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_cost_items
    ADD CONSTRAINT surgeon_cost_items_pkey PRIMARY KEY (id);


--
-- Name: surgeon_cost_items surgeon_cost_items_surgeon_id_procedure_type_id_cost_catego_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_cost_items
    ADD CONSTRAINT surgeon_cost_items_surgeon_id_procedure_type_id_cost_catego_key UNIQUE (surgeon_id, procedure_type_id, cost_category_id);


--
-- Name: surgeon_milestone_averages surgeon_milestone_averages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_milestone_averages
    ADD CONSTRAINT surgeon_milestone_averages_pkey PRIMARY KEY (id);


--
-- Name: surgeon_milestone_averages surgeon_milestone_averages_surgeon_id_procedure_type_id_mil_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_milestone_averages
    ADD CONSTRAINT surgeon_milestone_averages_surgeon_id_procedure_type_id_mil_key UNIQUE (surgeon_id, procedure_type_id, milestone_type_id);


--
-- Name: surgeon_milestone_averages surgeon_milestone_averages_surgeon_procedure_milestone_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_milestone_averages
    ADD CONSTRAINT surgeon_milestone_averages_surgeon_procedure_milestone_key UNIQUE (surgeon_id, procedure_type_id, milestone_type_id);


--
-- Name: surgeon_preference_companies surgeon_preference_companies_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preference_companies
    ADD CONSTRAINT surgeon_preference_companies_pkey PRIMARY KEY (id);


--
-- Name: surgeon_preference_companies surgeon_preference_companies_surgeon_preference_id_implant__key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preference_companies
    ADD CONSTRAINT surgeon_preference_companies_surgeon_preference_id_implant__key UNIQUE (surgeon_preference_id, implant_company_id);


--
-- Name: surgeon_preferences surgeon_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preferences
    ADD CONSTRAINT surgeon_preferences_pkey PRIMARY KEY (id);


--
-- Name: surgeon_procedure_averages surgeon_procedure_averages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_procedure_averages
    ADD CONSTRAINT surgeon_procedure_averages_pkey PRIMARY KEY (id);


--
-- Name: surgeon_procedure_averages surgeon_procedure_averages_surgeon_id_procedure_type_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_procedure_averages
    ADD CONSTRAINT surgeon_procedure_averages_surgeon_id_procedure_type_id_key UNIQUE (surgeon_id, procedure_type_id);


--
-- Name: surgeon_procedure_averages surgeon_procedure_averages_surgeon_procedure_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_procedure_averages
    ADD CONSTRAINT surgeon_procedure_averages_surgeon_procedure_key UNIQUE (surgeon_id, procedure_type_id);


--
-- Name: procedure_milestone_config uq_proc_milestone_config; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_config
    ADD CONSTRAINT uq_proc_milestone_config UNIQUE (facility_id, procedure_type_id, facility_milestone_id);


--
-- Name: user_invites user_invites_invite_token_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_invites
    ADD CONSTRAINT user_invites_invite_token_key UNIQUE (invite_token);


--
-- Name: user_invites user_invites_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_invites
    ADD CONSTRAINT user_invites_pkey PRIMARY KEY (id);


--
-- Name: user_roles user_roles_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_name_key UNIQUE (name);


--
-- Name: user_roles user_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_pkey PRIMARY KEY (id);


--
-- Name: user_sessions user_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_sessions
    ADD CONSTRAINT user_sessions_pkey PRIMARY KEY (id);


--
-- Name: users users_email_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: idx_admin_sessions_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_admin_sessions_active ON public.admin_sessions USING btree (admin_user_id, is_active) WHERE (is_active = true);


--
-- Name: idx_audit_log_action; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_action ON public.audit_log USING btree (action);


--
-- Name: idx_audit_log_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_created_at ON public.audit_log USING btree (created_at DESC);


--
-- Name: idx_audit_log_facility_action_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_facility_action_created ON public.audit_log USING btree (facility_id, action, created_at DESC);


--
-- Name: idx_audit_log_facility_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_facility_created ON public.audit_log USING btree (facility_id, created_at DESC);


--
-- Name: idx_audit_log_facility_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_facility_date ON public.audit_log USING btree (facility_id, created_at DESC);


--
-- Name: idx_audit_log_facility_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_facility_id ON public.audit_log USING btree (facility_id);


--
-- Name: idx_audit_log_target; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_target ON public.audit_log USING btree (target_type, target_id);


--
-- Name: idx_audit_log_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_audit_log_user_id ON public.audit_log USING btree (user_id);


--
-- Name: idx_block_schedules_day; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_block_schedules_day ON public.block_schedules USING btree (day_of_week) WHERE (deleted_at IS NULL);


--
-- Name: idx_block_schedules_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_block_schedules_facility ON public.block_schedules USING btree (facility_id) WHERE (deleted_at IS NULL);


--
-- Name: idx_block_schedules_surgeon; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_block_schedules_surgeon ON public.block_schedules USING btree (surgeon_id) WHERE (deleted_at IS NULL);


--
-- Name: idx_body_regions_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_body_regions_active ON public.body_regions USING btree (deleted_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_cancellation_reason_templates_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cancellation_reason_templates_active ON public.cancellation_reason_templates USING btree (is_active) WHERE ((is_active = true) AND (deleted_at IS NULL));


--
-- Name: idx_cancellation_reasons_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cancellation_reasons_active ON public.cancellation_reasons USING btree (facility_id, is_active) WHERE ((is_active = true) AND (deleted_at IS NULL));


--
-- Name: idx_cancellation_reasons_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cancellation_reasons_facility ON public.cancellation_reasons USING btree (facility_id);


--
-- Name: idx_case_complexities_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_complexities_case ON public.case_complexities USING btree (case_id);


--
-- Name: idx_case_delays_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_delays_case ON public.case_delays USING btree (case_id);


--
-- Name: idx_case_device_activity_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_device_activity_case ON public.case_device_activity USING btree (case_id);


--
-- Name: idx_case_device_activity_company; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_device_activity_company ON public.case_device_activity USING btree (implant_company_id) WHERE (implant_company_id IS NOT NULL);


--
-- Name: idx_case_device_activity_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_device_activity_created ON public.case_device_activity USING btree (created_at DESC);


--
-- Name: idx_case_device_companies_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_device_companies_case ON public.case_device_companies USING btree (case_id);


--
-- Name: idx_case_device_companies_company; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_device_companies_company ON public.case_device_companies USING btree (implant_company_id);


--
-- Name: idx_case_device_companies_pending; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_device_companies_pending ON public.case_device_companies USING btree (tray_status) WHERE (tray_status = 'pending'::text);


--
-- Name: idx_case_device_companies_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_device_companies_status ON public.case_device_companies USING btree (tray_status);


--
-- Name: idx_case_flags_case_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_case_id ON public.case_flags USING btree (case_id);


--
-- Name: idx_case_flags_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_created_at ON public.case_flags USING btree (created_at DESC);


--
-- Name: idx_case_flags_delay_type_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_delay_type_id ON public.case_flags USING btree (delay_type_id);


--
-- Name: idx_case_flags_facility_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_facility_id ON public.case_flags USING btree (facility_id);


--
-- Name: idx_case_flags_facility_milestone_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_facility_milestone_id ON public.case_flags USING btree (facility_milestone_id) WHERE (facility_milestone_id IS NOT NULL);


--
-- Name: idx_case_flags_facility_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_facility_severity ON public.case_flags USING btree (facility_id, severity, created_at DESC);


--
-- Name: idx_case_flags_flag_rule_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_flag_rule_id ON public.case_flags USING btree (flag_rule_id);


--
-- Name: idx_case_flags_flag_type; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_flag_type ON public.case_flags USING btree (flag_type);


--
-- Name: idx_case_flags_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_flags_severity ON public.case_flags USING btree (severity);


--
-- Name: idx_case_implant_companies_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_implant_companies_case ON public.case_implant_companies USING btree (case_id);


--
-- Name: idx_case_implant_companies_company; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_implant_companies_company ON public.case_implant_companies USING btree (implant_company_id);


--
-- Name: idx_case_milestones_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_milestones_case ON public.case_milestones USING btree (case_id);


--
-- Name: idx_case_milestones_recorded; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_milestones_recorded ON public.case_milestones USING btree (recorded_at);


--
-- Name: idx_case_staff_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_case_staff_case ON public.case_staff USING btree (case_id);


--
-- Name: idx_cases_called_back; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_called_back ON public.cases USING btree (called_back_at) WHERE (called_back_at IS NOT NULL);


--
-- Name: idx_cases_cancellation; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_cancellation ON public.cases USING btree (cancellation_reason_id) WHERE (cancellation_reason_id IS NOT NULL);


--
-- Name: idx_cases_cancelled_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_cancelled_at ON public.cases USING btree (cancelled_at) WHERE (cancelled_at IS NOT NULL);


--
-- Name: idx_cases_data_validated; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_data_validated ON public.cases USING btree (data_validated) WHERE (data_validated = true);


--
-- Name: idx_cases_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_facility ON public.cases USING btree (facility_id);


--
-- Name: idx_cases_facility_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_facility_date ON public.cases USING btree (facility_id, scheduled_date);


--
-- Name: idx_cases_facility_status_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_facility_status_date ON public.cases USING btree (facility_id, status_id, scheduled_date);


--
-- Name: idx_cases_patient; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_patient ON public.cases USING btree (patient_id) WHERE (patient_id IS NOT NULL);


--
-- Name: idx_cases_scheduled_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_scheduled_date ON public.cases USING btree (scheduled_date);


--
-- Name: idx_cases_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_status ON public.cases USING btree (status_id);


--
-- Name: idx_cases_surgeon_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_surgeon_date ON public.cases USING btree (surgeon_id, scheduled_date) WHERE (surgeon_id IS NOT NULL);


--
-- Name: idx_cases_validation_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cases_validation_status ON public.cases USING btree (data_validated, is_excluded_from_metrics);


--
-- Name: idx_ccs_case_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ccs_case_date ON public.case_completion_stats USING btree (case_date);


--
-- Name: idx_ccs_excluded; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ccs_excluded ON public.case_completion_stats USING btree (facility_id, excluded_at) WHERE (is_excluded = true);


--
-- Name: idx_ccs_facility_procedure; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ccs_facility_procedure ON public.case_completion_stats USING btree (facility_id, procedure_type_id);


--
-- Name: idx_ccs_facility_surgeon_procedure; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ccs_facility_surgeon_procedure ON public.case_completion_stats USING btree (facility_id, surgeon_id, procedure_type_id);


--
-- Name: idx_ccs_not_excluded; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ccs_not_excluded ON public.case_completion_stats USING btree (facility_id, case_date) WHERE ((is_excluded = false) OR (is_excluded IS NULL));


--
-- Name: idx_ccs_room_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ccs_room_date ON public.case_completion_stats USING btree (or_room_id, case_date);


--
-- Name: idx_ccs_surgeon; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ccs_surgeon ON public.case_completion_stats USING btree (surgeon_id) WHERE (surgeon_id IS NOT NULL);


--
-- Name: idx_ccs_surgeon_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ccs_surgeon_date ON public.case_completion_stats USING btree (surgeon_id, case_date);


--
-- Name: idx_cms_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cms_case ON public.case_milestone_stats USING btree (case_id);


--
-- Name: idx_cms_facility_procedure_milestone; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cms_facility_procedure_milestone ON public.case_milestone_stats USING btree (facility_id, procedure_type_id, milestone_type_id);


--
-- Name: idx_cms_surgeon_procedure_milestone; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cms_surgeon_procedure_milestone ON public.case_milestone_stats USING btree (surgeon_id, procedure_type_id, milestone_type_id);


--
-- Name: idx_complexities_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_complexities_active ON public.complexities USING btree (facility_id, is_active);


--
-- Name: idx_complexities_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_complexities_facility ON public.complexities USING btree (facility_id);


--
-- Name: idx_complexities_facility_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_complexities_facility_active ON public.complexities USING btree (facility_id, is_active) WHERE (deleted_at IS NULL);


--
-- Name: idx_complexity_templates_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_complexity_templates_active ON public.complexity_templates USING btree (is_active) WHERE (deleted_at IS NULL);


--
-- Name: idx_cost_categories_deleted_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cost_categories_deleted_at ON public.cost_categories USING btree (deleted_at);


--
-- Name: idx_cost_categories_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cost_categories_facility ON public.cost_categories USING btree (facility_id);


--
-- Name: idx_cost_category_templates_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cost_category_templates_active ON public.cost_category_templates USING btree (is_active) WHERE (deleted_at IS NULL);


--
-- Name: idx_delay_types_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_delay_types_facility ON public.delay_types USING btree (facility_id);


--
-- Name: idx_delay_types_facility_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_delay_types_facility_active ON public.delay_types USING btree (facility_id, is_active) WHERE (deleted_at IS NULL);


--
-- Name: idx_delay_types_unique_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_delay_types_unique_facility ON public.delay_types USING btree (name, facility_id) WHERE (facility_id IS NOT NULL);


--
-- Name: idx_delay_types_unique_global; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_delay_types_unique_global ON public.delay_types USING btree (name) WHERE (facility_id IS NULL);


--
-- Name: idx_device_rep_invites_email; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_device_rep_invites_email ON public.device_rep_invites USING btree (email);


--
-- Name: idx_device_rep_invites_token; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_device_rep_invites_token ON public.device_rep_invites USING btree (invite_token);


--
-- Name: idx_device_tokens_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_device_tokens_user ON public.device_tokens USING btree (user_id);


--
-- Name: idx_dq_notifications_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_dq_notifications_facility ON public.data_quality_notifications USING btree (facility_id, created_at DESC);


--
-- Name: idx_dq_notifications_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_dq_notifications_user ON public.data_quality_notifications USING btree (user_id, is_read, created_at DESC);


--
-- Name: idx_error_logs_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_logs_category ON public.error_logs USING btree (category);


--
-- Name: idx_error_logs_context_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_logs_context_user ON public.error_logs USING gin (((context -> 'userId'::text)));


--
-- Name: idx_error_logs_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_logs_created_at ON public.error_logs USING btree (created_at DESC);


--
-- Name: idx_error_logs_facility_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_logs_facility_created ON public.error_logs USING btree (facility_id, created_at DESC);


--
-- Name: idx_error_logs_facility_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_logs_facility_id ON public.error_logs USING btree (facility_id);


--
-- Name: idx_error_logs_severity; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_error_logs_severity ON public.error_logs USING btree (severity);


--
-- Name: idx_escort_status_links_checkin; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_escort_status_links_checkin ON public.escort_status_links USING btree (checkin_id);


--
-- Name: idx_escort_status_links_token; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_escort_status_links_token ON public.escort_status_links USING btree (token) WHERE (is_active = true);


--
-- Name: idx_facility_closures_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_closures_date ON public.facility_closures USING btree (closure_date);


--
-- Name: idx_facility_closures_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_closures_facility ON public.facility_closures USING btree (facility_id);


--
-- Name: idx_facility_device_reps_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_device_reps_facility ON public.facility_device_reps USING btree (facility_id);


--
-- Name: idx_facility_device_reps_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_device_reps_status ON public.facility_device_reps USING btree (status);


--
-- Name: idx_facility_device_reps_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_device_reps_user ON public.facility_device_reps USING btree (user_id);


--
-- Name: idx_facility_features_enabled; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_features_enabled ON public.facility_features USING btree (facility_id, is_enabled) WHERE (is_enabled = true);


--
-- Name: idx_facility_features_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_features_facility ON public.facility_features USING btree (facility_id);


--
-- Name: idx_facility_features_feature; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_features_feature ON public.facility_features USING btree (feature_id);


--
-- Name: idx_facility_holidays_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_holidays_facility ON public.facility_holidays USING btree (facility_id);


--
-- Name: idx_facility_milestones_deleted_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_milestones_deleted_at ON public.facility_milestones USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_facility_milestones_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_milestones_facility ON public.facility_milestones USING btree (facility_id);


--
-- Name: idx_facility_permissions_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_facility_permissions_lookup ON public.facility_permissions USING btree (facility_id, access_level);


--
-- Name: idx_facility_procedure_stats_pk; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_facility_procedure_stats_pk ON public.facility_procedure_stats USING btree (facility_id, procedure_type_id);


--
-- Name: idx_flag_rules_facility_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_flag_rules_facility_id ON public.flag_rules USING btree (facility_id);


--
-- Name: idx_flag_rules_is_enabled; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_flag_rules_is_enabled ON public.flag_rules USING btree (is_enabled);


--
-- Name: idx_flag_rules_metric; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_flag_rules_metric ON public.flag_rules USING btree (metric);


--
-- Name: idx_fms_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_fms_lookup ON public.facility_milestone_stats USING btree (facility_id, procedure_type_id, milestone_type_id);


--
-- Name: idx_implant_companies_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_implant_companies_active ON public.implant_companies USING btree (deleted_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_implant_companies_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_implant_companies_facility ON public.implant_companies USING btree (facility_id);


--
-- Name: idx_implant_companies_facility_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_implant_companies_facility_active ON public.implant_companies USING btree (facility_id, is_active) WHERE (deleted_at IS NULL);


--
-- Name: idx_implant_companies_unique_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_implant_companies_unique_facility ON public.implant_companies USING btree (name, facility_id) WHERE (facility_id IS NOT NULL);


--
-- Name: idx_implant_companies_unique_global; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_implant_companies_unique_global ON public.implant_companies USING btree (name) WHERE (facility_id IS NULL);


--
-- Name: idx_login_attempts_blocked_until; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_login_attempts_blocked_until ON public.login_attempts USING btree (blocked_until);


--
-- Name: idx_login_attempts_email; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_login_attempts_email ON public.login_attempts USING btree (email);


--
-- Name: idx_login_attempts_ip; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_login_attempts_ip ON public.login_attempts USING btree (ip_address);


--
-- Name: idx_metric_issues_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_metric_issues_case ON public.metric_issues USING btree (case_id);


--
-- Name: idx_metric_issues_expires; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_metric_issues_expires ON public.metric_issues USING btree (expires_at) WHERE (resolved_at IS NULL);


--
-- Name: idx_metric_issues_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_metric_issues_facility ON public.metric_issues USING btree (facility_id);


--
-- Name: idx_metric_issues_unresolved; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_metric_issues_unresolved ON public.metric_issues USING btree (facility_id, resolved_at) WHERE (resolved_at IS NULL);


--
-- Name: idx_milestone_types_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_milestone_types_active ON public.milestone_types USING btree (deleted_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_milestone_types_deleted_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_milestone_types_deleted_at ON public.milestone_types USING btree (deleted_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_notification_reads_notification; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_reads_notification ON public.notification_reads USING btree (notification_id);


--
-- Name: idx_notification_reads_user; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notification_reads_user ON public.notification_reads USING btree (user_id);


--
-- Name: idx_notifications_created; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notifications_created ON public.notifications USING btree (created_at DESC);


--
-- Name: idx_notifications_expires; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notifications_expires ON public.notifications USING btree (expires_at);


--
-- Name: idx_notifications_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notifications_facility ON public.notifications USING btree (facility_id);


--
-- Name: idx_or_rooms_display_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_or_rooms_display_order ON public.or_rooms USING btree (facility_id, display_order);


--
-- Name: idx_or_rooms_facility_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_or_rooms_facility_active ON public.or_rooms USING btree (facility_id, is_active) WHERE (deleted_at IS NULL);


--
-- Name: idx_patient_checkins_case; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_patient_checkins_case ON public.patient_checkins USING btree (case_id);


--
-- Name: idx_patient_checkins_date; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_patient_checkins_date ON public.patient_checkins USING btree (facility_id, expected_arrival_time);


--
-- Name: idx_patient_checkins_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_patient_checkins_facility ON public.patient_checkins USING btree (facility_id);


--
-- Name: idx_patient_checkins_status; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_patient_checkins_status ON public.patient_checkins USING btree (patient_status_id);


--
-- Name: idx_patients_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_patients_facility ON public.patients USING btree (facility_id);


--
-- Name: idx_patients_identifier; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_patients_identifier ON public.patients USING btree (facility_id, identifier);


--
-- Name: idx_patients_mrn; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_patients_mrn ON public.patients USING btree (facility_id, mrn) WHERE (mrn IS NOT NULL);


--
-- Name: idx_payers_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_payers_facility ON public.payers USING btree (facility_id);


--
-- Name: idx_payers_facility_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_payers_facility_active ON public.payers USING btree (facility_id, is_active) WHERE (deleted_at IS NULL);


--
-- Name: idx_pci_effective_range; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_pci_effective_range ON public.procedure_cost_items USING btree (procedure_type_id, facility_id, effective_from, effective_to);


--
-- Name: idx_permission_templates_access; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_permission_templates_access ON public.permission_templates USING btree (access_level);


--
-- Name: idx_permissions_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_permissions_category ON public.permissions USING btree (category, sort_order);


--
-- Name: idx_permissions_key; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_permissions_key ON public.permissions USING btree (key);


--
-- Name: idx_preop_checklist_fields_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_preop_checklist_fields_active ON public.preop_checklist_fields USING btree (facility_id, is_active) WHERE ((is_active = true) AND (deleted_at IS NULL));


--
-- Name: idx_preop_checklist_fields_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_preop_checklist_fields_facility ON public.preop_checklist_fields USING btree (facility_id);


--
-- Name: idx_procedure_categories_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_categories_active ON public.procedure_categories USING btree (deleted_at) WHERE (deleted_at IS NULL);


--
-- Name: idx_procedure_categories_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_categories_order ON public.procedure_categories USING btree (display_order);


--
-- Name: idx_procedure_cost_items_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_cost_items_active ON public.procedure_cost_items USING btree (facility_id, procedure_type_id, cost_category_id) WHERE (effective_to IS NULL);


--
-- Name: idx_procedure_cost_items_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_cost_items_facility ON public.procedure_cost_items USING btree (facility_id);


--
-- Name: idx_procedure_cost_items_procedure; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_cost_items_procedure ON public.procedure_cost_items USING btree (procedure_type_id);


--
-- Name: idx_procedure_milestone_config_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_milestone_config_facility ON public.procedure_milestone_config USING btree (facility_id);


--
-- Name: idx_procedure_milestone_config_procedure; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_milestone_config_procedure ON public.procedure_milestone_config USING btree (procedure_type_id);


--
-- Name: idx_procedure_milestone_templates_procedure; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_milestone_templates_procedure ON public.procedure_milestone_templates USING btree (procedure_type_template_id);


--
-- Name: idx_procedure_reimbursements_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_reimbursements_facility ON public.procedure_reimbursements USING btree (facility_id);


--
-- Name: idx_procedure_reimbursements_payer; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_reimbursements_payer ON public.procedure_reimbursements USING btree (payer_id);


--
-- Name: idx_procedure_reimbursements_procedure; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_reimbursements_procedure ON public.procedure_reimbursements USING btree (procedure_type_id);


--
-- Name: idx_procedure_type_templates_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_type_templates_active ON public.procedure_type_templates USING btree (is_active, display_order);


--
-- Name: idx_procedure_types_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_types_category ON public.procedure_types USING btree (procedure_category_id);


--
-- Name: idx_procedure_types_facility_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_procedure_types_facility_active ON public.procedure_types USING btree (facility_id, is_active) WHERE (deleted_at IS NULL);


--
-- Name: idx_procedure_types_unique_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_procedure_types_unique_facility ON public.procedure_types USING btree (name, facility_id) WHERE (facility_id IS NOT NULL);


--
-- Name: idx_procedure_types_unique_global; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_procedure_types_unique_global ON public.procedure_types USING btree (name) WHERE (facility_id IS NULL);


--
-- Name: idx_room_schedules_effective; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_room_schedules_effective ON public.room_schedules USING btree (or_room_id, day_of_week, effective_start, effective_end);


--
-- Name: idx_room_schedules_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_room_schedules_facility ON public.room_schedules USING btree (facility_id);


--
-- Name: idx_room_schedules_room_day; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_room_schedules_room_day ON public.room_schedules USING btree (or_room_id, day_of_week);


--
-- Name: idx_sci_effective_range; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_sci_effective_range ON public.surgeon_cost_items USING btree (surgeon_id, procedure_type_id, facility_id, effective_from, effective_to);


--
-- Name: idx_sms_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_sms_lookup ON public.surgeon_milestone_stats USING btree (facility_id, surgeon_id, procedure_type_id, milestone_type_id);


--
-- Name: idx_sos_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_sos_lookup ON public.surgeon_overall_stats USING btree (facility_id, surgeon_id);


--
-- Name: idx_surgeon_colors_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_surgeon_colors_facility ON public.surgeon_colors USING btree (facility_id);


--
-- Name: idx_surgeon_cost_items_procedure; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_surgeon_cost_items_procedure ON public.surgeon_cost_items USING btree (procedure_type_id);


--
-- Name: idx_surgeon_cost_items_surgeon; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_surgeon_cost_items_surgeon ON public.surgeon_cost_items USING btree (surgeon_id);


--
-- Name: idx_surgeon_milestone_avg_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_surgeon_milestone_avg_lookup ON public.surgeon_milestone_averages USING btree (surgeon_id, procedure_type_id);


--
-- Name: idx_surgeon_preference_companies_pref; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_surgeon_preference_companies_pref ON public.surgeon_preference_companies USING btree (surgeon_preference_id);


--
-- Name: idx_surgeon_preferences_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_surgeon_preferences_facility ON public.surgeon_preferences USING btree (facility_id);


--
-- Name: idx_surgeon_preferences_surgeon; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_surgeon_preferences_surgeon ON public.surgeon_preferences USING btree (surgeon_id);


--
-- Name: idx_surgeon_procedure_avg_lookup; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_surgeon_procedure_avg_lookup ON public.surgeon_procedure_averages USING btree (surgeon_id, procedure_type_id);


--
-- Name: idx_surgeon_procedure_stats_pk; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX idx_surgeon_procedure_stats_pk ON public.surgeon_procedure_stats USING btree (facility_id, surgeon_id, procedure_type_id);


--
-- Name: idx_user_invites_email; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_invites_email ON public.user_invites USING btree (email);


--
-- Name: idx_user_invites_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_invites_facility ON public.user_invites USING btree (facility_id);


--
-- Name: idx_user_invites_pending; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_invites_pending ON public.user_invites USING btree (email, facility_id) WHERE (accepted_at IS NULL);


--
-- Name: idx_user_invites_token; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_invites_token ON public.user_invites USING btree (invite_token);


--
-- Name: idx_user_sessions_expires_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_sessions_expires_at ON public.user_sessions USING btree (expires_at);


--
-- Name: idx_user_sessions_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_sessions_user_id ON public.user_sessions USING btree (user_id);


--
-- Name: idx_users_closing_workflow; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_users_closing_workflow ON public.users USING btree (closing_workflow) WHERE (closing_workflow = 'pa_closes'::text);


--
-- Name: idx_users_facility; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_users_facility ON public.users USING btree (facility_id);


--
-- Name: idx_users_implant_company; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_users_implant_company ON public.users USING btree (implant_company_id);


--
-- Name: idx_users_invitation_token; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_users_invitation_token ON public.users USING btree (invitation_token) WHERE (invitation_token IS NOT NULL);


--
-- Name: idx_users_is_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_users_is_active ON public.users USING btree (is_active);


--
-- Name: mv_facility_health_scores_facility_id; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX mv_facility_health_scores_facility_id ON public.mv_facility_health_scores USING btree (facility_id);


--
-- Name: case_device_companies audit_case_device_companies_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER audit_case_device_companies_trigger AFTER INSERT OR DELETE OR UPDATE ON public.case_device_companies FOR EACH ROW EXECUTE FUNCTION public.audit_case_device_companies_changes();


--
-- Name: case_implants audit_case_implants_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER audit_case_implants_trigger AFTER INSERT OR DELETE OR UPDATE ON public.case_implants FOR EACH ROW EXECUTE FUNCTION public.audit_case_implants_changes();


--
-- Name: cases on_case_completed; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_case_completed AFTER UPDATE ON public.cases FOR EACH ROW WHEN ((old.status_id IS DISTINCT FROM new.status_id)) EXECUTE FUNCTION public.trigger_recalculate_averages();


--
-- Name: cases on_case_status_change_detect_issues; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_case_status_change_detect_issues AFTER UPDATE ON public.cases FOR EACH ROW WHEN ((old.status_id IS DISTINCT FROM new.status_id)) EXECUTE FUNCTION public.trigger_issue_detection_on_case_update();


--
-- Name: facilities on_facility_created_copy_milestones; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_facility_created_copy_milestones AFTER INSERT ON public.facilities FOR EACH ROW EXECUTE FUNCTION public.copy_milestone_settings_to_new_facility();


--
-- Name: facilities on_facility_created_seed_templates; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_facility_created_seed_templates AFTER INSERT ON public.facilities FOR EACH ROW EXECUTE FUNCTION public.trigger_seed_facility_on_create();


--
-- Name: case_milestones on_milestone_recorded_detect_issues; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER on_milestone_recorded_detect_issues AFTER INSERT ON public.case_milestones FOR EACH ROW EXECUTE FUNCTION public.trigger_issue_detection_on_milestone();


--
-- Name: page_registry page_registry_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER page_registry_updated_at BEFORE UPDATE ON public.page_registry FOR EACH ROW EXECUTE FUNCTION public.update_page_registry_timestamp();


--
-- Name: case_implants set_case_implants_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER set_case_implants_updated_at BEFORE UPDATE ON public.case_implants FOR EACH ROW EXECUTE FUNCTION public.update_case_implants_updated_at();


--
-- Name: case_milestones set_case_milestones_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER set_case_milestones_updated_at BEFORE UPDATE ON public.case_milestones FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: cases set_cases_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER set_cases_updated_at BEFORE UPDATE ON public.cases FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: page_registry_categories set_category_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER set_category_updated_at BEFORE UPDATE ON public.page_registry_categories FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: complexity_templates set_complexity_templates_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER set_complexity_templates_updated_at BEFORE UPDATE ON public.complexity_templates FOR EACH ROW EXECUTE FUNCTION public.update_default_complexities_updated_at();


--
-- Name: body_regions sync_soft_delete_body_regions; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_body_regions BEFORE UPDATE ON public.body_regions FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: cancellation_reason_templates sync_soft_delete_cancellation_reason_templates; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_cancellation_reason_templates BEFORE UPDATE ON public.cancellation_reason_templates FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: cancellation_reasons sync_soft_delete_cancellation_reasons; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_cancellation_reasons BEFORE UPDATE ON public.cancellation_reasons FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: complexities sync_soft_delete_complexities; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_complexities BEFORE UPDATE ON public.complexities FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: complexity_templates sync_soft_delete_complexity_templates; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_complexity_templates BEFORE UPDATE ON public.complexity_templates FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: cost_categories sync_soft_delete_cost_categories; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_cost_categories BEFORE UPDATE ON public.cost_categories FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: cost_category_templates sync_soft_delete_cost_category_templates; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_cost_category_templates BEFORE UPDATE ON public.cost_category_templates FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: delay_types sync_soft_delete_delay_types; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_delay_types BEFORE UPDATE ON public.delay_types FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: facility_milestones sync_soft_delete_facility_milestones; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_facility_milestones BEFORE UPDATE ON public.facility_milestones FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: implant_companies sync_soft_delete_implant_companies; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_implant_companies BEFORE UPDATE ON public.implant_companies FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: milestone_types sync_soft_delete_milestone_types; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_milestone_types BEFORE UPDATE ON public.milestone_types FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: or_rooms sync_soft_delete_or_rooms; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_or_rooms BEFORE UPDATE ON public.or_rooms FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: patients sync_soft_delete_patients; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_patients BEFORE UPDATE ON public.patients FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: payers sync_soft_delete_payers; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_payers BEFORE UPDATE ON public.payers FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: preop_checklist_field_templates sync_soft_delete_preop_checklist_field_templates; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_preop_checklist_field_templates BEFORE UPDATE ON public.preop_checklist_field_templates FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: preop_checklist_fields sync_soft_delete_preop_checklist_fields; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_preop_checklist_fields BEFORE UPDATE ON public.preop_checklist_fields FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: procedure_categories sync_soft_delete_procedure_categories; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_procedure_categories BEFORE UPDATE ON public.procedure_categories FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: procedure_type_templates sync_soft_delete_procedure_type_templates; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_procedure_type_templates BEFORE UPDATE ON public.procedure_type_templates FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: procedure_types sync_soft_delete_procedure_types; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_procedure_types BEFORE UPDATE ON public.procedure_types FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: users sync_soft_delete_users; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER sync_soft_delete_users BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.sync_soft_delete_columns();


--
-- Name: flag_rules trg_flag_rules_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_flag_rules_updated_at BEFORE UPDATE ON public.flag_rules FOR EACH ROW EXECUTE FUNCTION public.update_flag_rules_updated_at();


--
-- Name: case_milestones trg_record_case_stats; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_record_case_stats AFTER INSERT ON public.case_milestones FOR EACH ROW EXECUTE FUNCTION public.trigger_record_case_stats();


--
-- Name: cases trg_record_stats_on_validation; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_record_stats_on_validation AFTER UPDATE OF data_validated ON public.cases FOR EACH ROW EXECUTE FUNCTION public.trigger_record_stats_on_validation();


--
-- Name: cases trg_refresh_stats_on_completion; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_refresh_stats_on_completion AFTER UPDATE ON public.cases FOR EACH ROW WHEN ((old.status_id IS DISTINCT FROM new.status_id)) EXECUTE FUNCTION public.trigger_refresh_stats_on_completion();


--
-- Name: cases trg_remove_stats_on_invalidation; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_remove_stats_on_invalidation AFTER UPDATE OF data_validated ON public.cases FOR EACH ROW EXECUTE FUNCTION public.trigger_remove_stats_on_invalidation();


--
-- Name: cases trg_sync_exclusion_to_stats; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_sync_exclusion_to_stats AFTER UPDATE OF is_excluded_from_metrics ON public.cases FOR EACH ROW EXECUTE FUNCTION public.trigger_sync_exclusion_to_stats();


--
-- Name: case_milestones trg_update_case_stats; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_update_case_stats AFTER UPDATE ON public.case_milestones FOR EACH ROW EXECUTE FUNCTION public.trigger_update_case_stats();


--
-- Name: cases trigger_auto_create_patient_checkin; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_auto_create_patient_checkin AFTER INSERT OR UPDATE OF scheduled_date, start_time, procedure_type_id ON public.cases FOR EACH ROW EXECUTE FUNCTION public.auto_create_patient_checkin();


--
-- Name: case_device_companies trigger_case_device_companies_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_case_device_companies_updated_at BEFORE UPDATE ON public.case_device_companies FOR EACH ROW EXECUTE FUNCTION public.update_case_device_companies_updated_at();


--
-- Name: or_rooms trigger_set_room_display_order; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_set_room_display_order BEFORE INSERT ON public.or_rooms FOR EACH ROW EXECUTE FUNCTION public.set_room_display_order();


--
-- Name: case_milestones trigger_update_patient_status_from_milestone; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trigger_update_patient_status_from_milestone AFTER INSERT ON public.case_milestones FOR EACH ROW EXECUTE FUNCTION public.update_patient_status_from_milestone();


--
-- Name: facility_analytics_settings update_facility_analytics_settings_timestamp; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER update_facility_analytics_settings_timestamp BEFORE UPDATE ON public.facility_analytics_settings FOR EACH ROW EXECUTE FUNCTION public.update_analytics_settings_timestamp();


--
-- Name: admin_sessions admin_sessions_admin_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.admin_sessions
    ADD CONSTRAINT admin_sessions_admin_user_id_fkey FOREIGN KEY (admin_user_id) REFERENCES public.users(id);


--
-- Name: admin_sessions admin_sessions_viewing_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.admin_sessions
    ADD CONSTRAINT admin_sessions_viewing_facility_id_fkey FOREIGN KEY (viewing_facility_id) REFERENCES public.facilities(id);


--
-- Name: audit_log audit_log_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE SET NULL;


--
-- Name: block_schedules block_schedules_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.block_schedules
    ADD CONSTRAINT block_schedules_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: block_schedules block_schedules_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.block_schedules
    ADD CONSTRAINT block_schedules_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: block_schedules block_schedules_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.block_schedules
    ADD CONSTRAINT block_schedules_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: cancellation_reason_templates cancellation_reason_templates_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cancellation_reason_templates
    ADD CONSTRAINT cancellation_reason_templates_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES auth.users(id);


--
-- Name: cancellation_reasons cancellation_reasons_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cancellation_reasons
    ADD CONSTRAINT cancellation_reasons_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES auth.users(id);


--
-- Name: cancellation_reasons cancellation_reasons_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cancellation_reasons
    ADD CONSTRAINT cancellation_reasons_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: cancellation_reasons cancellation_reasons_source_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cancellation_reasons
    ADD CONSTRAINT cancellation_reasons_source_template_id_fkey FOREIGN KEY (source_template_id) REFERENCES public.cancellation_reason_templates(id);


--
-- Name: case_completion_stats case_completion_stats_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_completion_stats case_completion_stats_excluded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_excluded_by_fkey FOREIGN KEY (excluded_by) REFERENCES public.users(id);


--
-- Name: case_completion_stats case_completion_stats_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: case_completion_stats case_completion_stats_or_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_or_room_id_fkey FOREIGN KEY (or_room_id) REFERENCES public.or_rooms(id) ON DELETE SET NULL;


--
-- Name: case_completion_stats case_completion_stats_payer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_payer_id_fkey FOREIGN KEY (payer_id) REFERENCES public.payers(id) ON DELETE SET NULL;


--
-- Name: case_completion_stats case_completion_stats_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE SET NULL;


--
-- Name: case_completion_stats case_completion_stats_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_completion_stats
    ADD CONSTRAINT case_completion_stats_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id) ON DELETE SET NULL;


--
-- Name: case_complexities case_complexities_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_complexities
    ADD CONSTRAINT case_complexities_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_complexities case_complexities_complexity_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_complexities
    ADD CONSTRAINT case_complexities_complexity_id_fkey FOREIGN KEY (complexity_id) REFERENCES public.complexities(id) ON DELETE CASCADE;


--
-- Name: case_complexities case_complexities_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_complexities
    ADD CONSTRAINT case_complexities_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: case_delays case_delays_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_delays
    ADD CONSTRAINT case_delays_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_delays case_delays_delay_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_delays
    ADD CONSTRAINT case_delays_delay_type_id_fkey FOREIGN KEY (delay_type_id) REFERENCES public.delay_types(id);


--
-- Name: case_delays case_delays_recorded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_delays
    ADD CONSTRAINT case_delays_recorded_by_fkey FOREIGN KEY (recorded_by) REFERENCES public.users(id);


--
-- Name: case_device_activity case_device_activity_actor_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_activity
    ADD CONSTRAINT case_device_activity_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES public.users(id) ON DELETE SET NULL;


--
-- Name: case_device_activity case_device_activity_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_activity
    ADD CONSTRAINT case_device_activity_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_device_activity case_device_activity_implant_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_activity
    ADD CONSTRAINT case_device_activity_implant_company_id_fkey FOREIGN KEY (implant_company_id) REFERENCES public.implant_companies(id) ON DELETE SET NULL;


--
-- Name: case_device_companies case_device_companies_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_companies
    ADD CONSTRAINT case_device_companies_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_device_companies case_device_companies_confirmed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_companies
    ADD CONSTRAINT case_device_companies_confirmed_by_fkey FOREIGN KEY (confirmed_by) REFERENCES public.users(id);


--
-- Name: case_device_companies case_device_companies_delivered_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_companies
    ADD CONSTRAINT case_device_companies_delivered_by_fkey FOREIGN KEY (delivered_by) REFERENCES public.users(id);


--
-- Name: case_device_companies case_device_companies_implant_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_device_companies
    ADD CONSTRAINT case_device_companies_implant_company_id_fkey FOREIGN KEY (implant_company_id) REFERENCES public.implant_companies(id) ON DELETE RESTRICT;


--
-- Name: case_flags case_flags_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_flags
    ADD CONSTRAINT case_flags_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_flags case_flags_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_flags
    ADD CONSTRAINT case_flags_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL;


--
-- Name: case_flags case_flags_delay_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_flags
    ADD CONSTRAINT case_flags_delay_type_id_fkey FOREIGN KEY (delay_type_id) REFERENCES public.delay_types(id) ON DELETE SET NULL;


--
-- Name: case_flags case_flags_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_flags
    ADD CONSTRAINT case_flags_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: case_flags case_flags_facility_milestone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_flags
    ADD CONSTRAINT case_flags_facility_milestone_id_fkey FOREIGN KEY (facility_milestone_id) REFERENCES public.facility_milestones(id);


--
-- Name: case_flags case_flags_flag_rule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_flags
    ADD CONSTRAINT case_flags_flag_rule_id_fkey FOREIGN KEY (flag_rule_id) REFERENCES public.flag_rules(id) ON DELETE SET NULL;


--
-- Name: case_implant_companies case_implant_companies_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_implant_companies
    ADD CONSTRAINT case_implant_companies_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_implant_companies case_implant_companies_implant_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_implant_companies
    ADD CONSTRAINT case_implant_companies_implant_company_id_fkey FOREIGN KEY (implant_company_id) REFERENCES public.implant_companies(id) ON DELETE CASCADE;


--
-- Name: case_implants case_implants_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_implants
    ADD CONSTRAINT case_implants_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_milestone_stats case_milestone_stats_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestone_stats
    ADD CONSTRAINT case_milestone_stats_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_milestone_stats case_milestone_stats_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestone_stats
    ADD CONSTRAINT case_milestone_stats_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: case_milestone_stats case_milestone_stats_milestone_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestone_stats
    ADD CONSTRAINT case_milestone_stats_milestone_type_id_fkey FOREIGN KEY (milestone_type_id) REFERENCES public.milestone_types(id) ON DELETE CASCADE;


--
-- Name: case_milestone_stats case_milestone_stats_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestone_stats
    ADD CONSTRAINT case_milestone_stats_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE SET NULL;


--
-- Name: case_milestone_stats case_milestone_stats_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestone_stats
    ADD CONSTRAINT case_milestone_stats_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id) ON DELETE SET NULL;


--
-- Name: case_milestones case_milestones_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestones
    ADD CONSTRAINT case_milestones_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_milestones case_milestones_facility_milestone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestones
    ADD CONSTRAINT case_milestones_facility_milestone_id_fkey FOREIGN KEY (facility_milestone_id) REFERENCES public.facility_milestones(id);


--
-- Name: case_milestones case_milestones_recorded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_milestones
    ADD CONSTRAINT case_milestones_recorded_by_fkey FOREIGN KEY (recorded_by) REFERENCES public.users(id);


--
-- Name: case_staff case_staff_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_staff
    ADD CONSTRAINT case_staff_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: case_staff case_staff_removed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_staff
    ADD CONSTRAINT case_staff_removed_by_fkey FOREIGN KEY (removed_by) REFERENCES public.users(id);


--
-- Name: case_staff case_staff_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_staff
    ADD CONSTRAINT case_staff_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.user_roles(id);


--
-- Name: case_staff case_staff_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.case_staff
    ADD CONSTRAINT case_staff_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: cases cases_anesthesiologist_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_anesthesiologist_id_fkey FOREIGN KEY (anesthesiologist_id) REFERENCES public.users(id);


--
-- Name: cases cases_call_time_recorded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_call_time_recorded_by_fkey FOREIGN KEY (call_time_recorded_by) REFERENCES public.users(id);


--
-- Name: cases cases_called_back_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_called_back_by_fkey FOREIGN KEY (called_back_by) REFERENCES public.users(id);


--
-- Name: cases cases_called_next_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_called_next_case_id_fkey FOREIGN KEY (called_next_case_id) REFERENCES public.cases(id);


--
-- Name: cases cases_cancellation_reason_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_cancellation_reason_id_fkey FOREIGN KEY (cancellation_reason_id) REFERENCES public.cancellation_reasons(id);


--
-- Name: cases cases_cancelled_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_cancelled_by_fkey FOREIGN KEY (cancelled_by) REFERENCES auth.users(id);


--
-- Name: cases cases_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: cases cases_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: cases cases_or_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_or_room_id_fkey FOREIGN KEY (or_room_id) REFERENCES public.or_rooms(id);


--
-- Name: cases cases_patient_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_patient_id_fkey FOREIGN KEY (patient_id) REFERENCES public.patients(id) ON DELETE SET NULL;


--
-- Name: cases cases_payer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_payer_id_fkey FOREIGN KEY (payer_id) REFERENCES public.payers(id);


--
-- Name: cases cases_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id);


--
-- Name: cases cases_status_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_status_id_fkey FOREIGN KEY (status_id) REFERENCES public.case_statuses(id);


--
-- Name: cases cases_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id);


--
-- Name: cases cases_validated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cases
    ADD CONSTRAINT cases_validated_by_fkey FOREIGN KEY (validated_by) REFERENCES public.users(id);


--
-- Name: complexities complexities_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.complexities
    ADD CONSTRAINT complexities_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: complexities complexities_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.complexities
    ADD CONSTRAINT complexities_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: complexities complexities_source_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.complexities
    ADD CONSTRAINT complexities_source_template_id_fkey FOREIGN KEY (source_template_id) REFERENCES public.complexity_templates(id) ON DELETE SET NULL;


--
-- Name: complexity_templates complexity_templates_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.complexity_templates
    ADD CONSTRAINT complexity_templates_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: cost_categories cost_categories_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_categories
    ADD CONSTRAINT cost_categories_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: cost_categories cost_categories_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_categories
    ADD CONSTRAINT cost_categories_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: cost_category_templates cost_category_templates_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_category_templates
    ADD CONSTRAINT cost_category_templates_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: data_quality_notifications data_quality_notifications_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.data_quality_notifications
    ADD CONSTRAINT data_quality_notifications_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: data_quality_notifications data_quality_notifications_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.data_quality_notifications
    ADD CONSTRAINT data_quality_notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE SET NULL;


--
-- Name: procedure_milestone_templates default_procedure_milestones_milestone_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_templates
    ADD CONSTRAINT default_procedure_milestones_milestone_type_id_fkey FOREIGN KEY (milestone_type_id) REFERENCES public.milestone_types(id) ON DELETE CASCADE;


--
-- Name: procedure_type_templates default_procedure_types_body_region_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_type_templates
    ADD CONSTRAINT default_procedure_types_body_region_id_fkey FOREIGN KEY (body_region_id) REFERENCES public.body_regions(id);


--
-- Name: procedure_type_templates default_procedure_types_procedure_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_type_templates
    ADD CONSTRAINT default_procedure_types_procedure_category_id_fkey FOREIGN KEY (procedure_category_id) REFERENCES public.procedure_categories(id);


--
-- Name: delay_types delay_types_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.delay_types
    ADD CONSTRAINT delay_types_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: delay_types delay_types_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.delay_types
    ADD CONSTRAINT delay_types_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: device_rep_facility_access device_rep_facility_access_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_facility_access
    ADD CONSTRAINT device_rep_facility_access_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: device_rep_facility_access device_rep_facility_access_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_facility_access
    ADD CONSTRAINT device_rep_facility_access_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: device_rep_invites device_rep_invites_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_invites
    ADD CONSTRAINT device_rep_invites_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: device_rep_invites device_rep_invites_implant_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_invites
    ADD CONSTRAINT device_rep_invites_implant_company_id_fkey FOREIGN KEY (implant_company_id) REFERENCES public.implant_companies(id);


--
-- Name: device_rep_invites device_rep_invites_invited_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_rep_invites
    ADD CONSTRAINT device_rep_invites_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES public.users(id);


--
-- Name: device_tokens device_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.device_tokens
    ADD CONSTRAINT device_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: error_logs error_logs_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.error_logs
    ADD CONSTRAINT error_logs_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE SET NULL;


--
-- Name: escort_status_links escort_status_links_checkin_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.escort_status_links
    ADD CONSTRAINT escort_status_links_checkin_id_fkey FOREIGN KEY (checkin_id) REFERENCES public.patient_checkins(id) ON DELETE CASCADE;


--
-- Name: escort_status_links escort_status_links_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.escort_status_links
    ADD CONSTRAINT escort_status_links_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: escort_status_links escort_status_links_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.escort_status_links
    ADD CONSTRAINT escort_status_links_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: facility_analytics_settings facility_analytics_settings_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_analytics_settings
    ADD CONSTRAINT facility_analytics_settings_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: facility_closures facility_closures_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_closures
    ADD CONSTRAINT facility_closures_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: facility_closures facility_closures_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_closures
    ADD CONSTRAINT facility_closures_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: facility_device_reps facility_device_reps_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_device_reps
    ADD CONSTRAINT facility_device_reps_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: facility_device_reps facility_device_reps_invited_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_device_reps
    ADD CONSTRAINT facility_device_reps_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES public.users(id);


--
-- Name: facility_device_reps facility_device_reps_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_device_reps
    ADD CONSTRAINT facility_device_reps_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: facility_features facility_features_disabled_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_features
    ADD CONSTRAINT facility_features_disabled_by_fkey FOREIGN KEY (disabled_by) REFERENCES public.users(id);


--
-- Name: facility_features facility_features_enabled_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_features
    ADD CONSTRAINT facility_features_enabled_by_fkey FOREIGN KEY (enabled_by) REFERENCES public.users(id);


--
-- Name: facility_features facility_features_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_features
    ADD CONSTRAINT facility_features_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: facility_features facility_features_feature_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_features
    ADD CONSTRAINT facility_features_feature_id_fkey FOREIGN KEY (feature_id) REFERENCES public.features(id) ON DELETE CASCADE;


--
-- Name: facility_holidays facility_holidays_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_holidays
    ADD CONSTRAINT facility_holidays_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: facility_holidays facility_holidays_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_holidays
    ADD CONSTRAINT facility_holidays_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: facility_milestones facility_milestones_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_milestones
    ADD CONSTRAINT facility_milestones_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: facility_milestones facility_milestones_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_milestones
    ADD CONSTRAINT facility_milestones_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: facility_milestones facility_milestones_pair_with_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_milestones
    ADD CONSTRAINT facility_milestones_pair_with_id_fkey FOREIGN KEY (pair_with_id) REFERENCES public.facility_milestones(id);


--
-- Name: facility_milestones facility_milestones_source_milestone_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_milestones
    ADD CONSTRAINT facility_milestones_source_milestone_type_id_fkey FOREIGN KEY (source_milestone_type_id) REFERENCES public.milestone_types(id);


--
-- Name: facility_permissions facility_permissions_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_permissions
    ADD CONSTRAINT facility_permissions_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: facility_permissions facility_permissions_permission_key_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_permissions
    ADD CONSTRAINT facility_permissions_permission_key_fkey FOREIGN KEY (permission_key) REFERENCES public.permissions(key) ON DELETE CASCADE;


--
-- Name: facility_permissions facility_permissions_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.facility_permissions
    ADD CONSTRAINT facility_permissions_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: flag_rules flag_rules_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.flag_rules
    ADD CONSTRAINT flag_rules_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: flag_rules flag_rules_source_rule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.flag_rules
    ADD CONSTRAINT flag_rules_source_rule_id_fkey FOREIGN KEY (source_rule_id) REFERENCES public.flag_rules(id);


--
-- Name: global_milestone_settings global_milestone_settings_milestone_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.global_milestone_settings
    ADD CONSTRAINT global_milestone_settings_milestone_type_id_fkey FOREIGN KEY (milestone_type_id) REFERENCES public.milestone_types(id) ON DELETE CASCADE;


--
-- Name: implant_companies implant_companies_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.implant_companies
    ADD CONSTRAINT implant_companies_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: implant_companies implant_companies_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.implant_companies
    ADD CONSTRAINT implant_companies_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: implant_companies implant_companies_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.implant_companies
    ADD CONSTRAINT implant_companies_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: metric_issues metric_issues_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: metric_issues metric_issues_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: metric_issues metric_issues_facility_milestone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_facility_milestone_id_fkey FOREIGN KEY (facility_milestone_id) REFERENCES public.facility_milestones(id);


--
-- Name: metric_issues metric_issues_issue_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_issue_type_id_fkey FOREIGN KEY (issue_type_id) REFERENCES public.issue_types(id);


--
-- Name: metric_issues metric_issues_milestone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_milestone_id_fkey FOREIGN KEY (milestone_id) REFERENCES public.case_milestones(id);


--
-- Name: metric_issues metric_issues_resolution_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_resolution_type_id_fkey FOREIGN KEY (resolution_type_id) REFERENCES public.resolution_types(id);


--
-- Name: metric_issues metric_issues_resolved_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.metric_issues
    ADD CONSTRAINT metric_issues_resolved_by_fkey FOREIGN KEY (resolved_by) REFERENCES public.users(id);


--
-- Name: milestone_types milestone_types_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.milestone_types
    ADD CONSTRAINT milestone_types_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES auth.users(id);


--
-- Name: milestone_types milestone_types_pair_with_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.milestone_types
    ADD CONSTRAINT milestone_types_pair_with_id_fkey FOREIGN KEY (pair_with_id) REFERENCES public.milestone_types(id);


--
-- Name: notification_reads notification_reads_notification_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_reads
    ADD CONSTRAINT notification_reads_notification_id_fkey FOREIGN KEY (notification_id) REFERENCES public.notifications(id) ON DELETE CASCADE;


--
-- Name: notification_reads notification_reads_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification_reads
    ADD CONSTRAINT notification_reads_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: notifications notifications_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE SET NULL;


--
-- Name: notifications notifications_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: notifications notifications_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_room_id_fkey FOREIGN KEY (room_id) REFERENCES public.or_rooms(id) ON DELETE SET NULL;


--
-- Name: notifications notifications_sent_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_sent_by_fkey FOREIGN KEY (sent_by) REFERENCES public.users(id) ON DELETE SET NULL;


--
-- Name: or_rooms or_rooms_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.or_rooms
    ADD CONSTRAINT or_rooms_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: or_rooms or_rooms_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.or_rooms
    ADD CONSTRAINT or_rooms_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: outlier_review_notes outlier_review_notes_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.outlier_review_notes
    ADD CONSTRAINT outlier_review_notes_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: outlier_review_notes outlier_review_notes_outlier_review_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.outlier_review_notes
    ADD CONSTRAINT outlier_review_notes_outlier_review_id_fkey FOREIGN KEY (outlier_review_id) REFERENCES public.outlier_reviews(id) ON DELETE CASCADE;


--
-- Name: outlier_reviews outlier_reviews_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.outlier_reviews
    ADD CONSTRAINT outlier_reviews_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: outlier_reviews outlier_reviews_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.outlier_reviews
    ADD CONSTRAINT outlier_reviews_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: outlier_reviews outlier_reviews_reviewed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.outlier_reviews
    ADD CONSTRAINT outlier_reviews_reviewed_by_fkey FOREIGN KEY (reviewed_by) REFERENCES public.users(id);


--
-- Name: patient_checkins patient_checkins_case_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_case_id_fkey FOREIGN KEY (case_id) REFERENCES public.cases(id) ON DELETE CASCADE;


--
-- Name: patient_checkins patient_checkins_checked_in_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_checked_in_by_fkey FOREIGN KEY (checked_in_by) REFERENCES public.users(id);


--
-- Name: patient_checkins patient_checkins_checklist_completed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_checklist_completed_by_fkey FOREIGN KEY (checklist_completed_by) REFERENCES public.users(id);


--
-- Name: patient_checkins patient_checkins_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: patient_checkins patient_checkins_patient_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_patient_id_fkey FOREIGN KEY (patient_id) REFERENCES public.patients(id) ON DELETE SET NULL;


--
-- Name: patient_checkins patient_checkins_patient_status_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_patient_status_id_fkey FOREIGN KEY (patient_status_id) REFERENCES public.patient_statuses(id);


--
-- Name: patient_checkins patient_checkins_status_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patient_checkins
    ADD CONSTRAINT patient_checkins_status_updated_by_fkey FOREIGN KEY (status_updated_by) REFERENCES public.users(id);


--
-- Name: patients patients_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patients
    ADD CONSTRAINT patients_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES auth.users(id);


--
-- Name: patients patients_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.patients
    ADD CONSTRAINT patients_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: payers payers_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payers
    ADD CONSTRAINT payers_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: payers payers_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payers
    ADD CONSTRAINT payers_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: permission_templates permission_templates_permission_key_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.permission_templates
    ADD CONSTRAINT permission_templates_permission_key_fkey FOREIGN KEY (permission_key) REFERENCES public.permissions(key) ON DELETE CASCADE;


--
-- Name: permission_templates permission_templates_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.permission_templates
    ADD CONSTRAINT permission_templates_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: preop_checklist_field_templates preop_checklist_field_templates_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preop_checklist_field_templates
    ADD CONSTRAINT preop_checklist_field_templates_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES auth.users(id);


--
-- Name: preop_checklist_fields preop_checklist_fields_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preop_checklist_fields
    ADD CONSTRAINT preop_checklist_fields_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: preop_checklist_fields preop_checklist_fields_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preop_checklist_fields
    ADD CONSTRAINT preop_checklist_fields_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: preop_checklist_fields preop_checklist_fields_source_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.preop_checklist_fields
    ADD CONSTRAINT preop_checklist_fields_source_template_id_fkey FOREIGN KEY (source_template_id) REFERENCES public.preop_checklist_field_templates(id);


--
-- Name: procedure_categories procedure_categories_body_region_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_categories
    ADD CONSTRAINT procedure_categories_body_region_id_fkey FOREIGN KEY (body_region_id) REFERENCES public.body_regions(id) ON DELETE SET NULL;


--
-- Name: procedure_cost_items procedure_cost_items_cost_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_cost_items
    ADD CONSTRAINT procedure_cost_items_cost_category_id_fkey FOREIGN KEY (cost_category_id) REFERENCES public.cost_categories(id) ON DELETE CASCADE;


--
-- Name: procedure_cost_items procedure_cost_items_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_cost_items
    ADD CONSTRAINT procedure_cost_items_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: procedure_cost_items procedure_cost_items_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_cost_items
    ADD CONSTRAINT procedure_cost_items_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE CASCADE;


--
-- Name: procedure_milestone_config procedure_milestone_config_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_config
    ADD CONSTRAINT procedure_milestone_config_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: procedure_milestone_config procedure_milestone_config_facility_milestone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_config
    ADD CONSTRAINT procedure_milestone_config_facility_milestone_id_fkey FOREIGN KEY (facility_milestone_id) REFERENCES public.facility_milestones(id) ON DELETE CASCADE;


--
-- Name: procedure_milestone_config procedure_milestone_config_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_config
    ADD CONSTRAINT procedure_milestone_config_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE CASCADE;


--
-- Name: procedure_milestone_templates procedure_milestone_templates_procedure_type_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_milestone_templates
    ADD CONSTRAINT procedure_milestone_templates_procedure_type_template_id_fkey FOREIGN KEY (procedure_type_template_id) REFERENCES public.procedure_type_templates(id) ON DELETE CASCADE;


--
-- Name: procedure_reimbursements procedure_reimbursements_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_reimbursements
    ADD CONSTRAINT procedure_reimbursements_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: procedure_reimbursements procedure_reimbursements_payer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_reimbursements
    ADD CONSTRAINT procedure_reimbursements_payer_id_fkey FOREIGN KEY (payer_id) REFERENCES public.payers(id) ON DELETE CASCADE;


--
-- Name: procedure_reimbursements procedure_reimbursements_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_reimbursements
    ADD CONSTRAINT procedure_reimbursements_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE CASCADE;


--
-- Name: procedure_type_templates procedure_type_templates_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_type_templates
    ADD CONSTRAINT procedure_type_templates_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: procedure_types procedure_types_body_region_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_types
    ADD CONSTRAINT procedure_types_body_region_id_fkey FOREIGN KEY (body_region_id) REFERENCES public.body_regions(id);


--
-- Name: procedure_types procedure_types_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_types
    ADD CONSTRAINT procedure_types_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: procedure_types procedure_types_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_types
    ADD CONSTRAINT procedure_types_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: procedure_types procedure_types_procedure_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_types
    ADD CONSTRAINT procedure_types_procedure_category_id_fkey FOREIGN KEY (procedure_category_id) REFERENCES public.procedure_categories(id) ON DELETE SET NULL;


--
-- Name: procedure_types procedure_types_source_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_types
    ADD CONSTRAINT procedure_types_source_template_id_fkey FOREIGN KEY (source_template_id) REFERENCES public.procedure_type_templates(id) ON DELETE SET NULL;


--
-- Name: procedure_types procedure_types_technique_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procedure_types
    ADD CONSTRAINT procedure_types_technique_id_fkey FOREIGN KEY (technique_id) REFERENCES public.procedure_techniques(id);


--
-- Name: room_schedules room_schedules_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.room_schedules
    ADD CONSTRAINT room_schedules_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: room_schedules room_schedules_or_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.room_schedules
    ADD CONSTRAINT room_schedules_or_room_id_fkey FOREIGN KEY (or_room_id) REFERENCES public.or_rooms(id) ON DELETE CASCADE;


--
-- Name: surgeon_colors surgeon_colors_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_colors
    ADD CONSTRAINT surgeon_colors_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: surgeon_colors surgeon_colors_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_colors
    ADD CONSTRAINT surgeon_colors_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: surgeon_cost_items surgeon_cost_items_cost_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_cost_items
    ADD CONSTRAINT surgeon_cost_items_cost_category_id_fkey FOREIGN KEY (cost_category_id) REFERENCES public.cost_categories(id) ON DELETE CASCADE;


--
-- Name: surgeon_cost_items surgeon_cost_items_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_cost_items
    ADD CONSTRAINT surgeon_cost_items_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: surgeon_cost_items surgeon_cost_items_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_cost_items
    ADD CONSTRAINT surgeon_cost_items_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE CASCADE;


--
-- Name: surgeon_cost_items surgeon_cost_items_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_cost_items
    ADD CONSTRAINT surgeon_cost_items_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: surgeon_milestone_averages surgeon_milestone_averages_milestone_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_milestone_averages
    ADD CONSTRAINT surgeon_milestone_averages_milestone_type_id_fkey FOREIGN KEY (milestone_type_id) REFERENCES public.milestone_types(id) ON DELETE CASCADE;


--
-- Name: surgeon_milestone_averages surgeon_milestone_averages_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_milestone_averages
    ADD CONSTRAINT surgeon_milestone_averages_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE CASCADE;


--
-- Name: surgeon_milestone_averages surgeon_milestone_averages_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_milestone_averages
    ADD CONSTRAINT surgeon_milestone_averages_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: surgeon_preference_companies surgeon_preference_companies_implant_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preference_companies
    ADD CONSTRAINT surgeon_preference_companies_implant_company_id_fkey FOREIGN KEY (implant_company_id) REFERENCES public.implant_companies(id) ON DELETE CASCADE;


--
-- Name: surgeon_preference_companies surgeon_preference_companies_surgeon_preference_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preference_companies
    ADD CONSTRAINT surgeon_preference_companies_surgeon_preference_id_fkey FOREIGN KEY (surgeon_preference_id) REFERENCES public.surgeon_preferences(id) ON DELETE CASCADE;


--
-- Name: surgeon_preferences surgeon_preferences_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preferences
    ADD CONSTRAINT surgeon_preferences_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: surgeon_preferences surgeon_preferences_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preferences
    ADD CONSTRAINT surgeon_preferences_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: surgeon_preferences surgeon_preferences_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preferences
    ADD CONSTRAINT surgeon_preferences_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE CASCADE;


--
-- Name: surgeon_preferences surgeon_preferences_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_preferences
    ADD CONSTRAINT surgeon_preferences_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: surgeon_procedure_averages surgeon_procedure_averages_procedure_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_procedure_averages
    ADD CONSTRAINT surgeon_procedure_averages_procedure_type_id_fkey FOREIGN KEY (procedure_type_id) REFERENCES public.procedure_types(id) ON DELETE CASCADE;


--
-- Name: surgeon_procedure_averages surgeon_procedure_averages_surgeon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.surgeon_procedure_averages
    ADD CONSTRAINT surgeon_procedure_averages_surgeon_id_fkey FOREIGN KEY (surgeon_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: user_invites user_invites_existing_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_invites
    ADD CONSTRAINT user_invites_existing_user_id_fkey FOREIGN KEY (existing_user_id) REFERENCES public.users(id);


--
-- Name: user_invites user_invites_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_invites
    ADD CONSTRAINT user_invites_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: user_invites user_invites_invited_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_invites
    ADD CONSTRAINT user_invites_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES public.users(id);


--
-- Name: user_invites user_invites_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_invites
    ADD CONSTRAINT user_invites_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.user_roles(id);


--
-- Name: user_sessions user_sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_sessions
    ADD CONSTRAINT user_sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: users users_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES auth.users(id);


--
-- Name: users users_facility_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_facility_id_fkey FOREIGN KEY (facility_id) REFERENCES public.facilities(id) ON DELETE CASCADE;


--
-- Name: users users_implant_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_implant_company_id_fkey FOREIGN KEY (implant_company_id) REFERENCES public.implant_companies(id);


--
-- Name: users users_invited_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES public.users(id);


--
-- Name: users users_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.user_roles(id);


--
-- Name: preop_checklist_fields Admins can manage own facility checklist fields; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage own facility checklist fields" ON public.preop_checklist_fields USING (((public.get_my_access_level() = 'global_admin'::text) OR ((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())))) WITH CHECK (((public.get_my_access_level() = 'global_admin'::text) OR ((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id()))));


--
-- Name: escort_status_links Admins can manage own facility escort links; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage own facility escort links" ON public.escort_status_links USING (((public.get_my_access_level() = 'global_admin'::text) OR ((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())) OR (facility_id = public.get_my_facility_id()))) WITH CHECK (((public.get_my_access_level() = 'global_admin'::text) OR ((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())) OR (facility_id = public.get_my_facility_id())));


--
-- Name: surgeon_colors Admins can manage surgeon colors; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage surgeon colors" ON public.surgeon_colors USING ((((facility_id = public.get_my_facility_id()) AND (public.get_my_access_level() = ANY (ARRAY['facility_admin'::text, 'global_admin'::text]))) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: flag_rules Admins can manage their facility flag rules; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage their facility flag rules" ON public.flag_rules USING ((facility_id IN ( SELECT u.facility_id
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.access_level = ANY (ARRAY['facility_admin'::text, 'global_admin'::text]))))));


--
-- Name: room_schedules Admins can manage their facility room schedules; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage their facility room schedules" ON public.room_schedules USING ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: facility_analytics_settings Admins can manage their facility settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can manage their facility settings" ON public.facility_analytics_settings USING ((facility_id IN ( SELECT u.facility_id
   FROM (public.users u
     JOIN public.user_roles ur ON ((u.role_id = ur.id)))
  WHERE ((u.id = auth.uid()) AND (ur.name = ANY (ARRAY['admin'::text, 'facility_admin'::text]))))));


--
-- Name: audit_log Admins can view audit logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can view audit logs" ON public.audit_log FOR SELECT USING (((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))) OR (EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = ANY (ARRAY['facility_admin'::text, 'admin'::text])) AND (users.facility_id = audit_log.facility_id)))) OR (user_id = auth.uid())));


--
-- Name: error_logs Admins can view error logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Admins can view error logs" ON public.error_logs FOR SELECT USING (((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))) OR (EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = ANY (ARRAY['facility_admin'::text, 'admin'::text])) AND (users.facility_id = error_logs.facility_id))))));


--
-- Name: procedure_categories All authenticated users can view procedure categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All authenticated users can view procedure categories" ON public.procedure_categories FOR SELECT TO authenticated USING (true);


--
-- Name: body_regions All users can view body regions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view body regions" ON public.body_regions FOR SELECT USING ((auth.uid() IS NOT NULL));


--
-- Name: cancellation_reason_templates All users can view cancellation reason templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view cancellation reason templates" ON public.cancellation_reason_templates FOR SELECT USING (true);


--
-- Name: case_statuses All users can view case statuses; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view case statuses" ON public.case_statuses FOR SELECT USING ((auth.uid() IS NOT NULL));


--
-- Name: preop_checklist_field_templates All users can view checklist templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view checklist templates" ON public.preop_checklist_field_templates FOR SELECT USING (true);


--
-- Name: complexity_templates All users can view complexity templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view complexity templates" ON public.complexity_templates FOR SELECT USING (true);


--
-- Name: cost_category_templates All users can view cost category templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view cost category templates" ON public.cost_category_templates FOR SELECT USING (true);


--
-- Name: delay_types All users can view delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view delay types" ON public.delay_types FOR SELECT USING (true);


--
-- Name: features All users can view features; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view features" ON public.features FOR SELECT USING (true);


--
-- Name: global_milestone_settings All users can view global milestone settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view global milestone settings" ON public.global_milestone_settings FOR SELECT USING (true);


--
-- Name: issue_types All users can view issue types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view issue types" ON public.issue_types FOR SELECT USING (true);


--
-- Name: milestone_types All users can view milestone types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view milestone types" ON public.milestone_types FOR SELECT USING ((auth.uid() IS NOT NULL));


--
-- Name: patient_statuses All users can view patient statuses; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view patient statuses" ON public.patient_statuses FOR SELECT USING (true);


--
-- Name: procedure_milestone_templates All users can view procedure milestone templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view procedure milestone templates" ON public.procedure_milestone_templates FOR SELECT USING (true);


--
-- Name: procedure_techniques All users can view procedure techniques; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view procedure techniques" ON public.procedure_techniques FOR SELECT USING ((auth.uid() IS NOT NULL));


--
-- Name: procedure_type_templates All users can view procedure type templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view procedure type templates" ON public.procedure_type_templates FOR SELECT USING (true);


--
-- Name: resolution_types All users can view resolution types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view resolution types" ON public.resolution_types FOR SELECT USING (true);


--
-- Name: user_roles All users can view user roles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "All users can view user roles" ON public.user_roles FOR SELECT USING ((auth.uid() IS NOT NULL));


--
-- Name: error_logs Allow service role to insert errors; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Allow service role to insert errors" ON public.error_logs FOR INSERT WITH CHECK (true);


--
-- Name: escort_status_links Anyone can view active escort links by token; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view active escort links by token" ON public.escort_status_links FOR SELECT TO anon USING (((is_active = true) AND (expires_at > now())));


--
-- Name: facilities Anyone can view facility names; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view facility names" ON public.facilities FOR SELECT USING (true);


--
-- Name: device_rep_invites Anyone can view invite by token; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view invite by token" ON public.device_rep_invites FOR SELECT USING (true);


--
-- Name: user_invites Anyone can view invite by token; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Anyone can view invite by token" ON public.user_invites FOR SELECT USING (true);


--
-- Name: audit_log Authenticated users can insert audit logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can insert audit logs" ON public.audit_log FOR INSERT WITH CHECK ((auth.uid() IS NOT NULL));


--
-- Name: implant_companies Authenticated users can view implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can view implant companies" ON public.implant_companies FOR SELECT TO authenticated USING (true);


--
-- Name: surgeon_milestone_averages Authenticated users can view milestone averages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can view milestone averages" ON public.surgeon_milestone_averages FOR SELECT TO authenticated USING (true);


--
-- Name: permissions Authenticated users can view permissions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can view permissions" ON public.permissions FOR SELECT USING ((auth.uid() IS NOT NULL));


--
-- Name: surgeon_procedure_averages Authenticated users can view procedure averages; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Authenticated users can view procedure averages" ON public.surgeon_procedure_averages FOR SELECT TO authenticated USING (true);


--
-- Name: facility_device_reps Device reps can accept own invites; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can accept own invites" ON public.facility_device_reps FOR UPDATE USING (((user_id = auth.uid()) AND (status = 'pending'::text))) WITH CHECK (((user_id = auth.uid()) AND (status = 'accepted'::text)));


--
-- Name: case_device_activity Device reps can insert case_device_activity; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can insert case_device_activity" ON public.case_device_activity FOR INSERT WITH CHECK (((public.get_my_access_level() = 'device_rep'::text) AND (EXISTS ( SELECT 1
   FROM (public.cases c
     JOIN public.facility_device_reps fdr ON ((fdr.facility_id = c.facility_id)))
  WHERE ((c.id = case_device_activity.case_id) AND (fdr.user_id = auth.uid()) AND (fdr.status = 'accepted'::text))))));


--
-- Name: case_implants Device reps can insert case_implants for their cases; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can insert case_implants for their cases" ON public.case_implants FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM (public.case_implant_companies cic
     JOIN public.users u ON ((u.implant_company_id = cic.implant_company_id)))
  WHERE ((cic.case_id = case_implants.case_id) AND (u.id = auth.uid())))));


--
-- Name: case_implants Device reps can update case_implants for their cases; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can update case_implants for their cases" ON public.case_implants FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM (public.case_implant_companies cic
     JOIN public.users u ON ((u.implant_company_id = cic.implant_company_id)))
  WHERE ((cic.case_id = case_implants.case_id) AND (u.id = auth.uid())))));


--
-- Name: case_device_companies Device reps can update their company case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can update their company case_device_companies" ON public.case_device_companies FOR UPDATE USING (((public.get_my_access_level() = 'device_rep'::text) AND (EXISTS ( SELECT 1
   FROM ((public.cases c
     JOIN public.facility_device_reps fdr ON ((fdr.facility_id = c.facility_id)))
     JOIN public.users u ON ((u.id = fdr.user_id)))
  WHERE ((c.id = case_device_companies.case_id) AND (fdr.user_id = auth.uid()) AND (fdr.status = 'accepted'::text) AND (case_device_companies.implant_company_id = u.implant_company_id))))));


--
-- Name: case_implants Device reps can view case_implants for their cases; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view case_implants for their cases" ON public.case_implants FOR SELECT USING ((EXISTS ( SELECT 1
   FROM (public.case_implant_companies cic
     JOIN public.users u ON ((u.implant_company_id = cic.implant_company_id)))
  WHERE ((cic.case_id = case_implants.case_id) AND (u.id = auth.uid())))));


--
-- Name: cases Device reps can view cases at assigned facilities with their co; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view cases at assigned facilities with their co" ON public.cases FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ((public.device_rep_facility_access drfa
     JOIN public.users u ON ((u.id = drfa.user_id)))
     JOIN public.case_implant_companies cic ON ((cic.case_id = cases.id)))
  WHERE ((drfa.user_id = auth.uid()) AND (drfa.facility_id = cases.facility_id) AND (u.implant_company_id = cic.implant_company_id)))));


--
-- Name: facility_device_reps Device reps can view own access records; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view own access records" ON public.facility_device_reps FOR SELECT USING ((user_id = auth.uid()));


--
-- Name: procedure_types Device reps can view procedures at assigned facilities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view procedures at assigned facilities" ON public.procedure_types FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.device_rep_facility_access drfa
  WHERE ((drfa.user_id = auth.uid()) AND (drfa.facility_id = procedure_types.facility_id)))));


--
-- Name: or_rooms Device reps can view rooms at assigned facilities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view rooms at assigned facilities" ON public.or_rooms FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.device_rep_facility_access drfa
  WHERE ((drfa.user_id = auth.uid()) AND (drfa.facility_id = or_rooms.facility_id)))));


--
-- Name: case_device_activity Device reps can view their case_device_activity; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view their case_device_activity" ON public.case_device_activity FOR SELECT USING (((public.get_my_access_level() = 'device_rep'::text) AND (EXISTS ( SELECT 1
   FROM (public.cases c
     JOIN public.facility_device_reps fdr ON ((fdr.facility_id = c.facility_id)))
  WHERE ((c.id = case_device_activity.case_id) AND (fdr.user_id = auth.uid()) AND (fdr.status = 'accepted'::text))))));


--
-- Name: case_implant_companies Device reps can view their company cases; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view their company cases" ON public.case_implant_companies FOR SELECT USING (((public.get_my_access_level() = 'device_rep'::text) AND (EXISTS ( SELECT 1
   FROM (public.cases c
     JOIN public.facility_device_reps fdr ON ((fdr.facility_id = c.facility_id)))
  WHERE ((c.id = case_implant_companies.case_id) AND (fdr.user_id = auth.uid()) AND (fdr.status = 'accepted'::text)))) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.implant_company_id = u.implant_company_id))))));


--
-- Name: case_device_companies Device reps can view their facility case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view their facility case_device_companies" ON public.case_device_companies FOR SELECT USING (((public.get_my_access_level() = 'device_rep'::text) AND (EXISTS ( SELECT 1
   FROM ((public.cases c
     JOIN public.facility_device_reps fdr ON ((fdr.facility_id = c.facility_id)))
     JOIN public.users u ON ((u.id = fdr.user_id)))
  WHERE ((c.id = case_device_companies.case_id) AND (fdr.user_id = auth.uid()) AND (fdr.status = 'accepted'::text) AND (case_device_companies.implant_company_id = u.implant_company_id))))));


--
-- Name: users Device reps can view users at assigned facilities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Device reps can view users at assigned facilities" ON public.users FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.device_rep_facility_access drfa
  WHERE ((drfa.user_id = auth.uid()) AND (drfa.facility_id = users.facility_id)))));


--
-- Name: case_staff Facility admins can create case staff at own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can create case staff at own facility" ON public.case_staff FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM (public.users u
     JOIN public.cases c ON ((c.facility_id = u.facility_id)))
  WHERE ((u.id = auth.uid()) AND (u.access_level = 'facility_admin'::text) AND (c.id = case_staff.case_id)))));


--
-- Name: device_rep_invites Facility admins can create invites; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can create invites" ON public.device_rep_invites FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: user_invites Facility admins can create invites for own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can create invites for own facility" ON public.user_invites FOR INSERT WITH CHECK (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: patients Facility admins can create patients at own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can create patients at own facility" ON public.patients FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['facility_admin'::text, 'user'::text])) AND (facility_id = public.get_my_facility_id())));


--
-- Name: payers Facility admins can create payers at own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can create payers at own facility" ON public.payers FOR INSERT WITH CHECK (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: procedure_types Facility admins can create procedure types at own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can create procedure types at own facility" ON public.procedure_types FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'facility_admin'::text) AND (users.facility_id = users.facility_id)))));


--
-- Name: or_rooms Facility admins can create rooms at own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can create rooms at own facility" ON public.or_rooms FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'facility_admin'::text) AND (users.facility_id = users.facility_id)))));


--
-- Name: users Facility admins can create users at own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can create users at own facility" ON public.users FOR INSERT WITH CHECK (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: case_implant_companies Facility admins can delete case implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete case implant companies" ON public.case_implant_companies FOR DELETE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_implant_companies.case_id) AND ((c.facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)))))));


--
-- Name: case_device_companies Facility admins can delete case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete case_device_companies" ON public.case_device_companies FOR DELETE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_device_companies.case_id) AND (c.facility_id = public.get_my_facility_id()))))));


--
-- Name: delay_types Facility admins can delete facility delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete facility delay types" ON public.delay_types FOR DELETE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (facility_id = public.get_my_facility_id())));


--
-- Name: facility_device_reps Facility admins can delete facility device reps; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete facility device reps" ON public.facility_device_reps FOR DELETE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: implant_companies Facility admins can delete facility implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete facility implant companies" ON public.implant_companies FOR DELETE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (facility_id = public.get_my_facility_id())));


--
-- Name: device_rep_invites Facility admins can delete invites; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete invites" ON public.device_rep_invites FOR DELETE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: cancellation_reasons Facility admins can delete own facility cancellation reasons; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility cancellation reasons" ON public.cancellation_reasons FOR DELETE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: case_delays Facility admins can delete own facility case delays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility case delays" ON public.case_delays FOR DELETE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (EXISTS ( SELECT 1
   FROM public.cases
  WHERE ((cases.id = case_delays.case_id) AND (cases.facility_id = public.get_my_facility_id()))))));


--
-- Name: case_staff Facility admins can delete own facility case staff; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility case staff" ON public.case_staff FOR DELETE USING ((EXISTS ( SELECT 1
   FROM (public.users u
     JOIN public.cases c ON ((c.facility_id = u.facility_id)))
  WHERE ((u.id = auth.uid()) AND (u.access_level = 'facility_admin'::text) AND (c.id = case_staff.case_id)))));


--
-- Name: user_invites Facility admins can delete own facility invites; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility invites" ON public.user_invites FOR DELETE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: case_milestones Facility admins can delete own facility milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility milestones" ON public.case_milestones FOR DELETE USING ((EXISTS ( SELECT 1
   FROM (public.users u
     JOIN public.cases c ON ((c.facility_id = u.facility_id)))
  WHERE ((u.id = auth.uid()) AND (u.access_level = 'facility_admin'::text) AND (c.id = case_milestones.case_id)))));


--
-- Name: patients Facility admins can delete own facility patients; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility patients" ON public.patients FOR DELETE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: payers Facility admins can delete own facility payers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility payers" ON public.payers FOR DELETE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: procedure_types Facility admins can delete own facility procedure types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility procedure types" ON public.procedure_types FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'facility_admin'::text) AND (users.facility_id = procedure_types.facility_id)))));


--
-- Name: or_rooms Facility admins can delete own facility rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility rooms" ON public.or_rooms FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'facility_admin'::text) AND (users.facility_id = or_rooms.facility_id)))));


--
-- Name: users Facility admins can delete own facility users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete own facility users" ON public.users FOR DELETE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: surgeon_preference_companies Facility admins can delete surgeon preference companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete surgeon preference companies" ON public.surgeon_preference_companies FOR DELETE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (EXISTS ( SELECT 1
   FROM public.surgeon_preferences sp
  WHERE ((sp.id = surgeon_preference_companies.surgeon_preference_id) AND ((sp.facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)))))));


--
-- Name: surgeon_preferences Facility admins can delete surgeon preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can delete surgeon preferences" ON public.surgeon_preferences FOR DELETE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: case_implant_companies Facility admins can insert case implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can insert case implant companies" ON public.case_implant_companies FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_implant_companies.case_id) AND ((c.facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)))))));


--
-- Name: case_device_companies Facility admins can insert case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can insert case_device_companies" ON public.case_device_companies FOR INSERT WITH CHECK (((public.get_my_access_level() = 'facility_admin'::text) AND (EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_device_companies.case_id) AND (c.facility_id = public.get_my_facility_id()))))));


--
-- Name: delay_types Facility admins can insert facility delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can insert facility delay types" ON public.delay_types FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (facility_id = public.get_my_facility_id())));


--
-- Name: facility_device_reps Facility admins can insert facility device reps; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can insert facility device reps" ON public.facility_device_reps FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: implant_companies Facility admins can insert facility implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can insert facility implant companies" ON public.implant_companies FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (facility_id = public.get_my_facility_id())));


--
-- Name: cancellation_reasons Facility admins can insert own facility cancellation reasons; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can insert own facility cancellation reasons" ON public.cancellation_reasons FOR INSERT WITH CHECK (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: surgeon_preference_companies Facility admins can insert surgeon preference companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can insert surgeon preference companies" ON public.surgeon_preference_companies FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (EXISTS ( SELECT 1
   FROM public.surgeon_preferences sp
  WHERE ((sp.id = surgeon_preference_companies.surgeon_preference_id) AND ((sp.facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)))))));


--
-- Name: surgeon_preferences Facility admins can insert surgeon preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can insert surgeon preferences" ON public.surgeon_preferences FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: block_schedules Facility admins can manage own facility block_schedules; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility block_schedules" ON public.block_schedules USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: case_complexities Facility admins can manage own facility case complexities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility case complexities" ON public.case_complexities USING (((public.get_my_access_level() = ANY (ARRAY['facility_admin'::text, 'user'::text])) AND (case_id IN ( SELECT cases.id
   FROM public.cases
  WHERE (cases.facility_id = public.get_my_facility_id()))))) WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['facility_admin'::text, 'user'::text])) AND (case_id IN ( SELECT cases.id
   FROM public.cases
  WHERE (cases.facility_id = public.get_my_facility_id())))));


--
-- Name: facility_closures Facility admins can manage own facility closures; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility closures" ON public.facility_closures USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: complexities Facility admins can manage own facility complexities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility complexities" ON public.complexities USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id()))) WITH CHECK (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: cost_categories Facility admins can manage own facility cost categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility cost categories" ON public.cost_categories USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: facility_holidays Facility admins can manage own facility holidays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility holidays" ON public.facility_holidays USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: facility_milestones Facility admins can manage own facility milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility milestones" ON public.facility_milestones USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: facility_permissions Facility admins can manage own facility permissions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility permissions" ON public.facility_permissions USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id()))) WITH CHECK (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: procedure_cost_items Facility admins can manage own facility procedure cost items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility procedure cost items" ON public.procedure_cost_items USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: procedure_reimbursements Facility admins can manage own facility procedure reimbursement; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility procedure reimbursement" ON public.procedure_reimbursements USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: procedure_milestone_config Facility admins can manage own facility procedure_milestone_con; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility procedure_milestone_con" ON public.procedure_milestone_config USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: surgeon_cost_items Facility admins can manage own facility surgeon cost items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility surgeon cost items" ON public.surgeon_cost_items USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: surgeon_colors Facility admins can manage own facility surgeon_colors; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage own facility surgeon_colors" ON public.surgeon_colors USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: outlier_review_notes Facility admins can manage review notes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage review notes" ON public.outlier_review_notes USING (((EXISTS ( SELECT 1
   FROM public.outlier_reviews
  WHERE ((outlier_reviews.id = outlier_review_notes.outlier_review_id) AND ((outlier_reviews.facility_id = public.get_my_facility_id()) AND (public.get_my_access_level() = ANY (ARRAY['facility_admin'::text, 'global_admin'::text])))))) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: outlier_reviews Facility admins can manage reviews; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can manage reviews" ON public.outlier_reviews USING ((((facility_id = public.get_my_facility_id()) AND (public.get_my_access_level() = ANY (ARRAY['facility_admin'::text, 'global_admin'::text]))) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: case_device_companies Facility admins can update case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update case_device_companies" ON public.case_device_companies FOR UPDATE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_device_companies.case_id) AND (c.facility_id = public.get_my_facility_id()))))));


--
-- Name: delay_types Facility admins can update facility delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update facility delay types" ON public.delay_types FOR UPDATE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (facility_id = public.get_my_facility_id())));


--
-- Name: facility_device_reps Facility admins can update facility device reps; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update facility device reps" ON public.facility_device_reps FOR UPDATE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: implant_companies Facility admins can update facility implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update facility implant companies" ON public.implant_companies FOR UPDATE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND (facility_id = public.get_my_facility_id())));


--
-- Name: facilities Facility admins can update own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility" ON public.facilities FOR UPDATE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (id = public.get_my_facility_id()))) WITH CHECK (((public.get_my_access_level() = 'facility_admin'::text) AND (id = public.get_my_facility_id())));


--
-- Name: cancellation_reasons Facility admins can update own facility cancellation reasons; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility cancellation reasons" ON public.cancellation_reasons FOR UPDATE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: case_delays Facility admins can update own facility case delays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility case delays" ON public.case_delays FOR UPDATE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (EXISTS ( SELECT 1
   FROM public.cases
  WHERE ((cases.id = case_delays.case_id) AND (cases.facility_id = public.get_my_facility_id()))))));


--
-- Name: case_staff Facility admins can update own facility case staff; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility case staff" ON public.case_staff FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM (public.users u
     JOIN public.cases c ON ((c.facility_id = u.facility_id)))
  WHERE ((u.id = auth.uid()) AND (u.access_level = 'facility_admin'::text) AND (c.id = case_staff.case_id)))));


--
-- Name: user_invites Facility admins can update own facility invites; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility invites" ON public.user_invites FOR UPDATE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: metric_issues Facility admins can update own facility metric issues; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility metric issues" ON public.metric_issues FOR UPDATE USING (((facility_id = public.get_my_facility_id()) AND (public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text]))));


--
-- Name: case_milestones Facility admins can update own facility milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility milestones" ON public.case_milestones FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM (public.users u
     JOIN public.cases c ON ((c.facility_id = u.facility_id)))
  WHERE ((u.id = auth.uid()) AND (u.access_level = 'facility_admin'::text) AND (c.id = case_milestones.case_id)))));


--
-- Name: patients Facility admins can update own facility patients; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility patients" ON public.patients FOR UPDATE USING (((public.get_my_access_level() = ANY (ARRAY['facility_admin'::text, 'user'::text])) AND (facility_id = public.get_my_facility_id())));


--
-- Name: payers Facility admins can update own facility payers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility payers" ON public.payers FOR UPDATE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: procedure_types Facility admins can update own facility procedure types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility procedure types" ON public.procedure_types FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'facility_admin'::text) AND (users.facility_id = procedure_types.facility_id)))));


--
-- Name: or_rooms Facility admins can update own facility rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility rooms" ON public.or_rooms FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'facility_admin'::text) AND (users.facility_id = or_rooms.facility_id)))));


--
-- Name: users Facility admins can update own facility users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update own facility users" ON public.users FOR UPDATE USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: surgeon_preferences Facility admins can update surgeon preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can update surgeon preferences" ON public.surgeon_preferences FOR UPDATE USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: users Facility admins can view device reps with facility access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can view device reps with facility access" ON public.users FOR SELECT USING (((access_level = 'device_rep'::text) AND (EXISTS ( SELECT 1
   FROM public.facility_device_reps fdr
  WHERE ((fdr.user_id = users.id) AND (fdr.facility_id = public.get_my_facility_id()) AND (fdr.status <> 'revoked'::text))))));


--
-- Name: audit_log Facility admins can view own facility audit logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can view own facility audit logs" ON public.audit_log FOR SELECT USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: facility_device_reps Facility admins can view own facility device reps; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can view own facility device reps" ON public.facility_device_reps FOR SELECT USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: device_rep_invites Facility admins can view own facility invites; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can view own facility invites" ON public.device_rep_invites FOR SELECT USING (((public.get_my_access_level() = ANY (ARRAY['global_admin'::text, 'facility_admin'::text])) AND ((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))));


--
-- Name: user_invites Facility admins can view own facility invites; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can view own facility invites" ON public.user_invites FOR SELECT USING (((public.get_my_access_level() = 'facility_admin'::text) AND (facility_id = public.get_my_facility_id())));


--
-- Name: permission_templates Facility admins can view permission templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility admins can view permission templates" ON public.permission_templates FOR SELECT USING ((public.get_my_access_level() = 'facility_admin'::text));


--
-- Name: case_device_activity Facility users can insert case_device_activity; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility users can insert case_device_activity" ON public.case_device_activity FOR INSERT WITH CHECK (((public.get_my_access_level() = ANY (ARRAY['facility_admin'::text, 'user'::text])) AND (EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_device_activity.case_id) AND (c.facility_id = public.get_my_facility_id()))))));


--
-- Name: case_device_activity Facility users can view own facility case_device_activity; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility users can view own facility case_device_activity" ON public.case_device_activity FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_device_activity.case_id) AND (c.facility_id = public.get_my_facility_id())))));


--
-- Name: case_device_companies Facility users can view own facility case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Facility users can view own facility case_device_companies" ON public.case_device_companies FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_device_companies.case_id) AND (c.facility_id = public.get_my_facility_id())))));


--
-- Name: body_regions Global admins can create body regions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create body regions" ON public.body_regions FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_staff Global admins can create case staff; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create case staff" ON public.case_staff FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_statuses Global admins can create case statuses; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create case statuses" ON public.case_statuses FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: facilities Global admins can create facilities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create facilities" ON public.facilities FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: metric_issues Global admins can create metric issues; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create metric issues" ON public.metric_issues FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: milestone_types Global admins can create milestone types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create milestone types" ON public.milestone_types FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_milestones Global admins can create milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create milestones" ON public.case_milestones FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: patients Global admins can create patients; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create patients" ON public.patients FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: payers Global admins can create payers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create payers" ON public.payers FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_techniques Global admins can create procedure techniques; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create procedure techniques" ON public.procedure_techniques FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: procedure_types Global admins can create procedure types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create procedure types" ON public.procedure_types FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: or_rooms Global admins can create rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create rooms" ON public.or_rooms FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: user_roles Global admins can create user roles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create user roles" ON public.user_roles FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: users Global admins can create users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can create users" ON public.users FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: body_regions Global admins can delete body regions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete body regions" ON public.body_regions FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: cancellation_reason_templates Global admins can delete cancellation reason templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete cancellation reason templates" ON public.cancellation_reason_templates FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: cancellation_reasons Global admins can delete cancellation reasons; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete cancellation reasons" ON public.cancellation_reasons FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_delays Global admins can delete case delays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete case delays" ON public.case_delays FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_staff Global admins can delete case staff; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete case staff" ON public.case_staff FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_statuses Global admins can delete case statuses; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete case statuses" ON public.case_statuses FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_device_companies Global admins can delete case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete case_device_companies" ON public.case_device_companies FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: delay_types Global admins can delete delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete delay types" ON public.delay_types FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facilities Global admins can delete facilities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete facilities" ON public.facilities FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: delay_types Global admins can delete global delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete global delay types" ON public.delay_types FOR DELETE USING (((public.get_my_access_level() = 'global_admin'::text) AND (facility_id IS NULL)));


--
-- Name: implant_companies Global admins can delete global implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete global implant companies" ON public.implant_companies FOR DELETE USING (((public.get_my_access_level() = 'global_admin'::text) AND (facility_id IS NULL)));


--
-- Name: global_milestone_settings Global admins can delete global milestone settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete global milestone settings" ON public.global_milestone_settings FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: metric_issues Global admins can delete metric issues; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete metric issues" ON public.metric_issues FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: milestone_types Global admins can delete milestone types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete milestone types" ON public.milestone_types FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_milestones Global admins can delete milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete milestones" ON public.case_milestones FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: notifications Global admins can delete notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete notifications" ON public.notifications FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: page_registry Global admins can delete page_registry; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete page_registry" ON public.page_registry FOR DELETE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: patients Global admins can delete patients; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete patients" ON public.patients FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: payers Global admins can delete payers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete payers" ON public.payers FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_categories Global admins can delete procedure categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete procedure categories" ON public.procedure_categories FOR DELETE TO authenticated USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_techniques Global admins can delete procedure techniques; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete procedure techniques" ON public.procedure_techniques FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: procedure_types Global admins can delete procedure types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete procedure types" ON public.procedure_types FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: or_rooms Global admins can delete rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete rooms" ON public.or_rooms FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: user_roles Global admins can delete user roles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete user roles" ON public.user_roles FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: users Global admins can delete users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can delete users" ON public.users FOR DELETE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: block_schedules Global admins can do anything with block_schedules; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can do anything with block_schedules" ON public.block_schedules USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facility_closures Global admins can do anything with facility_closures; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can do anything with facility_closures" ON public.facility_closures USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facility_holidays Global admins can do anything with facility_holidays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can do anything with facility_holidays" ON public.facility_holidays USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: surgeon_colors Global admins can do anything with surgeon_colors; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can do anything with surgeon_colors" ON public.surgeon_colors USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_complexities Global admins can do everything with case_complexities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can do everything with case_complexities" ON public.case_complexities USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: complexities Global admins can do everything with complexities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can do everything with complexities" ON public.complexities USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: cancellation_reason_templates Global admins can insert cancellation reason templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert cancellation reason templates" ON public.cancellation_reason_templates FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: cancellation_reasons Global admins can insert cancellation reasons; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert cancellation reasons" ON public.cancellation_reasons FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_delays Global admins can insert case delays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert case delays" ON public.case_delays FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_device_activity Global admins can insert case_device_activity; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert case_device_activity" ON public.case_device_activity FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_device_companies Global admins can insert case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert case_device_companies" ON public.case_device_companies FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: delay_types Global admins can insert delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert delay types" ON public.delay_types FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: delay_types Global admins can insert global delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert global delay types" ON public.delay_types FOR INSERT WITH CHECK (((public.get_my_access_level() = 'global_admin'::text) AND (facility_id IS NULL)));


--
-- Name: implant_companies Global admins can insert global implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert global implant companies" ON public.implant_companies FOR INSERT WITH CHECK (((public.get_my_access_level() = 'global_admin'::text) AND (facility_id IS NULL)));


--
-- Name: global_milestone_settings Global admins can insert global milestone settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert global milestone settings" ON public.global_milestone_settings FOR INSERT WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: page_registry Global admins can insert page_registry; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert page_registry" ON public.page_registry FOR INSERT TO authenticated WITH CHECK ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: procedure_categories Global admins can insert procedure categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can insert procedure categories" ON public.procedure_categories FOR INSERT TO authenticated WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: admin_sessions Global admins can manage admin sessions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage admin sessions" ON public.admin_sessions USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: patient_checkins Global admins can manage all checkins; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all checkins" ON public.patient_checkins USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: cost_categories Global admins can manage all cost categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all cost categories" ON public.cost_categories USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facility_permissions Global admins can manage all facility permissions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all facility permissions" ON public.facility_permissions USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facility_milestones Global admins can manage all facility_milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all facility_milestones" ON public.facility_milestones USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_cost_items Global admins can manage all procedure cost items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all procedure cost items" ON public.procedure_cost_items USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_reimbursements Global admins can manage all procedure reimbursements; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all procedure reimbursements" ON public.procedure_reimbursements USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_milestone_config Global admins can manage all procedure_milestone_config; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all procedure_milestone_config" ON public.procedure_milestone_config USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: surgeon_cost_items Global admins can manage all surgeon cost items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all surgeon cost items" ON public.surgeon_cost_items USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: user_invites Global admins can manage all user invites; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage all user invites" ON public.user_invites USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: page_registry_categories Global admins can manage categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage categories" ON public.page_registry_categories USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: preop_checklist_field_templates Global admins can manage checklist templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage checklist templates" ON public.preop_checklist_field_templates USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: complexity_templates Global admins can manage complexity templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage complexity templates" ON public.complexity_templates USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: cost_category_templates Global admins can manage cost category templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage cost category templates" ON public.cost_category_templates USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: device_rep_facility_access Global admins can manage facility access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage facility access" ON public.device_rep_facility_access USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facility_features Global admins can manage facility features; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage facility features" ON public.facility_features USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: features Global admins can manage features; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage features" ON public.features USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: patient_statuses Global admins can manage patient statuses; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage patient statuses" ON public.patient_statuses USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: permission_templates Global admins can manage permission templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage permission templates" ON public.permission_templates USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: permissions Global admins can manage permissions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage permissions" ON public.permissions USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_milestone_templates Global admins can manage procedure milestone templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage procedure milestone templates" ON public.procedure_milestone_templates USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_type_templates Global admins can manage procedure type templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can manage procedure type templates" ON public.procedure_type_templates USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: page_registry Global admins can read page_registry; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can read page_registry" ON public.page_registry FOR SELECT TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: body_regions Global admins can update body regions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update body regions" ON public.body_regions FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: cancellation_reason_templates Global admins can update cancellation reason templates; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update cancellation reason templates" ON public.cancellation_reason_templates FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: cancellation_reasons Global admins can update cancellation reasons; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update cancellation reasons" ON public.cancellation_reasons FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_delays Global admins can update case delays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update case delays" ON public.case_delays FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_staff Global admins can update case staff; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update case staff" ON public.case_staff FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_statuses Global admins can update case statuses; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update case statuses" ON public.case_statuses FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_device_companies Global admins can update case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update case_device_companies" ON public.case_device_companies FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: delay_types Global admins can update delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update delay types" ON public.delay_types FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facilities Global admins can update facilities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update facilities" ON public.facilities FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: delay_types Global admins can update global delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update global delay types" ON public.delay_types FOR UPDATE USING (((public.get_my_access_level() = 'global_admin'::text) AND (facility_id IS NULL)));


--
-- Name: implant_companies Global admins can update global implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update global implant companies" ON public.implant_companies FOR UPDATE USING (((public.get_my_access_level() = 'global_admin'::text) AND (facility_id IS NULL)));


--
-- Name: global_milestone_settings Global admins can update global milestone settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update global milestone settings" ON public.global_milestone_settings FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: milestone_types Global admins can update milestone types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update milestone types" ON public.milestone_types FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_milestones Global admins can update milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update milestones" ON public.case_milestones FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: page_registry Global admins can update page_registry; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update page_registry" ON public.page_registry FOR UPDATE TO authenticated USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: patients Global admins can update patients; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update patients" ON public.patients FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: payers Global admins can update payers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update payers" ON public.payers FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_categories Global admins can update procedure categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update procedure categories" ON public.procedure_categories FOR UPDATE TO authenticated USING ((public.get_my_access_level() = 'global_admin'::text)) WITH CHECK ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_techniques Global admins can update procedure techniques; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update procedure techniques" ON public.procedure_techniques FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: procedure_types Global admins can update procedure types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update procedure types" ON public.procedure_types FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: or_rooms Global admins can update rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update rooms" ON public.or_rooms FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: user_roles Global admins can update user roles; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update user roles" ON public.user_roles FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: users Global admins can update users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can update users" ON public.users FOR UPDATE USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: audit_log Global admins can view all audit logs; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all audit logs" ON public.audit_log FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: cancellation_reasons Global admins can view all cancellation reasons; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all cancellation reasons" ON public.cancellation_reasons FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_completion_stats Global admins can view all case completion stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all case completion stats" ON public.case_completion_stats FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_delays Global admins can view all case delays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all case delays" ON public.case_delays FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_milestone_stats Global admins can view all case milestone stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all case milestone stats" ON public.case_milestone_stats FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_staff Global admins can view all case staff; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all case staff" ON public.case_staff FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: case_device_activity Global admins can view all case_device_activity; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all case_device_activity" ON public.case_device_activity FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_device_companies Global admins can view all case_device_companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all case_device_companies" ON public.case_device_companies FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: patient_checkins Global admins can view all checkins; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all checkins" ON public.patient_checkins FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: preop_checklist_fields Global admins can view all checklist fields; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all checklist fields" ON public.preop_checklist_fields FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: cost_categories Global admins can view all cost categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all cost categories" ON public.cost_categories FOR SELECT USING (((public.get_my_access_level() = 'global_admin'::text) AND ((deleted_at IS NULL) OR (deleted_at > (now() - '30 days'::interval)))));


--
-- Name: escort_status_links Global admins can view all escort links; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all escort links" ON public.escort_status_links FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facilities Global admins can view all facilities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all facilities" ON public.facilities FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: facility_device_reps Global admins can view all facility device reps; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all facility device reps" ON public.facility_device_reps FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facility_features Global admins can view all facility features; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all facility features" ON public.facility_features FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: facility_milestones Global admins can view all facility_milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all facility_milestones" ON public.facility_milestones FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: metric_issues Global admins can view all metric issues; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all metric issues" ON public.metric_issues FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: case_milestones Global admins can view all milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all milestones" ON public.case_milestones FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: notifications Global admins can view all notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all notifications" ON public.notifications FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: patients Global admins can view all patients; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all patients" ON public.patients FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: payers Global admins can view all payers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all payers" ON public.payers FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_cost_items Global admins can view all procedure cost items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all procedure cost items" ON public.procedure_cost_items FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_reimbursements Global admins can view all procedure reimbursements; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all procedure reimbursements" ON public.procedure_reimbursements FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_types Global admins can view all procedure types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all procedure types" ON public.procedure_types FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: procedure_milestone_config Global admins can view all procedure_milestone_config; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all procedure_milestone_config" ON public.procedure_milestone_config FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: or_rooms Global admins can view all rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all rooms" ON public.or_rooms FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))));


--
-- Name: surgeon_cost_items Global admins can view all surgeon cost items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all surgeon cost items" ON public.surgeon_cost_items FOR SELECT USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: users Global admins can view all users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Global admins can view all users" ON public.users FOR SELECT TO authenticated USING ((public.get_my_access_level() = 'global_admin'::text));


--
-- Name: login_attempts Service role can manage login attempts; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Service role can manage login attempts" ON public.login_attempts USING (true) WITH CHECK (true);


--
-- Name: metric_issues System can create metric issues; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can create metric issues" ON public.metric_issues FOR INSERT WITH CHECK (true);


--
-- Name: data_quality_notifications System can create notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can create notifications" ON public.data_quality_notifications FOR INSERT WITH CHECK (true);


--
-- Name: case_completion_stats System can delete case completion stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can delete case completion stats" ON public.case_completion_stats FOR DELETE USING (true);


--
-- Name: case_milestone_stats System can delete case milestone stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can delete case milestone stats" ON public.case_milestone_stats FOR DELETE USING (true);


--
-- Name: case_completion_stats System can insert case completion stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can insert case completion stats" ON public.case_completion_stats FOR INSERT WITH CHECK (true);


--
-- Name: case_milestone_stats System can insert case milestone stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can insert case milestone stats" ON public.case_milestone_stats FOR INSERT WITH CHECK (true);


--
-- Name: case_completion_stats System can update case completion stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can update case completion stats" ON public.case_completion_stats FOR UPDATE USING (true);


--
-- Name: case_milestone_stats System can update case milestone stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "System can update case milestone stats" ON public.case_milestone_stats FOR UPDATE USING (true);


--
-- Name: case_flags Users can create delay flags; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create delay flags" ON public.case_flags FOR INSERT WITH CHECK (((flag_type = 'delay'::text) AND (facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid())))));


--
-- Name: case_milestones Users can create milestones at own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create milestones at own facility" ON public.case_milestones FOR INSERT WITH CHECK ((case_id IN ( SELECT c.id
   FROM (public.cases c
     JOIN public.users u ON ((u.facility_id = c.facility_id)))
  WHERE (u.id = auth.uid()))));


--
-- Name: notifications Users can create notifications at own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can create notifications at own facility" ON public.notifications FOR INSERT WITH CHECK ((facility_id = public.get_my_facility_id()));


--
-- Name: notifications Users can delete notifications from own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete notifications from own facility" ON public.notifications FOR DELETE USING ((facility_id = public.get_my_facility_id()));


--
-- Name: device_tokens Users can delete own device tokens; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete own device tokens" ON public.device_tokens FOR DELETE USING ((user_id = auth.uid()));


--
-- Name: surgeon_colors Users can delete surgeon colors for their facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete surgeon colors for their facility" ON public.surgeon_colors FOR DELETE USING ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: user_sessions Users can delete their own sessions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can delete their own sessions" ON public.user_sessions FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: case_implants Users can insert implants for cases at their facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert implants for cases at their facility" ON public.case_implants FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM (public.cases c
     JOIN public.users u ON ((u.facility_id = c.facility_id)))
  WHERE ((c.id = case_implants.case_id) AND (u.id = auth.uid())))));


--
-- Name: device_tokens Users can insert own device tokens; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own device tokens" ON public.device_tokens FOR INSERT WITH CHECK ((user_id = auth.uid()));


--
-- Name: case_delays Users can insert own facility case delays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own facility case delays" ON public.case_delays FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.cases
  WHERE ((cases.id = case_delays.case_id) AND (cases.facility_id = public.get_my_facility_id())))));


--
-- Name: users Users can insert own profile; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert own profile" ON public.users FOR INSERT WITH CHECK ((id = auth.uid()));


--
-- Name: user_sessions Users can insert their own sessions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can insert their own sessions" ON public.user_sessions FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: patient_checkins Users can manage own facility checkins; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can manage own facility checkins" ON public.patient_checkins USING ((facility_id = public.get_my_facility_id())) WITH CHECK ((facility_id = public.get_my_facility_id()));


--
-- Name: surgeon_colors Users can manage surgeon colors for their facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can manage surgeon colors for their facility" ON public.surgeon_colors FOR INSERT WITH CHECK ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: notification_reads Users can mark notifications as read; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can mark notifications as read" ON public.notification_reads FOR INSERT WITH CHECK ((user_id = auth.uid()));


--
-- Name: users Users can read own record; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can read own record" ON public.users FOR SELECT USING ((id = auth.uid()));


--
-- Name: case_flags Users can update flag notes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update flag notes" ON public.case_flags FOR UPDATE USING ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid())))) WITH CHECK ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: case_implants Users can update implants for cases at their facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update implants for cases at their facility" ON public.case_implants FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM (public.cases c
     JOIN public.users u ON ((u.facility_id = c.facility_id)))
  WHERE ((c.id = case_implants.case_id) AND (u.id = auth.uid())))));


--
-- Name: device_tokens Users can update own device tokens; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update own device tokens" ON public.device_tokens FOR UPDATE USING ((user_id = auth.uid()));


--
-- Name: surgeon_colors Users can update surgeon colors for their facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can update surgeon colors for their facility" ON public.surgeon_colors FOR UPDATE USING ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: case_implant_companies Users can view case implant companies for own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view case implant companies for own facility" ON public.case_implant_companies FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.cases c
  WHERE ((c.id = case_implant_companies.case_id) AND ((c.facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))))));


--
-- Name: notifications Users can view facility notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view facility notifications" ON public.notifications FOR SELECT USING (((facility_id = public.get_my_facility_id()) AND (expires_at > now())));


--
-- Name: delay_types Users can view global and own facility delay types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view global and own facility delay types" ON public.delay_types FOR SELECT USING (((facility_id IS NULL) OR (facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: implant_companies Users can view global and own facility implant companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view global and own facility implant companies" ON public.implant_companies FOR SELECT USING (((facility_id IS NULL) OR (facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: procedure_types Users can view global and own facility procedure types; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view global and own facility procedure types" ON public.procedure_types FOR SELECT USING (((facility_id IS NULL) OR (facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: case_implants Users can view implants for cases at their facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view implants for cases at their facility" ON public.case_implants FOR SELECT USING ((EXISTS ( SELECT 1
   FROM (public.cases c
     JOIN public.users u ON ((u.facility_id = c.facility_id)))
  WHERE ((c.id = case_implants.case_id) AND (u.id = auth.uid())))));


--
-- Name: device_tokens Users can view own device tokens; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own device tokens" ON public.device_tokens FOR SELECT USING ((user_id = auth.uid()));


--
-- Name: facilities Users can view own facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility" ON public.facilities FOR SELECT USING ((id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: device_rep_facility_access Users can view own facility access; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility access" ON public.device_rep_facility_access FOR SELECT USING (((user_id = auth.uid()) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: block_schedules Users can view own facility block_schedules; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility block_schedules" ON public.block_schedules FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: cancellation_reasons Users can view own facility cancellation reasons; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility cancellation reasons" ON public.cancellation_reasons FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: case_completion_stats Users can view own facility case completion stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility case completion stats" ON public.case_completion_stats FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: case_complexities Users can view own facility case complexities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility case complexities" ON public.case_complexities FOR SELECT USING ((case_id IN ( SELECT cases.id
   FROM public.cases
  WHERE (cases.facility_id = public.get_my_facility_id()))));


--
-- Name: case_delays Users can view own facility case delays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility case delays" ON public.case_delays FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.cases
  WHERE ((cases.id = case_delays.case_id) AND (cases.facility_id = public.get_my_facility_id())))));


--
-- Name: case_milestone_stats Users can view own facility case milestone stats; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility case milestone stats" ON public.case_milestone_stats FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: case_staff Users can view own facility case staff; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility case staff" ON public.case_staff FOR SELECT USING ((case_id IN ( SELECT c.id
   FROM (public.cases c
     JOIN public.users u ON ((u.facility_id = c.facility_id)))
  WHERE (u.id = auth.uid()))));


--
-- Name: patient_checkins Users can view own facility checkins; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility checkins" ON public.patient_checkins FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: preop_checklist_fields Users can view own facility checklist fields; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility checklist fields" ON public.preop_checklist_fields FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: facility_closures Users can view own facility closures; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility closures" ON public.facility_closures FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: cost_categories Users can view own facility cost categories; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility cost categories" ON public.cost_categories FOR SELECT USING (((facility_id = public.get_my_facility_id()) AND ((deleted_at IS NULL) OR (deleted_at > (now() - '30 days'::interval)))));


--
-- Name: escort_status_links Users can view own facility escort links; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility escort links" ON public.escort_status_links FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: facility_features Users can view own facility features; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility features" ON public.facility_features FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: facility_holidays Users can view own facility holidays; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility holidays" ON public.facility_holidays FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: metric_issues Users can view own facility metric issues; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility metric issues" ON public.metric_issues FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: case_milestones Users can view own facility milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility milestones" ON public.case_milestones FOR SELECT USING ((case_id IN ( SELECT c.id
   FROM (public.cases c
     JOIN public.users u ON ((u.facility_id = c.facility_id)))
  WHERE (u.id = auth.uid()))));


--
-- Name: facility_milestones Users can view own facility milestones; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility milestones" ON public.facility_milestones FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: patients Users can view own facility patients; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility patients" ON public.patients FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: payers Users can view own facility payers; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility payers" ON public.payers FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: facility_permissions Users can view own facility permissions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility permissions" ON public.facility_permissions FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: procedure_cost_items Users can view own facility procedure cost items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility procedure cost items" ON public.procedure_cost_items FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: procedure_reimbursements Users can view own facility procedure reimbursements; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility procedure reimbursements" ON public.procedure_reimbursements FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: procedure_milestone_config Users can view own facility procedure_milestone_config; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility procedure_milestone_config" ON public.procedure_milestone_config FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: outlier_review_notes Users can view own facility review notes; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility review notes" ON public.outlier_review_notes FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.outlier_reviews
  WHERE ((outlier_reviews.id = outlier_review_notes.outlier_review_id) AND ((outlier_reviews.facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))))));


--
-- Name: outlier_reviews Users can view own facility reviews; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility reviews" ON public.outlier_reviews FOR SELECT USING (((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: or_rooms Users can view own facility rooms; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility rooms" ON public.or_rooms FOR SELECT USING ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: surgeon_cost_items Users can view own facility surgeon cost items; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility surgeon cost items" ON public.surgeon_cost_items FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: surgeon_preferences Users can view own facility surgeon preferences; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility surgeon preferences" ON public.surgeon_preferences FOR SELECT USING (((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: surgeon_colors Users can view own facility surgeon_colors; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility surgeon_colors" ON public.surgeon_colors FOR SELECT USING ((facility_id = public.get_my_facility_id()));


--
-- Name: users Users can view own facility users; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own facility users" ON public.users FOR SELECT TO authenticated USING ((facility_id = public.get_my_facility_id()));


--
-- Name: notification_reads Users can view own notification reads; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own notification reads" ON public.notification_reads FOR SELECT USING ((user_id = auth.uid()));


--
-- Name: data_quality_notifications Users can view own notifications; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own notifications" ON public.data_quality_notifications FOR SELECT USING (((user_id = auth.uid()) OR (facility_id = public.get_my_facility_id())));


--
-- Name: users Users can view own record; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view own record" ON public.users FOR SELECT TO authenticated USING ((id = auth.uid()));


--
-- Name: surgeon_colors Users can view surgeon colors for their facility; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view surgeon colors for their facility" ON public.surgeon_colors FOR SELECT USING (((facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text)));


--
-- Name: surgeon_preference_companies Users can view surgeon preference companies; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view surgeon preference companies" ON public.surgeon_preference_companies FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.surgeon_preferences sp
  WHERE ((sp.id = surgeon_preference_companies.surgeon_preference_id) AND ((sp.facility_id = public.get_my_facility_id()) OR (public.get_my_access_level() = 'global_admin'::text))))));


--
-- Name: complexities Users can view templates and own facility complexities; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view templates and own facility complexities" ON public.complexities FOR SELECT USING (((facility_id IS NULL) OR (facility_id = public.get_my_facility_id())));


--
-- Name: case_flags Users can view their facility case flags; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their facility case flags" ON public.case_flags FOR SELECT USING ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: flag_rules Users can view their facility flag rules; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their facility flag rules" ON public.flag_rules FOR SELECT USING (((facility_id IS NULL) OR (facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid())))));


--
-- Name: room_schedules Users can view their facility room schedules; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their facility room schedules" ON public.room_schedules FOR SELECT USING ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: facility_analytics_settings Users can view their facility settings; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their facility settings" ON public.facility_analytics_settings FOR SELECT USING ((facility_id IN ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: user_sessions Users can view their own sessions; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY "Users can view their own sessions" ON public.user_sessions FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: admin_sessions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.admin_sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: audit_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

--
-- Name: block_schedules; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.block_schedules ENABLE ROW LEVEL SECURITY;

--
-- Name: body_regions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.body_regions ENABLE ROW LEVEL SECURITY;

--
-- Name: cancellation_reason_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.cancellation_reason_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: cancellation_reasons; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.cancellation_reasons ENABLE ROW LEVEL SECURITY;

--
-- Name: case_completion_stats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_completion_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: case_complexities; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_complexities ENABLE ROW LEVEL SECURITY;

--
-- Name: case_delays; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_delays ENABLE ROW LEVEL SECURITY;

--
-- Name: case_device_activity; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_device_activity ENABLE ROW LEVEL SECURITY;

--
-- Name: case_device_companies; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_device_companies ENABLE ROW LEVEL SECURITY;

--
-- Name: case_flags; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_flags ENABLE ROW LEVEL SECURITY;

--
-- Name: case_implants; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_implants ENABLE ROW LEVEL SECURITY;

--
-- Name: case_milestone_stats; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_milestone_stats ENABLE ROW LEVEL SECURITY;

--
-- Name: case_milestones; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_milestones ENABLE ROW LEVEL SECURITY;

--
-- Name: case_staff; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_staff ENABLE ROW LEVEL SECURITY;

--
-- Name: case_statuses; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.case_statuses ENABLE ROW LEVEL SECURITY;

--
-- Name: cases; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.cases ENABLE ROW LEVEL SECURITY;

--
-- Name: complexities; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.complexities ENABLE ROW LEVEL SECURITY;

--
-- Name: complexity_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.complexity_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: cost_categories; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.cost_categories ENABLE ROW LEVEL SECURITY;

--
-- Name: cost_category_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.cost_category_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: data_quality_notifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.data_quality_notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: delay_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.delay_types ENABLE ROW LEVEL SECURITY;

--
-- Name: cases delete_cases; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY delete_cases ON public.cases FOR DELETE USING (((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = ANY (ARRAY['global_admin'::text, 'facility_admin'::text]))))) AND ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))) OR (facility_id = ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))))));


--
-- Name: device_rep_facility_access; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.device_rep_facility_access ENABLE ROW LEVEL SECURITY;

--
-- Name: device_tokens; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.device_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: error_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.error_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: escort_status_links; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.escort_status_links ENABLE ROW LEVEL SECURITY;

--
-- Name: facilities; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.facilities ENABLE ROW LEVEL SECURITY;

--
-- Name: facility_analytics_settings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.facility_analytics_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: facility_closures; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.facility_closures ENABLE ROW LEVEL SECURITY;

--
-- Name: facility_features; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.facility_features ENABLE ROW LEVEL SECURITY;

--
-- Name: facility_holidays; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.facility_holidays ENABLE ROW LEVEL SECURITY;

--
-- Name: facility_milestones; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.facility_milestones ENABLE ROW LEVEL SECURITY;

--
-- Name: facility_permissions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.facility_permissions ENABLE ROW LEVEL SECURITY;

--
-- Name: features; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.features ENABLE ROW LEVEL SECURITY;

--
-- Name: flag_rules; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.flag_rules ENABLE ROW LEVEL SECURITY;

--
-- Name: global_milestone_settings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.global_milestone_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: cases insert_cases; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY insert_cases ON public.cases FOR INSERT WITH CHECK ((facility_id = ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid()))));


--
-- Name: issue_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.issue_types ENABLE ROW LEVEL SECURITY;

--
-- Name: login_attempts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.login_attempts ENABLE ROW LEVEL SECURITY;

--
-- Name: metric_issues; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.metric_issues ENABLE ROW LEVEL SECURITY;

--
-- Name: milestone_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.milestone_types ENABLE ROW LEVEL SECURITY;

--
-- Name: notification_reads; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notification_reads ENABLE ROW LEVEL SECURITY;

--
-- Name: notifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: or_rooms; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.or_rooms ENABLE ROW LEVEL SECURITY;

--
-- Name: outlier_review_notes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.outlier_review_notes ENABLE ROW LEVEL SECURITY;

--
-- Name: outlier_reviews; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.outlier_reviews ENABLE ROW LEVEL SECURITY;

--
-- Name: page_registry; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.page_registry ENABLE ROW LEVEL SECURITY;

--
-- Name: page_registry_categories; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.page_registry_categories ENABLE ROW LEVEL SECURITY;

--
-- Name: patient_checkins; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.patient_checkins ENABLE ROW LEVEL SECURITY;

--
-- Name: patient_statuses; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.patient_statuses ENABLE ROW LEVEL SECURITY;

--
-- Name: patients; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.patients ENABLE ROW LEVEL SECURITY;

--
-- Name: payers; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.payers ENABLE ROW LEVEL SECURITY;

--
-- Name: permission_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.permission_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: permissions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.permissions ENABLE ROW LEVEL SECURITY;

--
-- Name: preop_checklist_field_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.preop_checklist_field_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: preop_checklist_fields; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.preop_checklist_fields ENABLE ROW LEVEL SECURITY;

--
-- Name: procedure_categories; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procedure_categories ENABLE ROW LEVEL SECURITY;

--
-- Name: procedure_cost_items; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procedure_cost_items ENABLE ROW LEVEL SECURITY;

--
-- Name: procedure_milestone_config; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procedure_milestone_config ENABLE ROW LEVEL SECURITY;

--
-- Name: procedure_milestone_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procedure_milestone_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: procedure_reimbursements; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procedure_reimbursements ENABLE ROW LEVEL SECURITY;

--
-- Name: procedure_techniques; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procedure_techniques ENABLE ROW LEVEL SECURITY;

--
-- Name: procedure_type_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procedure_type_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: procedure_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procedure_types ENABLE ROW LEVEL SECURITY;

--
-- Name: resolution_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.resolution_types ENABLE ROW LEVEL SECURITY;

--
-- Name: room_schedules; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.room_schedules ENABLE ROW LEVEL SECURITY;

--
-- Name: cases select_cases; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY select_cases ON public.cases FOR SELECT USING (((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))) OR (facility_id = ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid())))));


--
-- Name: surgeon_colors; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.surgeon_colors ENABLE ROW LEVEL SECURITY;

--
-- Name: surgeon_cost_items; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.surgeon_cost_items ENABLE ROW LEVEL SECURITY;

--
-- Name: surgeon_milestone_averages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.surgeon_milestone_averages ENABLE ROW LEVEL SECURITY;

--
-- Name: surgeon_procedure_averages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.surgeon_procedure_averages ENABLE ROW LEVEL SECURITY;

--
-- Name: cases update_cases; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY update_cases ON public.cases FOR UPDATE USING (((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.access_level = 'global_admin'::text)))) OR (facility_id = ( SELECT users.facility_id
   FROM public.users
  WHERE (users.id = auth.uid())))));


--
-- Name: user_invites; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_invites ENABLE ROW LEVEL SECURITY;

--
-- Name: user_roles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

--
-- Name: user_sessions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: users; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

--
-- PostgreSQL database dump complete
--

-- end of baseline

